{"meta":{"title":"yangxiaofeng的博客","subtitle":"","description":"","author":"yangxiaofeng","url":"https://xiao_feng_yang993.gitee.io"},"pages":[{"title":"about","date":"2022-01-29T09:02:30.000Z","updated":"2022-02-23T15:46:12.859Z","comments":true,"path":"about/index.html","permalink":"https://xiao_feng_yang993.gitee.io/about/index.html","excerpt":"","text":"yangxiaofeng简历"},{"title":"categories","date":"2020-03-08T11:36:25.013Z","updated":"2020-03-08T05:44:26.852Z","comments":true,"path":"categories/index.html","permalink":"https://xiao_feng_yang993.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-08T05:48:13.194Z","updated":"2020-03-08T05:48:13.194Z","comments":true,"path":"tags/index.html","permalink":"https://xiao_feng_yang993.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"vscode图形界面在qemu上调试裸机程序","slug":"vscode图形界面在qemu上调试裸机程序","date":"2022-02-23T15:14:44.000Z","updated":"2022-02-23T15:15:22.606Z","comments":true,"path":"2022/02/23/vscode图形界面在qemu上调试裸机程序/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2022/02/23/vscode%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%9C%A8qemu%E4%B8%8A%E8%B0%83%E8%AF%95%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"1. 准备工作1）从扩展安装ms-vscode.cpptools插件2）配置文件launch.json&emsp;&emsp;从顶层目录打开miniOS项目，编辑debug配置文件launch.json，点击debug，创建launch.json文件，输入以下内容，重点在miDebuggerServerAddress设置为qemu对外暴露的调试端口IP填写qemu虚拟机所在的主机IP。program填写调试目标文件路径，绝对路径或相对路径都可，workspace表示项目目录，fileDirname表示当前focus所在编辑页面的文件目录。MIMode填写gdb，miDebuggerPath填写gdb程序的路径，如果是ARM程序需要使用ARM版GDB，x86程序使用x86的GDB。 1234567891011121314151617181920\"version\": \"0.2.0\",\"configurations\": [&#123; \"name\": \"kernel-debug\", \"type\": \"cppdbg\", \"request\": \"launch\", \"miDebuggerServerAddress\": \"127.0.0.1:1234\", \"program\": \"$&#123;fileDirname&#125;/kernel.gdb.bin\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"$&#123;fileDirname&#125;\", \"environment\": [], \"externalConsole\": false, \"logging\": &#123; \"engineLogging\": false &#125;, \"MIMode\": \"gdb\", \"miDebuggerPath\": \"/usr/bin/gdb\",&#125;] 2. 启动调试1）首先在命令行界面启动带gdb调试的qemu1qemu-system-i386 -m 2048 -hda b.img -boot order=a -ctrl-grab -gdb tcp::1234 -S -monitor stdio 2) 在vscode中启动调试可以看到左侧有调试窗口分别是变量，监视，调用堆栈，断点。 C语言部分的调试已经很熟悉了，重点说一下汇编的调试.&emsp;&emsp;汇编部分要先设置断点后启动vscode调试程序，这点很重要，否则程序将直接执行到C语言的main函数入口。比如要调试kernel.asm的_start函数，则在断点窗口添加_start断点，注意由于汇编程序不能通过鼠标在源码上设置断点，只能在断点窗口输入断点位置后启动debuger程序，程序将停在_start函数入口处。如下图所示：&emsp;&emsp;虽然停在_start了，可是编辑器的源码上没有任何光标指示，只能在调试控制台根据提示 用-exec disassemble这样的命令来执行GDB指令。&emsp;&emsp;这样的原因推测是miniOS项目用的是nasm编译器来编译汇编程序，与GDB兼容性低造成的，因为ARM移植工作的miniOS完全采用gcc编译器，就能显示光标在源文件上，如下图所示为使用GCC编译汇编程序的调试效果。&emsp;&emsp;虽然x86的汇编上没有光标，但是可以通过反汇编来实现汇编级别的图形化调试，如下所示。可以看到反汇编的指令&emsp;&emsp;这样还是有问题，发现有几条反汇编的指令与汇编源码不同，这是因为编译和反汇编采用的编译器不同造成的。但除了前2条指令其他反汇编指令还算正常，所以在通过图形界面设置断点的时候不能设置在错误的反汇编指令上，否则是不能起作用的甚至可能奔溃。可以在调试控制台 -exec b xxx来设置正确的断点。&emsp;&emsp;总之对于用nasm编译的汇编程序更推荐在调试控制台来调试，反汇编界面只作为参考。&emsp;&emsp;即使要用图形界面调试汇编也要先用-exec ni在调试控制台将反汇编错误的指令过去了再用图形界面调试。 3）错误的反汇编指令例子：&emsp;&emsp;可以看到当前指令的前面2条指令反汇编结果错误，在反汇编无误的时候才能在图形界面设置断点和单步调试。否则vscode会奔溃。","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://xiao_feng_yang993.gitee.io/tags/vscode/"},{"name":"汇编","slug":"汇编","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E6%B1%87%E7%BC%96/"},{"name":"调试","slug":"调试","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E8%B0%83%E8%AF%95/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"内嵌汇编","slug":"内嵌汇编","date":"2020-11-19T15:38:26.000Z","updated":"2022-01-29T14:54:52.985Z","comments":true,"path":"2020/11/19/内嵌汇编/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/11/19/%E5%86%85%E5%B5%8C%E6%B1%87%E7%BC%96/","excerpt":"","text":"内嵌汇编学习操作系统高级教程上面需要阅读Linux内核0.11的源码，其中在书《Linux内核设计的一书》第2.5节异常处理类中段服务程序挂接的部分，遇到了嵌入在C语言中的汇编代码，之前从来没有学习过汇编，因此记录下。 AT&amp;T基础知识内嵌汇编使用的是AT&amp;T汇编，所以首先稍微讲解下AT&amp;T的汇编指令的基础知识。 1234### 操作数前缀movl $8,%eax movl $0xffff,%ebx int $0x80 看到在AT%T汇编中诸如”%eax”、”%ebx”之类的寄存器名字前都要加上”%”；”$8”、”$0xffff”这样的立即数之前都要加上”$”。 源/目的操作数顺序在Intel语法中，第一个操作数是目的操作数，第二个操作数源操作数。而在AT&amp;T中，第一个数是源操作数，第二个数是目的操作数。 // INTEL语法MOV EAX,8 //EAX是目的操作数， 8是源操作数// AT&amp;T语法movl $8,%eax //8是源操作数 EAX是目的操作数 标识长度的操作码后缀在AT&amp;T的操作码后面有时还会有一个后缀，其含义就是指出操作码的大小。“l”表示长整数（32位），“w”表示字（16位），“b”表示字节（8位）。 1234movb %bl,%almovw %bx,%axmovl %ebx,%eaxmovl (%ebx),%eax GCC内嵌汇编Linux操作系统内核代码绝大部分使用C语言编写，只有一小部分使用汇编语言编写，例如与特定体系结构相关的代码和对性能影响很大的代码。GCC提供了内嵌汇编的功能，可以在C代码中直接内嵌汇编语言语句，大大方便了程序设计。 基本行内汇编基本行内汇编很容易理解，一般是按照下面的格式： 1asm(“statements”); 在“asm”后面有时也会加上“volatile”表示编译器不要优化代码，后面的指令保留原样 1__asm__ __volatile__(&quot;hlt&quot;); 如果有很多行汇编，则每一行后要加上“\\n\\t” ： 123asm( &quot;pushl %eax\\n\\t&quot; &quot;movl $0,%eax\\n\\t&quot;&quot;popl %eax&quot;); 或者我们也可以分成几行来写，如： 123asm(&quot;movl %eax,%ebx&quot;);asm(&quot;xorl %ebx,%edx&quot;);asm(&quot;movl $0,_booga); 通常使用汇编语句最方便的方式是把它们放在一个宏内，而宏语句需要在一行上定义，因此使用反斜杠\\将这些语句连成一行，所以上述语句如果在宏中定义的话就是： 123asm( &quot;pushl %eax; \\ movl $0,%eax; \\popl %eax&quot;); 扩展的行内汇编在扩展的行内汇编中，可以将C语言表达式（比如C语言中的变量）指定为汇编指令的操作数，而且不用去管如何将C语言表达式的值读入寄存器，以及如何将计算结果写回C变量，你只要告诉程序中C语言表达式与汇编指令操作数之间的对应关系即可， GCC会自动插入代码完成必要的操作。 使用内嵌汇编，要先编写汇编指令模板，然后将C语言表达式与指令的操作数相关联，并告诉GCC对这些操作有哪些限制条件。例如下面的内嵌汇编语句： 1234567int main()&#123; int input = 8; int result = 0; __asm__ __violate__ (\"movl %1,%0\" : \"=r\" (result) : \"r\" (input)); printf(\"%d\\n\",result); return 0;&#125; “movl %1,%0”是指令模板；“%0”和“%1”代表指令的操作数，称为占位符，“=r”代表它之后是输入变量且需用到寄存器，指令模板后面用小括号括起来的是C语言表达式 ，其中input是输入变量，该指令会完成把input的值复制到result中的操作 。 扩展的行内汇编的语法内嵌汇编语法如下： 1234567asm(&quot;汇编语句模块&quot;:输出寄存器 :输入寄存器 :会被修改的寄存器); 即格式为asm ( “statements” : output_regs : input_regs : clobbered_regs) 汇编语句模块必不可少，其他三部分可选，如果使用了后面的部分，而前面部分为空，也需要用“:”格开，相应部分内容为空。 汇编语句模块汇编语句模块由汇编语句序列组成，语句之间使用“;”、“\\n”或“\\n\\t”分开。指令中的操作数可以使用占位符引用C语言变量，操作数占位符最多10个，名称如下：%0，%1…，%9。指令中使用占位符表示的操作数，总被视为long型（4，个字节），但对其施加的操作根据指令可以是字或者字节，当把操作数当作字或者字节使用时，默认为低字或者低字节。对字节操作可以显式的指明是低字节还是次字节。方法是在%和序号之间插入一个字母，“b”代表低字节，“h”代表高字节，例如：%h1。 占位符的理解：将汇编输出寄存器与输入寄存器从输出寄存器行开始左到右从上到下进行编号分别为：%0，%1…，%9。比如有代码： 12345678910#define get_seg_byte(seg,addr) \\(&#123; \\register char __res; \\__asm__(\"push %%fs; \\mov %%ax,%%fs; \\movb %%fs:%2,%%al; \\pop %%fs\" \\:\"=a\" (__res) \\:\"\" (seg),\"m\" (*(addr))); \\__res;&#125;) 输出寄存器”=a”eax记为%0,输入寄存器””(依然是eax)记为%1,输入寄存器”m”为%2。 输出寄存器描述输出操作数，不同的操作数描述符之间用逗号格开，每个操作数描述符由限定字符串和C语言变量组成。每个输出操作数的限定字符串必须包含“=”，表示它是一个输出操作数。例如： 1__asm__ __volatile__ (\"pushfl ; popl %0 ; cli\":\"=g\" (x) ) 在这里“x”便是最终存放输出结果的C程序变量，而“=g”则是限定字符串，限定字符串表示了对它之后的变量的限制条件 。 输入寄存器描述输入操作数，不同的操作数描述符之间使用逗号格开，每个操作数描述符同样也由限定字符串和C语言表达式或者C语言变量组成。例： asm volatile__ (“lidt %0” : : “m” (real_mode_idt));其中%0是占位操作符，而输出寄存器为空，输入寄存器的值为C语言表达式real_mode_idt。 限定字符串又叫做寄存器加载代码 限定字符 描述 限定字符 描述 a 使用寄存器eax m 使用内存地址 b 使用寄存器ebx o 使用内存地址并可以加偏移值 c 使用寄存器ecx I 使用常数0~31 立即数 d 使用寄存器edx V 操作数是内存变量，但不是偏移寻址 s 使用寄存器esi , 操作数为内存变量，但寻址方式为自动增量 g、X 寄存器或内存 J 使用常数0~63 立即数 i 立即数 K 使用常数0~255立即数 n 立即数，有些系统不支持除字以外的立即数 p 操作数是一个合法的内存地址（指针） D 使用edi L 使用常数0~65535 立即数 q 使用动态分配字节可寻址寄存器（eax、ebx、ecx或edx） M 使用常数0~3 立即数 r 使用任意动态分配的寄存器 N 使用1字节常数（0~255）立即数 g 使用通用有效的地址即可（eax、ebx、ecx、edx或内存变量） O 使用常数0~31 立即数 A 使用eax与edx联合（64位） = 操作数在指令中是只写的（输出操作数） + 操作数在指令中是读写类型的（输入输出操作数） t 第一个浮点寄存器 u 第二个浮点寄存器 G 标准的80387 例子直接摘抄自《Linux内核完全注释》第5.2.2 traps.c程序的第82页 例子1： 1234567891001 #define get_seg_byte(seg,addr) \\02 (&#123; \\03 register char __res; \\04 __asm__(\"push %%fs; \\05 mov %%ax,%%fs; \\06 movb %%fs:%2,%%al; \\07 pop %%fs\" \\08 :\"=a\" (__res) \\09 :\"\" (seg),\"m\" (*(addr))); \\10 __res;&#125;) 第1 行定义了宏的名称，也即是宏函数名称 get_seg_byte(seg,addr) 。第 3 行定义了一个寄存器变量 res 。第 4 行上的 asm表示嵌入汇编语句的开始。从第 4 行到第 7 行的 4 条语句是 AT&amp;T 格式的汇编语句。 第 8 行即是输出寄存器，这句的含义是在这段代码运行结束后将 eax 所代表的寄存器的值放入__res变量中，作为本函数的输出值， “=a” 中的 “a” 称为加载代码， “=” 表示这是输出寄存器。第 9 行表示在这段代码开始运行时将 seg 放到 eax 寄存器中， “” 表示使用与上面同个位置的输出相同的寄存器。而 ((addr))表示一个内存偏移地址值。为了在上面汇编语句中使用该地址值，嵌入汇编程序规定把输出和输入寄存器统一按顺序编号，顺序是从输出寄存器序列从左到右从上到下以 “%0” 开始，分别记为 %0 、 %1 、 …%9 。因此，输出寄存器的编号是 %0 （这里只有一个输出寄存器），输入寄存器前一部分 (“” (seg)) 的编号是 %1 ，而后部分的编号是 %2 。上面第 6 行上的 %2 即代表 ((addr)) 这个内存偏移量。现在我们来研究 4—7 行上的代码的作用。第一句将 fs 段寄存器的内容入栈；第二句将 eax 中的段值赋给 fs 段寄存器；第三句是把 fs:(*(addr)) 所指定的字节放入 al 寄存器中。当执行完汇编语句后，输出寄存器 eax 的值将被放入 __res ，作为该宏函数（块结构表达式）的返回值。 通过上面分析，我们知道，宏名称中的 seg 代表一指定的内存段值，而 addr 表示一内存偏移地址量。到现在为止，我们应该很清楚这段程序的功能了吧！该宏函数的功能是从指定段和偏移值的内存地址处取一个字节。 通过上面的例子说明，阅读这段代码时应该像CPU处理指令时的逻辑一样，先从输出输入寄存器语句开始知道输入输出是什么，然后再阅读汇编语句，处理完后再看最后的返回是什么。 例子2再来看下Linux 内核中main()中对中断异常挂接的trap_init()中的设计到的一个GCC内嵌汇编。代码路径为；include\\asm\\system.h 123456789101 #define _set_gate(gate_addr,type,dpl,addr) \\2 __asm__ (\"movw %%dx,%%ax\\n\\t\" \\3 \"movw %0,%%dx\\n\\t\" \\4 \"movl %%eax,%1\\n\\t\" \\5 \"movl %%edx,%2\" \\6 : \\7 : \"i\" ((short) (0x8000+(dpl&lt;&lt;13)+(type&lt;&lt;8))), \\8 \"o\" (*((char *) (gate_addr))), \\9 \"o\" (*(4+(char *) (gate_addr))), \\10 \"d\" ((char *) (addr)),\"a\" (0x00080000)) 首先从第6行输出寄存器开始阅读：输出寄存器为空。然后是第7至10行的输入寄存器。第%0个输入寄存器使用“i”表示输入立即数，第%1个输入寄存器使用“o”表示使用内存地址并可以加偏移值，第%2个输入寄存器依然使用“o”代码，第%3个寄存器使用“d”表示使用寄存器edx，第%4个寄存器使用“a”表示使用寄存器eax。 之后再看下汇编语句：依次进行值的传递。","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"汇编","slug":"汇编","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E6%B1%87%E7%BC%96/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"Docker学习笔记 一：Docker 架构及工作原理","slug":"Docker学习笔记-一：Docker-架构及工作原理","date":"2020-10-10T18:20:11.000Z","updated":"2020-10-10T18:20:14.219Z","comments":true,"path":"2020/10/11/Docker学习笔记-一：Docker-架构及工作原理/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/10/11/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80%EF%BC%9ADocker-%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","excerpt":"","text":"Docker 架构及工作原理摘要：Docker 是一个客户端-服务器（C/S）架构程序。Docker 客户端只需要向 Docker 服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker 提供了一个命令行工具 Docker 以及一整套 RESTful API。 通过下图可以得知，Docker 在运行时分为 Docker 引擎（服务端守护进程） 和 客户端工具，我们日常使用各种 docker 命令，其实就是在使用 客户端工具 与 Docker 引擎 进行交互。 Client 客户端Docker 是一个客户端-服务器（C/S）架构程序。Docker 客户端只需要向 Docker 服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker 提供了一个命令行工具 Docker 以及一整套 RESTful API。你可以在同一台宿主机上运行 Docker 守护进程和客户端，也可以从本地的 Docker 客户端连接到运行在另一台宿主机上的远程 Docker 守护进程。 Host 主机(Docker 引擎)一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。 Image 镜像什么是 Docker 镜像？简单的理解，Docker 镜像就是一个 Linux 的文件系统（Root FileSystem），这个文件系统里面包含可以运行在 Linux 内核的程序以及相应的数据。通过镜像启动一个容器，一个镜像就是一个可执行的包，其中包括运行应用程序所需要的所有内容：包含代码，运行时间，库，环境变量和配置文件等。Docker 把 App 文件打包成为一个镜像，并且采用类似多次快照的存储技术，可以实现： 多个 App 可以共用相同的底层镜像（初始的操作系统镜像）；App 运行时的 IO 操作和镜像文件隔离；通过挂载包含不同配置/数据文件的目录或者卷（Volume），单个 App 镜像可以用来运行无数个不同业务的容器。 Container 容器镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 镜像分层Docker 支持通过扩展现有镜像，创建新的镜像。实际上，Docker Hub 中 99% 的镜像都是通过在 base 镜像中安装和配置需要的软件构建出来的。从上图可以看到，新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。镜像分层最大的一个好处就是共享资源。比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。如果多个容器共享一份基础镜像，当某个容器修改了基础镜像的内容，比如 /etc 下的文件，这时其他容器的 /etc 是不会被修改的，修改只会被限制在单个容器内。这就是容器 Copy-on-Write 特性。 可写的容器层当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。 镜像层数量可能会很多，所有镜像层会联合在一起组成一个统一的文件系统。如果不同层中有一个相同路径的文件，比如 /a，上层的 /a 会覆盖下层的 /a，也就是说用户只能访问到上层中的文件 /a。在容器层中，用户看到的是一个叠加之后的文件系统。 只有当需要修改时才复制一份数据，这种特性被称作 Copy-on-Write。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。 Copy-on-Write:123写入时复制（英语：Copy-on-write，简称COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。以 linux 为例，当通过系统调用（syscall）从一个已经存在的进程 P1 中 fork 出一个子进程 P2，OS会为 P2 创建一套与 P1 保持一致映射关系的虚拟内存空间，从而实现了 P1 和 P2 对物理空间的共享，这样做的目的是为了减少对物理内存的消耗，毕竟两份完全一样的数据没必要额外占用多一倍物理内存空间。此后，如果 P1 或 P2 需要更改某段内存，则须为其按需分配额外物理内存，将共享数据拷贝出来，供其修改，这里注意，无论父还是子进程，只要有修改，就会涉及到内存拷贝，这里的影响粒度范围是内存页，linux 内存页大小为 4KB。 总结下来就是：容器层记录对镜像的修改，所有镜像层都是只读的，不会被容器修改，所以镜像可以被多个容器共享。 Volume 数据卷实际上我们的容器就好像是一个简易版的操作系统，只不过系统中只安装了我们的程序运行所需要的环境，前边说到我们的容器是可以删除的，那如果删除了，容器中的程序产生的需要持久化的数据怎么办呢？容器运行的时候我们可以进容器去查看，容器一旦删除就什么都没有了。 所以数据卷就是来解决这个问题的，是用来将数据持久化到我们宿主机上，与容器间实现数据共享，简单的说就是将宿主机的目录映射到容器中的目录，应用程序在容器中的目录读写数据会同步到宿主机上，这样容器产生的数据就可以持久化了，比如我们的数据库容器，就可以把数据存储到我们宿主机上的真实磁盘中。 Registry 注册中心Docker 用 Registry 来保存用户构建的镜像。Registry 分为公共和私有两种。Docker 公司运营公共的 Registry 叫做 Docker Hub。用户可以在 Docker Hub 注册账号，分享并保存自己的镜像。 Docker 公司提供了公共的镜像仓库 hub.docker.com（Docker 称之为 Repository）提供了庞大的镜像集合供使用。 一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。 通常，一个仓库会包含同一个软件不同版本的镜像，而标签对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。 总结Docker 官网写着这样一句话：Build and Ship any Application Anywhere，再结合刚才我们所理解的内容，总结下来就是：一次构建，到处运行。此外，Docker 公司提供了公共的镜像仓库 hub.docker.com（Docker 称之为 Repository），GitHub connect，自动构建镜像，大大简化了应用分发、部署、升级流程。加上 Docker 可以非常方便的建立各种自定义的镜像文件，这些都是 Docker 成为最流行的容器技术的重要因素。 通过以上这些技术的组合，最后的结果就是：绝大部分应用，开发者都可以通过 docker build 创建镜像，通过 docker push 上传镜像，用户通过 docker pull 下载镜像，使用 docker run 运行容器应用。用户不再需要去关心如何搭建环境，如何安装，如何解决不同发行版的库冲突——而且通常不会消耗更多的硬件资源，不会明显降低性能。","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"},{"name":"docker","slug":"docker","permalink":"https://xiao_feng_yang993.gitee.io/tags/docker/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"石子合并","slug":"石子合并","date":"2020-07-16T16:31:59.000Z","updated":"2020-07-16T16:32:01.820Z","comments":true,"path":"2020/07/17/石子合并/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/07/17/%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/","excerpt":"","text":"题目有一个石子归并的游戏。最开始的时候，有n堆石子排成一列，目标是要将所有的石子合并成一堆。合并规则如下： 每一次可以合并相邻位置的两堆石子每次合并的代价为所合并的两堆石子的重量之和求出最小的合并代价。 样例样例 1: 输入: [3, 4, 3]输出: 17样例 2: 输入: [4, 1, 1, 4]输出: 18解释: 合并第二堆和第三堆 =&gt; [4, 2, 4], score = 2 合并前两堆 =&gt; [6, 4]，score = 8 合并剩余的两堆 =&gt; [10], score = 18解题思路用DP[i][j]来表示把A[i…j]搬到一起需要的score。DP[left][right]可以表示成DP[left][j] + DP[j+1][right] + sum(i,j) 元素i到j求和，可以前缀和求得；即首先形成这两团需要的score，和把这两团加在一起的score（前缀和）。 len要大于等于2才有意义，因为要长度至少为2才能累加。枚举的区间长度，左边是i，右边是i + len - 1。 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: /** * @param A: An integer array * @return: An integer */ int stoneGame(vector&lt;int&gt; &amp;A) &#123; // write your code here int n = A.size(); if(n==0)return 0; if(n==1)return 0; int *sum = (int *)malloc(sizeof(int)*n+1); sum[0]=0; for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+A[i-1]; // int dp[][]=new int[n][n]; int **dp; dp=(int **)malloc(sizeof(int *)*n); for(int i=0;i&lt;n;i++)&#123; dp[i]=(int *)malloc(sizeof(int)*n); &#125; for(int i=0;i&lt;n-1;i++)&#123; dp[i][i]=0; dp[i][i+1]=A[i]+A[i+1]; &#125; dp[n-1][n-1]=0; for(int len = 3;len&lt;=n;len++)&#123; for(int i=0;i&lt;=n-len;i++)&#123; int j=i+len-1; dp[i][j]=999999; for(int k=i;k&lt;j;k++)&#123; dp[i][j]=(dp[i][k]+dp[k+1][j]+sum[j+1]-sum[i]) &lt; dp[i][j]?(dp[i][k]+dp[k+1][j]+sum[j+1]-sum[i]):dp[i][j]; &#125; &#125; &#125; return dp[0][n-1]; &#125;&#125;;","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"dp","slug":"dp","permalink":"https://xiao_feng_yang993.gitee.io/tags/dp/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"软件工程-复习总结","slug":"软件工程-复习总结","date":"2020-07-02T17:32:57.000Z","updated":"2020-07-02T18:09:36.071Z","comments":true,"path":"2020/07/03/软件工程-复习总结/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/07/03/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/","excerpt":"","text":"第一章 软件工程 什么是软件？软件的特点？ 软件是计算机系统中与硬件相互依存的另一部分；它是包括程序，数据，文档的完整集合 软件危机的定义 软件开发和维护过程中所遇到的这一系列严重问题为软件危机： 软件十分复杂，价格昂贵，供需差日益则大 软件开发时常受挫，质量差，进度和完成日期不按时，研制失去控制 软件危机的原因 软件的复杂性：代码量大，系统类型多 软件产品的特殊性：一致性，可变性，不可见性 人们认识的局限性：忽视需求分析，当作编写程序，缺少度量标准，忽视软件维护 什么是软件工程 将系统化的，规范化的，可度量的方法应用于软件开发，运行，维护的过程，将工程化应用于软件中 软件工程是应用计算机科学，数学及管理科学等原理开发软件的工程。借鉴传统工程的原则，方法，以提高质量降低成本为目的 软件工程研究的内容是什么 软件工程以关注软件质量为目标，包括过程，方法和工具三个要素 过程：支持软件生命周期的所有活动 方法：为软件开发过程提供“如何做”的技术 工具：为软件开发方法提供自动或半自动的软件支撑环境 提高软件质量的手段 可靠性：正确性和健壮，正确性和对异常值边界值的处理能力 可维护性：可读性，可修改性，可测试性，完整性 可理解性：简单性，清晰性，可用性 效率： 什么是软件生命周期 一个软件被提出开始研制至软件最终被废弃不再使用为止的全过程，成为软件生命期，包括：软件定义，软件开发及软件运行维护 瀑布模型每一阶段的含义 可行性研究与计划 需求分析 设计 编码 测试 运行维护 瀑布模型的优缺点 优点： 强调开发的阶段性：阶段间具有顺序性和依赖性 强调早期计划及需求调查：推迟实现的观点 强调评审，强调产品测试：质量保证的观点 缺点： 依赖于早期进行的唯一一次需求调查，不能适应需求的变化 由于是单一流程，开发过程中的经验教训不能反馈于应用于本产品的过程 风险往往迟滞后期的开发阶段才显露，因而失去趁早纠正的机会。 文档驱动的，对于非专业用户难以阅读和理解 软件生命模型各自的特点 螺旋模型： 1)螺旋模型将瀑布模型与原型模型结合起来， 并且加入两种模型均忽略了的风险分析。 2)螺旋模型沿着螺线旋转，自内向外每旋转一 圈便开发出更完善的一个新版本。 ◆ 制定计划 确定软件目标，选定实施方案， 弄清项目开发的限制条件； ◆ 风险分析 分析所选方案，考虑如何识别和 消除风险； ◆ 实施工程 实施软件开发 ◆ 客户评估 评价开发，提出修正建议。 增量模型： 1)增量模型是迭代和演进的过程。 2)增量模型把软件产品分解成一系列的增量构件 ，在增量开发迭代中逐步加入。 3)每个构件由多个相互作用的模块构成，并且能够完成特定的功能。 4)早先完成的增量可以为后期的增量提供服务。 5)增量开发方法的新演进版本叫做“极限程序设 计（eXtreme Programming）” 原型模型： 1)原型模型是迭代的。因为软件与所有的复杂系统一样，必须经过不断演化才能完善。 2)原型模型先开发一个“原型”软件，完成部 分主要功能，展示给用户并征求意见，然后 逐步完善，最终获得满意的软件产品。 3)业务和产品需求在变化中，采用线性开发方 式是不实际的。 4)快速实现和提交一个有限的版本，可以应付 市场竞争的压力。 敏捷模型解决什么问题 敏捷过程为了使软件开发团队具有高效工作和快速响应变化的能力。 快速的市场进入时间，要求高生产率 快速变化的需求，需求模糊且经常改变 快速发展的技术 第二章 可行性研究 什么是可行性分析 弄清楚要计算机解决的问题根本所在，确定新系统的作用域，以及项目所需资源和经费 可行性分析的目的 用最小的代价在尽可能短的时间内确定问题能否解决 可行性分析的内容 经济可行性，技术可行性，操作可行性 步骤：研究当前正在运行的系统确定项目的规模和目标建立新系统的高层逻辑模型导出和评价各种方案推荐可行方案编写可行性研究报告 什么是人月，人月是什么单位 第三章 需求分析 需求分析的内容 需求分析的过程 需求获取 需求分析 规格说明 需求验证：确保需求编写正确。必须全面理解用户的各项要求，准确表达被接受的用户要求。 需求基线 需求管理：管理需求变化的过程，涉及需求变更如何被处理的策略、规程和过程 需求分析的方法 面向数据的结构化分析法（SA） 面向对象的分析方法（OOA） 需求报告的作用，需求报告主要内容，写作注意事项 作用：作为用户和软件人员之间的合同，为双方互相了解提供基础反映出问题结构，可用作为软件人员进行设计和编写的基础作为验收的依据，即作为选取测试用例和进行形式验证的依据 内容： 注意事项： 简洁：保持语句和段落的简短 一致：需求陈述应该具有一致的样式 必须避免模糊的、主观的术语，减少不确定性 避免使用比较性词汇 不应该把多个需求集中在一个冗长的叙述段落中 需求文档的质量属性 完整，无二义性，可验证，正确，一致 结构化分析的分析模型 建立系统的功能模型 利用数据流图（Data Flow Diagram，DFD）将 大问题分割成若干个小问题，采用分层的数据流图， 先建立系统环境图（顶层），再逐步求精。 建立数据字典 采用结构化英语，小说明，补充材料等列出。 E-R图 数据流图 数据守恒与数据封闭原则 加工分解的原则 子图与父图的“平衡“ 合理使用文件 数据字典 状态迁移图 描述系统的状态如何响应外部的事件进行推 移的一种图形表示 判断树，判定表 在某些数据处理中，某数据流图的加工需要依赖于多 个逻辑条件的取值，就是说完成这一加工的一组动作是由 于某一组条件取值的组合而引发的。这时使用判定表来描 述比较合适 判定树是判定表的变种，它也能清晰地表达复杂的条件组 合与所对应的操作之间的关系。判定树的优点在于它无须任 何说明，一眼就能看出其含义，易于理解和使用 第四章 总体设计 总体设计的内容 将系统划分成模块 决定每个模块的功能 决定模块调用关系 决定模块界面，即模块间传递的数据 模块化设计的重要指导思想是什么 分解，信息隐蔽，确保模块独立 什么是耦合，具体哪些耦合方式 耦合是对一个软件结构内不同模块之间互联程度的度量。耦合的强弱取决于模块间接口的复杂程度，进入模或访问一个模块的点以及通过接口的数据 简单耦合 数据耦合 标记耦合 控制耦合 外部耦合 公共耦合 内容耦合 模块之间联系的原则 尽量使用数据耦合，少使用控制耦合，限制公共耦合范围，完全不用内容耦合 模块间互相调用时，传递参数最好只有一个 什么是内聚，内聚有哪些类型。设计时因追求什么内聚 内聚标志着一个模块内部各个元素间彼此结合的紧密程度。 功能内聚： 模块内所有处理元素属于一个整体，完成一个单一的功能 顺序内聚： 一个模块内部各个组成部分的处理动作是按顺序执行的，且前一个处理动作和输出数据是下一个处理动作的输入数据 通信内聚： 一个模块内各个组成部分的处理动作都引用相同的输入数据或产生相同的输出数据 过程内聚： 一个模块内部各个组成部分的处理动作各不相同，彼此也没有什么关系，但它们都受同一个控制流支配，决定它们的执行顺序 时间内聚： 一个模块各组成部分，它们处理动作和时间有关 逻辑内聚： 逻辑相关的函数或数据出现在同一个模型里 偶然内聚： 无关的函数，过程或数据出现在同一个模块里 模块化的基本原则 高内聚，低耦合。内聚比耦合更重要 模块的评价标准 可分解，可组装，可理解，连续性，保护性 什么是模块的深度和广度 扇入于扇出 扇出：一个模块之间调用/控制的模块数 3&lt;=fan-out&lt;=9 扇入：之间调用该模块的模块数 不破坏独立性的前提下，fan-in大的比较好 控制域作用域 作用域是指该模块中一个判断所影响的所有其它模块 控制域指该模块本身以及所有直接或间接从属于它的模块 模块设计时的启发式规则 低耦合，高内聚；模块规模适中；适当控制深度宽度；降低接口复杂程度；争取单入单出；模块功能可预测 第五章 详细设计 详细设计的内容 以总体设计阶段的工作为基础 在总体设计阶段，数据项和数据结构以比较抽象的方式描述，而详细设计阶段则应在此基础上给出足够详细描述。 详细设计要提供关于算法的更多的细节 详细设计的任务和原则 任务： 确定每个模块算法 确定每一个模块的数据组织 为每一个模块设计一组测试用例 编写详细设计说明书 原则 模块的逻辑描述正确可靠 采用结构化程序设计方法，改善控制结构，降低程序复杂度，提高程序可读性，可测试性和可维护性 详细设计的工具，优缺点 程序流程图 优点：比较直观 和清晰地描述过程的控制流程 缺点： 不是逐步求 精的好工具，忽略了程序的全局结构 随意转移控制 表示数据结构方面存在不足。 H-S图 功能域 控制转移不能任意规定 容易确定局部数据和全局数据的作用域 容易表现嵌套关系，也可以表示模块的层次结构 pad图 清晰度和结构化程度高。 PAD图中的最左面的线是程序的主干线,即程序的第一层结构。随着程序层次的增加，PAD图逐渐 向右延伸。因此，PAD图可读性强。 利用PAD图设计出的程序必定是结构化的程序。 容易将PAD图转化成高级语言源程序。 PAD图支持自顶向下逐步求精的方法。 环形复杂度，如何计算 绘制流图：程序流程图中的顺序的处理框序列和菱形判定框， 可以映射成流图中的一个结点，仅仅描绘程序的控制流程，完全不表现对数据的具体操 作以及分支或循环的具体条件 流图中区域数（包括图外区域） 流图边数-节点数 + 2 判定结点数+1 环形复杂度对编程的指导意义 环形复杂度高 的程序，往往是最困难、最容易出问题的程序. 模块规模以V(G)≤10为宜，也就是说，V(G)=10 是模块规模的一个更科学更精确的上限 第六章 编码 编程语言共有的特性有哪些 名字说明 类型说明 初始化 程序对象的局部性 程序模块 循环控制结构 分支控制结构 异常处理 独立编译 什么是编码规范，枚举常用的编码规范 编码风格实际上是一种编码原则。编码的目标从强调效率转变到强调 清晰。与此相应，编码风格也从追求“聪明”和 “技巧” ，变为提倡“简明”和“直接” 。人们 逐渐认识到，良好的编码风格能在一定程度上弥 补程序设计语言存在的缺点。反之，如果不注意 编码风格，即使使用了结构化的现代语言，也很 难写出高质量的程序。 1). 序言性注释 2). 描述性注释 3). 变量名选择合理 4). 表达式书写 5). 循环语句设计 什么是程序内文档，如何做程序内文档 指编码时适当选择标识符的名字、适当安排注释和注重程序的整个组织形式。 提升代码效率的方法 准则： 效率是一种性能需求，目标值应该在需求分析阶段设定。软件效率应该以需求为准，不应该以人力所及为准 好的设计可用提高效率 代码效率与代码简单性相关 方法： （1）应先简化算术和逻辑的表达式。 （2）仔细研究嵌套的循环，以确定是否有语句可以 从内层往外移。 （3）尽量避免使用多维数组。 （4）尽量避免使用指针和复杂的列表。 （5）使用执行时间短的算术运算。 （6）即使语言允许，一般也不要采用混合数据类型。 （7）尽量使用整数表达式和布尔表达式。 第八章 维护 维护的种类 纠错性维护 适应性维护 完善性维护 预防性维护 什么是再工程（预防性维护） 再工程是一个重构活动，软件再工程是一类软件工程活动，是一个工程过程,它将逆向工程，重构和正向工程组合起来，将现存系统重新构造为新的形式 文档是影响软件可维护性的决定性因素","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"顺时针打印矩阵","slug":"顺时针打印矩阵","date":"2020-06-28T21:54:28.000Z","updated":"2020-06-28T21:56:02.543Z","comments":true,"path":"2020/06/29/顺时针打印矩阵/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/06/29/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/","excerpt":"","text":"题目输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 解析一圈一圈向内靠近，每轮减少两行两列，最后处理剩余不足2行2列的情况 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889class Solution &#123;public: typedef struct point&#123; int x; int y; &#125;point; vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) &#123; int lenx,leny; vector&lt;int&gt; ans; lenx=matrix.size(); leny=matrix[0].size(); point p[4]; p[0].x=0; p[0].y=0; p[1].x=0; p[1].y=leny-1; p[2].x=lenx-1; p[2].y=leny-1; p[3].x=lenx-1; p[3].y=0; bool first=true; while(1)&#123; if(first)&#123; if(p[0].x==p[3].x&amp;&amp;p[0].y==p[3].y)&#123; for(int i=p[0].y;i&lt;=p[1].y;i++)&#123; ans.push_back(matrix[p[0].x][i]); &#125; break; &#125; else if(p[0].x==p[1].x&amp;&amp;p[0].y==p[1].y)&#123; for(int i=p[1].x;i&lt;=p[2].x;i++)&#123; ans.push_back(matrix[i][p[1].y]); &#125; break; &#125; &#125; first=false; for(int i=p[0].y;i&lt;p[1].y;i++)&#123; ans.push_back(matrix[p[0].x][i]); &#125; for(int i=p[1].x;i&lt;p[2].x;i++)&#123; ans.push_back(matrix[i][p[1].y]); &#125; for(int i=p[2].y;i&gt;p[3].y;i--)&#123; ans.push_back(matrix[p[2].x][i]); &#125; for(int i=p[3].x;i&gt;p[0].x;i--)&#123; ans.push_back(matrix[i][p[3].y]); &#125; p[0].x++; p[0].y++; p[1].x++; p[1].y--; p[2].x--; p[2].y--; p[3].x--; p[3].y++; if(p[0].x&gt;p[3].x||p[0].y&gt;p[1].y)&#123; break; &#125; if(p[0].x==p[3].x&amp;&amp;p[0].y==p[3].y)&#123; for(int i=p[0].y;i&lt;=p[1].y;i++)&#123; ans.push_back(matrix[p[0].x][i]); &#125; break; &#125; else if(p[0].x==p[1].x&amp;&amp;p[0].y==p[1].y)&#123; for(int i=p[1].x;i&lt;=p[2].x;i++)&#123; ans.push_back(matrix[i][p[1].y]); &#125; break; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E7%AE%97%E6%B3%95/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"topK","slug":"topK","date":"2020-06-20T13:42:09.000Z","updated":"2020-06-20T13:42:09.429Z","comments":true,"path":"2020/06/20/topK/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/06/20/topK/","excerpt":"","text":"描述在数组中找到第 k 大的元素。 你可以交换数组中的元素的位置 样例样例 1： 输入：n = 1, nums = [1,3,4,2]输出：4样例 2： 输入：n = 3, nums = [9,3,2,4,8]输出：4 挑战要求时间复杂度为O(n)，空间复杂度为O(1)。 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution &#123;public: /** * @param n: An integer * @param nums: An array * @return: the Kth largest element */ static bool cmp(int a, int b) &#123; return a &gt; b; &#125;void quicksort(vector&lt;int&gt;&amp; a, int left, int right, int n)&#123; int temp = a[left]; int i, j; i = left; j = right; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; a[j] &lt;= temp) j--; a[i] = a[j]; while (i &lt; j &amp;&amp; a[i] &gt;= temp) i++; a[j] = a[i]; &#125; a[i] = temp; if (i &lt; n) &#123; quicksort(a, i+1, right, n); &#125; else if (i &gt; n) &#123; quicksort(a, left, i - 1, n); &#125; else &#123; sort(a.begin()+left, a.begin()+i+1, cmp); &#125;&#125;int kthLargestElement(int n, vector&lt;int&gt;&amp; nums)&#123; int l, r; l = 0; r = nums.size() - 1; n--; quicksort(nums, l, r, n); return nums[n];&#125;&#125;;","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E6%8E%92%E5%BA%8F/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"翻转链表","slug":"翻转链表","date":"2020-06-18T15:57:14.000Z","updated":"2020-06-18T15:57:14.424Z","comments":true,"path":"2020/06/18/翻转链表/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/06/18/%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"","text":"翻转链表中第m个节点到第n个节点的部分样例例1:输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL. 例2:输入: 1-&gt;2-&gt;3-&gt;4-&gt;NULL, m = 2 and n = 3,输出: 1-&gt;3-&gt;2-&gt;4-&gt;NULL. 挑战Reverse it in-place and in one-pass 注意事项m，n满足1 ≤ m ≤ n ≤ 链表长度 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * Definition of singly-linked-list: * class ListNode &#123; * public: * int val; * ListNode *next; * ListNode(int val) &#123; * this-&gt;val = val; * this-&gt;next = NULL; * &#125; * &#125; */class Solution &#123;public: /** * @param head: ListNode head is the head of the linked list * @param m: An integer * @param n: An integer * @return: The head of the reversed ListNode */ ListNode * reverseBetween(ListNode * head, int m, int n) &#123; // write your code here ListNode * p1,*psre,*pere,*ps,*pe,*penext; if(m==n)return head; p1=head; pe=ps=p1; if(p1-&gt;next!=NULL) for(int i=1;p1!=NULL;i++,p1=p1-&gt;next)&#123; if(i==m)&#123; ps=p1; &#125; if(i==n)&#123; pe=p1; &#125; if(i&lt;m)&#123; psre=p1; &#125; if(i&lt;n)&#123; pere=p1; &#125; &#125; // if(p1-&gt;next!=NULL) penext=pe-&gt;next; if(m!=1) psre-&gt;next=pe; else&#123; head=pe; &#125; ListNode *tp,*tpnext,*temp; tp=ps; if(head-&gt;next!=NULL)&#123; tpnext=ps-&gt;next; ps-&gt;next=penext; &#125; if(n-m!=0)&#123; for(int i=0;i&lt;n-m;i++)&#123; temp=tpnext-&gt;next; tpnext-&gt;next=tp; tp=tpnext; tpnext=temp; &#125; &#125; return head; &#125;&#125;;","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E9%93%BE%E8%A1%A8/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"struct","slug":"struct","date":"2020-06-17T08:55:59.000Z","updated":"2020-06-17T09:40:23.338Z","comments":true,"path":"2020/06/17/struct/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/06/17/struct/","excerpt":"","text":"1.C中struct在C中struct只单纯的用作数据的复合类型，也就是说，在结构体声明中只能将数据成员放在里面，而不能将函数放在里面。在C结构体声明中不能使用C++访问修饰符，如：public、protected、private 而在C++中可以使用。在C中定义结构体变量，如果使用了下面定义必须加struct。C的结构体不能继承（没有这一概念）。若结构体的名字与函数名相同，可以正常运行且正常的调用！例如：可以定义与 struct Base 不冲突的 void Base() {}。 完整案例：1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;struct Base &#123; // public int v1; // public: //error int v2; //private: int v3; //void print()&#123; // c中不能在结构体中嵌入函数 // printf(\"%s\\n\",\"hello world\"); //&#125;; //error!&#125;;void Base()&#123; printf(\"%s\\n\",\"I am Base func\");&#125;//struct Base base1; //ok//Base base2; //errorint main() &#123; struct Base base; base.v1=1; //base.print(); printf(\"%d\\n\",base.v1); Base(); return 0;&#125; 最后输出： 1I am Base func 2.C++中struct与C对比如下：C++结构体中不仅可以定义数据，还可以定义函数。C++结构体中可以使用访问修饰符，如：public、protected、private 。C++结构体使用可以直接使用不带struct。C++继承若结构体的名字与函数名相同，可以正常运行且正常的调用！但是定义结构体变量时候只用用带struct的！例如： 情形1：不适用typedef定义结构体别名未添加同名函数前： 123456struct Student &#123;&#125;;Student()&#123;&#125;Struct Student s; //okStudent s; //ok 添加同名函数后： 123456struct Student &#123;&#125;;Student()&#123;&#125;Struct Student s; //okStudent s; //error 情形二：使用typedef定义结构体别名12345678910typedef struct Base1 &#123; int v1;// private: //error! int v3; public: //显示声明public int v2; void print()&#123; printf(\"%s\\n\",\"hello world\"); &#125;; &#125;B; //void B() {} //error! 符号 “B” 已经被定义为一个 “struct Base1” 的别名 前三种案例12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;stdio.h&gt;struct Base &#123; int v1;// private: //error! int v3; public: //显示声明public int v2; void print()&#123; printf(\"%s\\n\",\"hello world\"); &#125;; &#125;;int main() &#123; struct Base base1; //ok Base base2; //ok Base base; base.v1=1; base.v3=2; base.print(); printf(\"%d\\n\",base.v1); printf(\"%d\\n\",base.v3); return 0;&#125; 继承案例12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;stdio.h&gt;struct Base &#123; int v1;// private: //error! int v3; public: //显示声明public int v2; virtual void print()&#123; printf(\"%s\\n\",\"Base\"); &#125;; &#125;;struct Derived:Base &#123; public: int v2; void print()&#123; printf(\"%s\\n\",\"Derived\"); &#125;; &#125;;int main() &#123; Base *b=new Derived(); b-&gt;print(); return 0;&#125; 同名函数123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;stdio.h&gt;struct Base &#123; int v1;// private: //error! int v3; public: //显示声明public int v2; void print()&#123; printf(\"%s\\n\",\"hello world\"); &#125;; &#125;;typedef struct Base1 &#123; int v1;// private: //error! int v3; public: //显示声明public int v2; void print()&#123; printf(\"%s\\n\",\"hello world\"); &#125;; &#125;B;void Base()&#123; printf(\"%s\\n\",\"I am Base func\");&#125;//void B() &#123;&#125; //error! 符号 \"B\" 已经被定义为一个 \"struct Base1\" 的别名int main() &#123; struct Base base; //ok //Base base1; // error! base.v1=1; base.v3=2; base.print(); printf(\"%d\\n\",base.v1); printf(\"%d\\n\",base.v3); Base(); return 0;&#125; 3.总结C和C++中的Struct区别 C C++ 不能将函数放在结构体声明 能将函数放在结构体声明 在C结构体声明中不能使用C++访问修饰符。 public、protected、private 在C++中可以使用。 在C中定义结构体变量，如果使用了下面定义必须加struct。 可以不加struct 结构体不能继承（没有这一概念）。 可以继承 若结构体的名字与函数名相同，可以正常运行且正常的调用！ 若结构体的名字与函数名相同，使用结构体，只能使用带struct定义！ — 4.struct与class区别总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。 区别:最本质的一个区别就是默认的访问控制 默认的继承访问权限。struct 是 public 的，class 是 private 的。 struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"C++","slug":"C","permalink":"https://xiao_feng_yang993.gitee.io/tags/C/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"断点调试","slug":"断点调试","date":"2020-06-16T15:17:25.000Z","updated":"2020-06-16T20:10:21.495Z","comments":true,"path":"2020/06/16/断点调试/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/06/16/%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/","excerpt":"","text":"1. Visual studio断点调试测试代码：123456789101112131415161718192021int add(int a, int b)&#123; int c = a + b; return c;&#125;int main()&#123; int i = 0; int val,t; int* ans; ans = (int*)malloc(sizeof(int) * 10); for (i = 0; i &lt; 10; i++) &#123; t = i * i; val = add(t,i); ans[i] = val; &#125; return 0;&#125; 上面代码的功能是分别计算i从0到9时，计算 的值并存到ans数组里。 断点类型： 1. 指定变量条件在t=i*i语句处设置条件断点——i&gt;7 运行调试程序，程序在i=8时停了下来 t是上一轮计算的7*7=49，调试程序直接停在了i=8的情况下。 2. 指定忽略次数 将刚才的断点设置为命中8次时调试程序暂停 程序暂停时i=7（因为i=0，1，2，3，4，5，6，7）刚好时第8次命中断点，便暂停了程序 3. 数据断点 当&amp;ans[5]处的值发生修改时触发断点 运行程序，程序断点被触发,指令指针指向ans[i]=val一句的下一句。 此时i=5，ans[5]的值被赋值为30. 4. 查看堆栈信息在add函数内设置断点 查看堆栈，看到有两个栈信息，分别时main（）和add（）。当前位于add（） 局部变量信息，只有add函数里的a，b，c 点击main函数的栈，切换栈帧 再看局部变量，可以看到main函数里的局部变量。 2. Eclipse1. 指定变量条件 在t = i*i处设置条件断点，条件为i&gt;7. 运行程序，程序在断点处暂停 其局部变量i的值为8，第一次满足i&gt;7的条件。 2. 忽略次数 设置断点属性的ignore count为8，意思时忽略8次断点命中，第九次暂停 运行程序，在断点处暂停 此时变量i的值为8，忽略了前8次（i=0，1，2，3，4，5，6，7）的情况。 3. 堆栈信息与局部变量 有add函数和main函数。 此时的局部变量信息 切换栈帧，双击main栈帧 再看局部变量 此时显示的是main里的局部变量 3. Gdb1. 指定变量条件在26行也就是t=i*i处设置条件断点，条件为i&gt;7;继续运行程序 程序暂停在断点处，查看此时的变量i的值，发现i=8，刚满足i&gt;7的断点条件 2. 指定忽略次数 在26行设置断点，查看断点信息，此时有一个位于main.c的26行的断点；设置断点忽略次数为8；运行程序。程序在t=i*i处暂停下来，查看变量i的值为8,意味这忽略了8次断点（分别为i=0,1,2,3,4,5,6,7） 3. 数据断点在&amp;ans[5]数据处设置数据断点 程序暂停在ans[i]=val语句的下一行， 此时ans[5]的值已经被修改 4. 堆栈信息及局部变量当函数执行到add函数里时，采用bt命令查看栈信息，有2个栈分别是main和add 此时查看局部变量信息看到，c = 42. 切换栈帧frame 1.查看main的局部变量。 4. WinDbg1. 指定变量条件 在t=i*i语句处设置断点，当i==8时触发断点 运行程序 可以看到在debug程序的main函数的首地址+0x5e处暂停。 从局部变量信息里看到此时i=8. 2. 设置忽略次数bp debug!main+0x5e 7 表示忽略前6次，在第七次过断点时触发断点 运行程序，停于断点处。 查看局部变量信息 变量i = 6, 意思是前6次全部忽略（i=0，1，2，3，4，5），第七次过断点才触发。 3. 数据断点在ans[1]处设置数据断点，需要先运行程序知道ans[1]的地址。 第一次断点，发现ans指向地址0x0000000000e46fb0处，所以32程序的ans[1]的地址为0x0000000000e46fb0 0x4, 在此设置数据断点 ba r4 0x0000000000e46fb0+0x4 执行ans[i]=val前的监视变量 Next step Ans[1]的值被更新。 4. 堆栈信息及局部变量在add函数内设置断点，程序执行至add函数内断点处 查看堆栈信息 查看局部变量，仅有add函数内的变量 .frame切换栈帧，查看局部变量，可以看到main内的函数，且当前栈帧为main","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"调试","slug":"调试","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E8%B0%83%E8%AF%95/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"有环链表","slug":"有环链表","date":"2020-06-15T18:37:37.000Z","updated":"2020-06-15T18:46:36.501Z","comments":true,"path":"2020/06/16/有环链表/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/06/16/%E6%9C%89%E7%8E%AF%E9%93%BE%E8%A1%A8/","excerpt":"","text":"题目给定一个链表，如果链表中存在环，则返回到链表中环的起始节点，如果没有环，返回null。 样例样例 1:输入：null,no cycle输出：no cycle解释：链表为空，所以没有环存在。 样例 2:输入：-21-&gt;10-&gt;4-&gt;5，tail connects to node index 1输出：10解释：最后一个节点5指向下标为1的节点，也就是10，所以环的入口为10。 挑战不使用额外的空间 解题思路 判断有环首先创建两个指针p1和p2（在Java里就是两个对象引用），让它们同时指向这个链表的头节点。然后开始一个大循环，在循环体中，让指针p1每次向后移动1个节点，让指针p2每次向后移动2个节点，然后比较两个指针指向的节点是否相同。如果相同，则可以判断出链表有环，如果不同，则继续下一次循环 求环长度当两个指针首次相遇，证明链表有环的时候，让两个指针从相遇点继续循环前进，并统计前进的循环次数，直到两个指针第2次相遇。此时，统计出来的前进次数就是环长。因为指针p1每次走1步，指针p2每次走2步，两者的速度差是1步。当两个指针再次相遇时，p2比p1多走了整整1圈。因此，环长 = 每一次速度差 × 前进次数 = 前进次数 确定入环点那么，当两个指针首次相遇时，各自所走的距离是多少呢？指针p1一次只走1步，所走的距离是D+S1指针p2一次走2步，多走了n(n&gt;=1)整圈，所走的距离是D+S1+n(S2 +S1)。由于p2的速度是p1的2倍，所以所走距离也是p1的2倍，因此：2(D+S1 ) = D+S1+n(S1+S2 )等式经过整理得出：D = (n-1)(S1+S2) + S2也就是说，从链表头结点到入环点的距离，等于从首次相遇点绕环n-1圈再回到入环点的距离。这样一来，只要把其中一个指针放回到头节点位置，另一个指针保持在首次相遇点，两个指针都是每次向前走1步。那么，它们最终相遇的节点，就是入环节点。 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Definition of singly-linked-list: * class ListNode &#123; * public: * int val; * ListNode *next; * ListNode(int val) &#123; * this-&gt;val = val; * this-&gt;next = NULL; * &#125; * &#125; */class Solution &#123;public: /** * @param head: The first node of linked list. * @return: The node where the cycle begins. if there is no cycle, return null */ ListNode * detectCycle(ListNode * head) &#123; // write your code here ListNode * p1,*p2; p1=p2=head; if(p1==NULL)return NULL; // if(p1==p1-&gt;next)return p1; // if(p1-&gt;next==NULL)return NULL; bool sign; sign = false; while(p2!=NULL&amp;&amp;p2-&gt;next!=NULL)&#123; p1=p1-&gt;next; p2=p2-&gt;next-&gt;next; if(p1==p2)&#123; sign=true; break; &#125; &#125; if(sign==false)&#123; return NULL; &#125; p1=head; while(p1!=p2)&#123; p1=p1-&gt;next; p2=p2-&gt;next; &#125; return p1; &#125;&#125;;","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E9%93%BE%E8%A1%A8/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"a+b位运算","slug":"a-b位运算","date":"2020-06-15T03:21:12.000Z","updated":"2020-06-15T07:41:48.492Z","comments":true,"path":"2020/06/15/a-b位运算/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/06/15/a-b%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"a+b位运算核心思想a^b(不进位加法)。(a&amp;b)&lt;&lt;1(用于表示进位的位置)。 具体步骤将上面2结果再次进行按位异或^运算，再求新的异或加法的进位表示，直到没有进位产生也就是(a&amp;b)&lt;&lt;1==0时a^b的结果即为a+b的最终结果 源码实现123456789101112131415161718192021class Solution &#123;public: /** * @param a: An integer * @param b: An integer * @return: The sum of a and b */ int aplusb(int a, int b) &#123; int c= a^b; int d = (a&amp;b)&lt;&lt;1; while(d!=0)&#123; a=c; b=d; c=a^b; d=(a&amp;b)&lt;&lt;1; &#125; return c; &#125;&#125;;","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"算法","slug":"算法","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E7%AE%97%E6%B3%95/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"AVX和AVX2学习笔记","slug":"AVX和AVX2学习笔记","date":"2020-06-14T17:19:25.000Z","updated":"2020-06-14T17:19:25.921Z","comments":true,"path":"2020/06/15/AVX和AVX2学习笔记/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/06/15/AVX%E5%92%8CAVX2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E7%BC%96%E7%A8%8B/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"寻找缺失的整数","slug":"寻找缺失的整数","date":"2020-06-14T14:31:12.000Z","updated":"2020-06-15T07:42:04.375Z","comments":true,"path":"2020/06/14/寻找缺失的整数/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/06/14/%E5%AF%BB%E6%89%BE%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B4%E6%95%B0/","excerpt":"","text":"1.题目在一个无序数组里有99个不重复的正整数，范围是1～100，唯独缺少1个1～100中的整数。如何找出这个缺失的整数？ 解答：先算出1+2+3+…+100的和，然后依次减去数组里的元素，最后得到的差值，就是那个缺失的整数。 复杂度分析假设数组长度是n，那么该解法的时间复杂度是O(n)，空间复杂度是O(1)。 2.题目一个无序数组里有若干个正整数，范围是1～100，其中99个整数都出现了偶数次 ，只有1个整数出现了奇数次 ，如何找到这个出现奇数次的整数？ 解答遍历整个数组，依次做异或运算。由于异或运算在进行位运算时，相同为0，不同为1，因此所有出现偶数次的整数都会相互抵消变成0，只有唯一出现奇数次的整数会被留下。 3.题目假设一个无序数组里有若干个正整数，范围是1～100，其中有98个整数出现了偶数次，只有2个 整数出现了奇数次，如何找到这2个出现奇数次的整数？ 解答采用分治思想，把数组分成两部分，保证每一部分都包含1个出现奇数次的整数，这样就与上一题的情况一样了。 把2个出现了奇数次的整数命名为A和B。遍历整个数组，然后依次做异或运算，进行异或运算的最终结果，等同于A和B进行异或运算的结果。在这个结果中，至少会有一个二进制位是1（如果都是0，说明A和B相等，和题目不相符）。根据这个结论，可以把原数组按照二进制的倒数第2位的不同，分成两部分，一部分的倒数第2位是0，另一部分的倒数第2位是1。由于A和B的倒数第2位不同，所以A被分配到其中一部分，B被分配到另一部分，绝不会出现A和B在同一部分，另一部分既没有A，也没有B的情况 复杂度分析假设数组长度是n，那么该解法的时间复杂度是O(n)。把数组分成两部分，并不需要借助额外的存储空间，完全可以在按二进制位分组的同时来做异或运算，所以空间复杂度仍然是O(1)。 代码实现1234567891011121314151617181920212223242526int[] findlostNum(int [] array)&#123; int result[2]=&#123;0,0&#125;; int xor=0; for(int i=0;i&lt;array.length();i++)&#123; xor^=array[i] &#125; if(xor==0) return Error; int separtor = 1; while(x==(separtor&amp;xor))&#123; separtor&lt;&lt;=1; &#125; for(int i=0;i&lt;array.length();i++)&#123; if(1==(separator&amp;array[i]))&#123; result[1]^=array[i]; &#125; else&#123; result[0]^=array[i]; &#125; &#125; return result;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"算法","slug":"算法","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E7%AE%97%E6%B3%95/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"vscode的terminal打开异常缓慢的问题","slug":"vscode的terminal打开异常缓慢的问题","date":"2020-06-11T15:39:05.000Z","updated":"2020-06-11T15:40:24.158Z","comments":true,"path":"2020/06/11/vscode的terminal打开异常缓慢的问题/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/06/11/vscode%E7%9A%84terminal%E6%89%93%E5%BC%80%E5%BC%82%E5%B8%B8%E7%BC%93%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"1.问题频现在使用了Linux的vscode后就经常发生内置terminal无法打开的问题： 2.解决无门在百度更换多个关键词查找后没有有价值的信息 3.出现转机在无边无际的搜索结果中一次偶然看到了解决方法：只要打开这项设置，就能解决问题关掉设置后，又会出现之前的问题设置信息可知：新的shells是否从vscode继承继承环境变量","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"},{"name":"vscode","slug":"vscode","permalink":"https://xiao_feng_yang993.gitee.io/tags/vscode/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"code-server 远程编辑","slug":"code-server-远程编辑","date":"2020-05-13T10:11:42.000Z","updated":"2020-06-15T07:42:16.313Z","comments":true,"path":"2020/05/13/code-server-远程编辑/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/05/13/code-server-%E8%BF%9C%E7%A8%8B%E7%BC%96%E8%BE%91/","excerpt":"","text":"1. 背景随着项目规模扩大，个人计算机已经无法满足测试需求，需要在服务器上运行项目程序。当需要对源码进行修改的时候，就非常麻烦，先下载再上传或者使用vim直接编辑，许多功能都没有。一次偶然发现了code-server这个软件，将它部署在服务器上，就可以直接在本地编辑远程文件了，而且具有vscode的所有功能。 2. 安装常见的安装方法见链接：知乎 文中提到需要下载code-server二进制包，位于github上，由于买不起代理，一直下载失败。但是在之前为Windows10里的wsl配置code-server时可以直接在wsl里./code自动下载数据包，下载源位于微软的服务器，速度快。根据这一特性，但是找了半天也没找见下载地址，索性将解压后的数据一律打包上传。安装位置位于home/.vscode-server/bin/XXXXXXXcode-server github 为本地vscode安装remote-ssh插件，设置服务器登录ip和用户名，在连接过程中会尝试自动下载数据包，由于服务器未连接到外网，下载失败，但是服务器对应目录已经创建，进到home/.vscode-server/bin/XXXXXXX下（xxxxx表示commit码）将在个人设备上打包的数据解压在此。再次连接就能正常使用了。 3.安装过程中遇到的问题 由于默认生成的.ssh/config位于home下，对于windows来说，这个目录是有权限要求的，所以在选择保存目录时选到普通目录下。 在连接过程中密码反复错误，原因是登录名错误，因为默认登录名是个人电脑用户名，而不是服务器用户名。解决方法：在setting中下面一项填写保存的config地址 版本匹配问题，这个插件还会检测客户端(vscode)和服务端(服务器)的版本是否一致, 所以还需要在 vscode 中禁用插件的自动更新.在 settings.json 添加如下行即可1\"extensions.autoUpdate\": false 或者将本地安装版本选择与服务器一致，定期同步更新 分割线2020.5.13更新采用remote-ssh的连接方式在服务器的.vscode目录下产生多个目录，难以管理。又换成了浏览器连接的方法。 3. 浏览器vscode编辑 下载2进制文件 code-server 启动服务端vscode于后台运行1nohup .&#x2F;code-server -port 8082 &gt; nohup.out 2&gt;&amp;1 &amp; 默认密码随机生成字符串。可以通过设置PASSWORD使用用户自定义密码，也可以设置auth=none免密登录（不建议） 4. 设置进程监控脚本在使用code-server过程中，偶尔会发生code-server进程意外停止的事情（多由插件造成）。每次都要重新ssh上去重启很是麻烦写一个shell脚本，来监控code-server进程是否存在，若不存在则启动进程。 12345678910111213141516171819202122232425262728293031#进程名字可修改PRO_NAME=code-serverwhile true ; do# 用ps获取$PRO_NAME进程数量 NUM=`ps aux | grep $&#123;PRO_NAME&#125; | grep -v grep |wc -l`# echo $NUM# 少于1，重启进程；start_server.sh是自写的启动脚本 if [ \"$&#123;NUM&#125;\" -lt \"1\" ];then echo \"$&#123;PRO_NAME&#125; was killed\" /home/yxf/download/code-server2.1698-vsc1.41.1-linux-x86_64/start_server.sh fi# 每隔10秒钟检测一次 sleep 10# 大于1，杀掉所有进程，重启# elif [ \"$&#123;NUM&#125;\" -gt \"1\" ];then# echo \"more than 1 $&#123;PRO_NAME&#125;,killall $&#123;PRO_NAME&#125;\"# killall -9 $PRO_NAME# $&#123;PRO_NAME&#125; -i $&#123;WLAN&#125;# fi# # kill僵尸进程# NUM_STAT=`ps aux | grep $&#123;PRO_NAME&#125; | grep T | grep -v grep | wc -l`# if [ \"$&#123;NUM_STAT&#125;\" -gt \"0\" ];then# killall -9 $&#123;PRO_NAME&#125;# $&#123;PRO_NAME&#125; -i $&#123;WLAN&#125;# fidoneexit 0 此时，如果code-server进程意外停止，10秒内就会重启 如果需要开机自启，则可以将这个监控脚本放在/etc/init.d目录下，实现开机自启动。","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"GPUDirect RDMA for openmpi","slug":"GPUDirect-RDMA-for-openmpi","date":"2020-04-10T13:41:37.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/04/10/GPUDirect-RDMA-for-openmpi/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/04/10/GPUDirect-RDMA-for-openmpi/","excerpt":"","text":"背景对于MPI跨节点项目，对GPU上的数据一般需要先cudaMemcopy到Host，再通过mpi_send出去，另一设备通过mpi_Recv到Host内存，再cudamemcopy到GPU显存，这一过程明显要费时。 1. compile openmpi with –with-cuda这一编译方法可以让openmpi对显存的数据操作，但是它只是减少了代码的书写量，从GPU到Host的数据传输在背后任然在执行。时间甚至比手写cudaMemcopy还要长。为了解决这一问题，就采用了GPUDirect RDMA 技术。openmpi run with cudaBuilding CUDA-aware Open MPIOpen MPI v1.7.4 and later have added some support to take advantage of GPUDirect RDMA on Mellanox cards. All the details about Mellanox hardware as well as software needed to get things to work can be found at the Mellanox web site. Note that to get GPUDirect RDMA support, you also need to configure your Open MPI library with CUDA 6.0.可以看到要想使用GPUDirect RDMA，任然需要对openmpi 加上cuda参数编译。 2. 查看GPUDirect RDMA 信息 To see if you have GPUDirect RDMA compiled into your library, you can check like this:12shell$ ompi_info --all | grep btl_openib_have_cuda_gdr MCA btl: informational \"btl_openib_have_cuda_gdr\" (current value: \"true\", data source: default, level: 4 tuner/basic, type: bool) To see if your OFED stack has GPUDirect RDMA support, you can check like this:12shell$ ompi_info --all | grep btl_openib_have_driver_gdr MCA btl: informational \"btl_openib_have_driver_gdr\" (current value: \"true\", data source: default, level: 4 tuner/basic, type: bool) To run with GPUDirect RDMA support, you have to enable it as it is off by default:1mpirun --mca btl_openib_want_cuda_gdr 1 ... 官网的主要介绍就是这样，但是在自己设备上测试就没这么容易了，问题出现在btl_openib_have_driver_gdr这一步，结果如下：它显示的值是false，初步判断是缺少驱动所致，问题解决过程如下：3. 安装 nv_peer_mem安装过程参考浪潮公司的专利内容：一种基于GPUDerict RDMA测试方法具体步骤如下图所示： 运行lsmod |grep nv_peer_mem检查是否安装成功 1lsmod | grep nv_peer_mem 安装后再查看btl_openib_have_driver_gdr信息就正常了这时我通过测试节点间的显存数据mpi传输，发现速度有明显提升，其中GPU-to-GPU的速度跟从Host到Host速度相差无几，测得GPU-to-GPU速度超过8GB/s，与节点内的速度处在相同数量级。由于避免了在Host内存的中转，速度提高至少50%。 其中的原理是：直接访问GPU内存，避免访问固定(pinned) CUDA主机内存时不必要的系统内存拷贝和CPU的开销，加速了与网络和存储设备之间的通信可以在同一系统中的一个GPU直接访问另一个GPU使用直接的高速DMA传输，增加了 P2P的内存访问，真正释放了主机CPU资源，消除主机了CPU中不必要的频繁数据传输，完全不参与输入的RDMA操作；包括HCA卡、GI3U卡、GI3U必备的Nvidia Driver^Nvidia CUDA toolkit，及infiniband必备的MLNX_0FED驱动外，以及一个GPU与IB卡通信的nv_peer_mem包。","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"},{"name":"cuda","slug":"cuda","permalink":"https://xiao_feng_yang993.gitee.io/tags/cuda/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"openmpi with cuda","slug":"openmpi-with-cuda","date":"2020-03-30T09:10:12.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/30/openmpi-with-cuda/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/30/openmpi-with-cuda/","excerpt":"","text":"openMPI 1.7之后的版本才支持CUDA 1.对于1.7~2.0的版本， 配置和编译、安装如下：123sudo ./configure --prefix=&lt;用户指定的openMPI的安装目录&gt; --with-cuda=&lt;cuda的include目录&gt; --with-cuda-libdir=&lt;cuda的lib64目录&gt;sudo make all install 2.openmpi-2.0以及以上版本建议安装ucx+gdrcopy来获取新的mpi功能和更好的性能 首先安装gdrcopy，这里建议安装gdrcopy-1.3版本。因为2.0版本会出现如下错误：安装gdrcopy需要四个依赖：check，check-devel，subunit，subunit-devel，注意下载可执行文件，而不是源码；下载源——RPM，遇到的问题见博客 《linux rpm 错误》 编译gdrcopy执行如下命令12make PREFIX=/public/home/asc02/yangxf/local/gdrcopy-1.3 all install./insmod.sh #root 这里不需要指定CUDA=XXX，因为makefile里的路径本身是正确的，指定了反而出现找不见cuda.h的错误。123456789101112131415PREFIX ?= /usr/localDESTLIB ?= $(PREFIX)/lib64CUDA ?= /usr/local/cudaGDRAPI_ARCH := $(shell ./config_arch)CUDA_LIB := -L $(CUDA)/lib64 -L $(CUDA)/lib -L /usr/lib64/nvidia -L /usr/lib/nvidiaCUDA_INC += -I $(CUDA)/includeCPPFLAGS := $(CUDA_INC) -I gdrdrv/ -I $(CUDA)/include -D GDRAPI_ARCH=$(GDRAPI_ARCH)LDFLAGS := $(CUDA_LIB) -L $(CUDA)/lib64COMMONCFLAGS := -O2CFLAGS += $(COMMONCFLAGS)CXXFLAGS += $(COMMONCFLAGS)LIBS := -lcudart -lcuda -lpthread -ldl 参考gdrcopy 编译ucx ucx执行命令1234./autogen.sh./configure --prefix=/public/home/asc02/yangxf/local/ucx --with-cuda=/usr/local/cuda --with-gdrcopy=/public/home/asc02/yangxf/local/gdrcopy-1.3 --with-mlx5-dv --with-avx --with-sse41 --with-sse42make -j8make install 编译openmpi这里用的是openmpi-3.0执行命令123./configure --prefix=/public/home/asc02/yangxf/local/openmpi-3.0.0 --with-cuda=/usr/local/cuda --with-ucx=/public/home/asc02/yangxf/local/ucx --enable-mpi-cxxmake -j8make install 编译安装完成，在生成的lib目录下可以看到多了关于cuda的库把相关路径添加到环境变量就可。 注： 对于多机运行的程序，需要将mpi环境变量添加到.bashrc中，否则在其他机器上确实mpi的环境变量。","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"},{"name":"cuda","slug":"cuda","permalink":"https://xiao_feng_yang993.gitee.io/tags/cuda/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"linux rpm 错误","slug":"linux-rpm-错误","date":"2020-03-29T13:27:59.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/29/linux-rpm-错误/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/29/linux-rpm-%E9%94%99%E8%AF%AF/","excerpt":"","text":"linux 使用rpm安装软件时,遇到”warning: rpmts_HdrFromFdno: Header V3 RSA/SHA256 Signature, key ID fd431d51: NOKEY” 错误建议的做法：warning: rpmts_HdrFromFdno: Header V3 RSA/SHA256 Signature, key ID fd431d51: NOKEY 网上资料说这是由于yum安装了旧版本的GPG keys造成的 1rpm --import /etc/pki/rpm-gpg/RPM* 不建议的方法如下：1、安装时提示：warning: *.rpm: Header V3 RSA/SHA256 Signature, keykey ID c105b9de: NOKEY 解决的方法就是在rpm 语句后面加上 –force –nodeps 即原本为 rpm -ivh *.rpm 现在改成 rpm -ivh *.rpm –force –nodeps就可以了。 nodeps的意思是忽视依赖关系。因为各个软件之间会有多多少少的联系。有了这两个设置选项就忽略了这些依赖关系，强制安装或者卸载 2、尝试卸载： 造成这个问题的主要原因是套件被重複 (强制) 安装了两次以上. 尝试了–nodeps, –force, –justdb都不行。 结果碰巧解决! 通过man rpm，发现–allmatches应该可以解决这个问题. [root@testserver openssl-0.9.8l]# rpm -e –allmatches –nodeps openssl* CentOS系统bash: groupadd: command not found问题如果我们需要在CentOS执行新建用户组命令的时候，需要进入到ROOT权限，如果你用以下命令： 12susu root 进入到ROOT账户，那么会出现上述的错误信息：“bash: groupadd: command not found” 这是因为执行这个两个进入ROOT命令不会把你的PATH环境变量带过去，你需要执行命令： 1su - root 这样子进入ROOT权限，执行groupadd或者useradd命令就不会有问题了。","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"Dart学习笔记（2）：数据类型","slug":"Dart学习笔记（2）：数据类型","date":"2020-03-20T04:55:13.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/20/Dart学习笔记（2）：数据类型/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/20/Dart%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"因为工作的关系，系列文章刚开始写可能就要拖稿了不管怎么样，慢慢来吧！ Dart中所有东西都是对象，包括数字、函数等它们都继承自Object，并且默认值都是null（包括数字）因此数字、字符串都可以调用各种方法 Dart中支持以下数据类型： Numbers Strings Booleans List（也就是数组） Maps 容器后面再讲，这里先说说常用的字符串和数值类型还是先建工程吧！Dart代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void main()&#123; //Dart 语言本质上是动态类型语言，类型是可选的 //可以使用 var 声明变量，也可以使用类型来声明变量 //一个变量也可以被赋予不同类型的对象 //但大多数情况，我们不会去改变一个变量的类型 //字符串赋值的时候，可以使用单引号，也可以使用双引号 var str1 = \"Ok?\"; //如果使用的是双引号，可以内嵌单引号 //当然，如果使用的是单引号，可以内嵌双引号，否则需要“\\”转义 //String str2 = ‘It\\’s ok!’; String str2 = \"It's ok!\"; //使用三个单引号或者双引号可以多行字符串赋值 var str3 = \"\"\"Dart Lang Hello,World!\"\"\"; //在Dart中，相邻的字符串在编译的时候会自动连接 //这里发现一个问题，如果多个字符串相邻，中间的字符串不能为空，否则报错 //但是如果单引号和双引号相邻，即使是空值也不会报错，但相信没有人这么做 //var name = 'Wang''''Jianfei'; 报错 var name = 'Wang'' ''Jianfei'; //assert 是语言内置的断言函数，仅在检查模式下有效 //如果断言失败则程序立刻终止 assert(name == \"Wang Jianfei\"); //Dart中字符串不支持“+”操作符，如str1 + str2 //如果要链接字符串，除了上面诉说，相邻字符串自动连接外 //还可以使用“$”插入变量的值 print(\"Name：$name\"); //声明原始字符串，直接在字符串前加字符“r” //可以避免“\\”的转义作用，在正则表达式里特别有用 print(r\"换行符：\\n\"); //Dart中数值是num，它有两个子类型：int 和 double //int是任意长度的整数，double是双精度浮点数 var hex = 0xDEADBEEF; //翻了半天的文档，才找打一个重要的函数：转换进制，英文太不过关了 //上面提到的字符串插值，还可以插入表达式：$&#123;&#125; print(\"整型转换为16进制：$hex —&gt; 0x$&#123;hex.toRadixString(16).toUpperCase()&#125;\");&#125; 注：新版本SDK已支持“+”操作符连接字符串运行结果如下：String和num有丰富的函数，这里就不一一介绍了，大家可以慢慢尝试 再聊点const和final，用法和其他语言类似在声明变量的时候，除了var，还可以使用const和final同时，在使用const和final的时候，可以省略var或者其他类型 1234567var i = 10;const i = 10;final i = 10;int i = 10;const int i = 10;final int i = 10; const和final定义的都是常量，值不能改变并且在声明的时候就必须初始化但是也有细微差别，简单来说 const定义的是编译时常量，只能用编译时常量来初始化 final定义的常量可以用变量来初始化 12final time = new DateTime.now(); //Okconst time = new DateTime.now(); //Error，new DateTime.now()不是const常量 var、final等在左边定义变量的时候，并不关心右边是不是常量但是如果右边用了const，那么不管左边如何，右边都必须是常量 123456const list = const[1,2,3];//Okconst list = [1,2,3];//Errorfinal list = [1,2,3];//Okfinal list = const[1,2,3];//Okfinal list = const[new DateTime.now(),2,3];//Error,const右边必须是常量","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"https://xiao_feng_yang993.gitee.io/tags/Dart/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"Dart学习笔记（1）：Hello，world！","slug":"Dart学习笔记（1）：Hello，world！","date":"2020-03-20T04:45:43.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/20/Dart学习笔记（1）：Hello，world！/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/20/Dart%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9AHello%EF%BC%8Cworld%EF%BC%81/","excerpt":"","text":"任何一门编程语言的第一节课基本上都会是Hello,world!估计很少有人会打破这个传统 最初官方推荐的编辑器是Dart Editor而现在已弃用，改为推荐WebStorm、Atom编辑器本站并没有提供下载链接 需要的可自行百度，查找最新版本 Dart SDK的安装非常简单， 资源下载 页面提供有墙内下载地址将zip文件解压到任意目录，并将bin目录添加至PATH环境变量即可 在新建工程的时候，WebStorm 提供有多个工程模板这里选择命令行应用编辑bin/main.dart，同C++一样，Dart程序是从main()函数开始执行的在main.dart中添加如下代码： 1234void main()&#123; print(\"Hello, world!\");&#125; 添加完之后点击工具栏的绿色运行按钮，或者dart文件右键菜单中的 Run 菜单便能够在命令行界面看到运行结果了顺带一提，Dart有 两种运行模式： 检查模式（checked）：进行类型检查，如果发现实际类型与声明或期望的类型不匹配就报错 生产模式（production）：不进行类型检查，忽略声明的类型信息，忽略 assert 语句 检查模式运行较慢，生产模式运行快但检查模式可以及早地发现程序在的问题，所以建议在开发过程中使用检查模式而在正式环境中使用生产模式运行 Dart VM 默认在生产模式下运行，而我们用 WebStorm 开发时默认在检查模式下运行通过 Run—&gt;Edit Configurations 选项可以设置使用不同的模式","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"https://xiao_feng_yang993.gitee.io/tags/Dart/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"Functors","slug":"Functors","date":"2020-03-11T16:40:09.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/12/Functors/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/12/Functors/","excerpt":"","text":"1. C++ FunctorsAlright, what is a functor?A C++ functor is a “function-object”. In other words, it is an object that can be called and treated just like a regular function. Let’s see an example. 123456789101112131415class Doubler&#123;public: void operator()(int &amp;val) const &#123; val *= 2; &#125;&#125;;Doubler d1, d2; // two instances of the Doubler classint i = 20, j = 30;d1(i); // both instances can be called asd2(j); // if they were regular functions// now i=40 and j=60 OK, so what do functors give us? LOTS! We can maintain per-instance state. We can pass functors around just like variables. Compiler optimizations (vs. function pointers)123456789101112131415class AddX&#123;public: AddX(int x) : _x(x) &#123;&#125; int operator()(const int &amp;val) const &#123; return val + _x; &#125;private: const int _x;&#125;;AddX add5(5), add10(10); // two instancesstd::cout &lt;&lt; add5(3) &lt;&lt; std::endl; // prints 8std::cout &lt;&lt; add10(3) &lt;&lt; std::endl; // prints 13 We can also pass functor instances into the STL algorithms.1234567891011121314151617181920void doubleIt(int &amp;val)&#123; val *= 2;&#125;class Doubler&#123;public: void operator()(int &amp;val) const &#123; val *= 2; &#125;&#125;;std::vector&lt;int&gt; myset(10);Doubler myDoubler;// the next two lines are functionally equivalentstd::for_each(myset.begin(), myset.end(), doubleIt);std::for_each(myset.begin(), myset.end(), myDoubler); 2. Thrust - FunctorsOK, so Thrust provides some vectors and generic algorithms for me. But what if I want to do more than just sort, count, and sum my data? Well, look at the title of the slide! - You can make your own functors and pass these into Thrust’s generic algorithms. 1234567891011121314151617181920// the next two lines are functionally equivalentstd::for_each(myset.begin(), myset.end(), doubleIt);std::for_each(myset.begin(), myset.end(), myDoubler);// calculate result[] = (a * x[]) + y[]struct saxpy&#123; const float _a; saxpy(int a) : _a(a) &#123;&#125; __host__ __device__ float operator()(const float &amp;x, const float &amp;y) const &#123; return a * x + y; &#125;&#125;;thrust::device_vector&lt;float&gt; x, y, result;// ... fill up x &amp; y vectors ...thrust::transform(x.begin(), x.end(), y.begin(), result.begin(), saxpy(a)); 12345678910struct saxpy&#123; const float _a; saxpy(int a) : _a(a) &#123;&#125; __host__ __device__ float operator()(const float &amp;x, const float &amp;y) const &#123; return a * x + y; &#125;&#125;; Let’s look more at that. The operator() function is prefixed with host device. This is CUDA compiler notation, but to Thrust it means that it can be called with a host_vector OR device_vector. Also notice that in this form of programming you don’t need to worry about threadIdx and blockIdx index calculations in the kernel code. You can just focus on what needs to happen to each element. There are many excellent Thrust examples (including this saxpy one) in the installed distribution and online.","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://xiao_feng_yang993.gitee.io/tags/C/"},{"name":"thrust","slug":"thrust","permalink":"https://xiao_feng_yang993.gitee.io/tags/thrust/"},{"name":"cuda","slug":"cuda","permalink":"https://xiao_feng_yang993.gitee.io/tags/cuda/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"GCC离线升级","slug":"GCC离线升级","date":"2020-03-10T09:48:38.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/10/GCC离线升级/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/10/GCC%E7%A6%BB%E7%BA%BF%E5%8D%87%E7%BA%A7/","excerpt":"","text":"1. 下载gcc安装包 gcc选择自己想要的版本并下载我下载的是7.5.0版本.然后解压。 打开contrib/download_prerequisites查看依赖可以看到这里要求了四个依赖包：gmp，mpc，mpfr，isl。下载的版本可以不是最新版，但是不能太旧，一般从现在往后退几代就可以了，具体要求gcc的configure时会说明。额外注意如果采用tree编译法要求mpc&gt;=1.0.3。 2. 安装准备与配置 下载完成后，将gmp、mpfr、mpc、isl安装放到cd /usr/local/gcc-7.1.0目录下并解压： tar -xf gmp-6.1.0.tar.bz2 tar -xf mpfr-3.1.4.tar.bz2 tar -xf mpc-1.0.3.tar.gz tar -xf isl-0.16.1.tar.bz2 建立软连接： ln -sf gmp-6.1.0 gmp ln -sf mpfr-3.1.4 mpfr ln -sf mpc-1.0.3 mpc ln -sf isl-0.16.1 isl 3. 编译安装： 创建build目录，不要在源码root目录下直接build，否则无法进行树形编译 编译命令 123..&#x2F;configure --prefix&#x3D;xxx -enable-checking&#x3D;release -enable-languages&#x3D;c,c++ -disable-multilibmake -jmake install #安装到指定的prefix目录下 4. 其他编译方式 如果不采用tree编译的方式，那么需要分别编译这几个依赖包，而且顺序固定，依次编译。 gmp安装： tar jxf gmp-4.3.2.tar.bz2 cd gmp-4.3.2 ./configure –prefix=/usr/local/gmp-4.3.2 &amp;&amp; make make install mpfr安装： tar jxf mpfr-2.4.2.tar.bz2 cd mpfr-2.4.2 ./configure –prefix=/usr/local/mpfr-2.4.2 –with-gmp=/usr/local/gmp-4.3.2 &amp;&amp; make make install mpc安装： tar zxvfv mpc-1.0.1.tar.gz cd mpc-1.0.1 ./configure –prefix=/usr/local/mpc-1.0.1 –with-gmp=/usr/local/gmp-4.3.2 –with-mpfr=/usr/local/mpfr-2.4.2 &amp;&amp; make make install 添加环境变量 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/gmp-4.3.2/lib:/usr/local/mpc-1.0.1/lib:/usr/local/mpfr-2.4.2/lib 安装gcc-5.4.0 tar -xzvf gcc-5.4.0.tar.gz cd gcc-5.4.0 mkdir gcc-build //创建编译目录 cd gcc-build ../configure –prefix=/usr/local/gcc-5.4.0 –enable-threads=posix –disable-checking –disable-multilib –enable-languages=c,c++ –with-gmp=/usr/local/gmp-4.3.2 –with-mpfr=/usr/local/mpfr-2.4.2 –with-mpc=/usr/local/mpc-1.0.1 //执行配置 make -j4 //多核编译，过程极其漫长～～～ make install 这种方式我在编译gcc的时候失败了。还是tree编译方法方便","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"},{"name":"gcc","slug":"gcc","permalink":"https://xiao_feng_yang993.gitee.io/tags/gcc/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"Android x86尝鲜记录","slug":"Android-x86尝鲜记录","date":"2020-03-09T09:44:36.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/09/Android-x86尝鲜记录/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/09/Android-x86%E5%B0%9D%E9%B2%9C%E8%AE%B0%E5%BD%95/","excerpt":"","text":"1. 下载系统镜像包Androidx86_64 9.0百度搜索出的镜像站位于香港，下载速度比较慢。想到国内也有类似的镜像源——清华镜像源，就去找了找，起初并没有找见Androidx86。索性安卓香港镜像来按图索骥，先进到osdn目录，结果跟平常页面不一样OSDN。里面的链接点击后会直接跳转到OSDN官网，跑到了国外。跟加速的理念不符。在香港的镜像站目录逐步回退，也是这个样子，毫无头绪。不经意间突然想到，为何不直接把香港站的后续路径直接复制过来看是什么情况？说干就干，结果就找见了位于清华镜像站的文件Android x86；根据不同的版本号选择自己需要下载的版本，下载下来就可以进行安装。我选择了最新版的64位安装包 2. 安装操作系统Android x86的安装与一般的Linux安装没有什么区别，都是那么个流程选择installation，选择安装盘即可。然后重启，重启画面如下： 运行界面：所有应用： 3. 尝试使用(1) 在浏览器下载了QQ，安装运行无大碍(2) 安装腾讯会议，卡在启动界面无法进入(3) 安装和平精英游戏，无法运行(4) 安装淘宝可正常运行(5) 不能拨打电话发短信 4. 总结Androidx86下无法运行多数应用，跟手机在兼容性无法相提并论。但是性能要好，安装应用速度非常快。用了几个小时就卸载了，装回deepin。","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"},{"name":"Android","slug":"Android","permalink":"https://xiao_feng_yang993.gitee.io/tags/Android/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"ubuntu与windows时间同步","slug":"ubuntu与windows双系统时间同步","date":"2020-03-07T11:57:27.000Z","updated":"2020-05-03T14:20:38.528Z","comments":true,"path":"2020/03/07/ubuntu与windows双系统时间同步/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/07/ubuntu%E4%B8%8Ewindows%E5%8F%8C%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/","excerpt":"","text":"@TOC注：本教程不研究系统计时原理，只简单解决问题，不修改系统核心设置，安全快速解决问题。网络上他人的博客已近提出了专业解决方案，大家可前往查看，在此不做重复。https://blog.csdn.net/zero_hzz/article/details/79205037 相信装了windows与ubuntu双系统的用户都会遇见一个问题，那就是两个系统的时间不同步，相差8小时。网上的修改教程复杂难懂，对于阅读困难症患者着实不易。本人在实践中发现一个新的简单解决方案，在此分享给大家，即使你没有任何计算机基础，也能快速解决问题。 windows与ubuntu时间相差8小时，为什么是8小时而不是其他时间？具体原因详见文章开头链接。这个时候想到我们所学地理知识，中国就处在东8区。我们的电脑安装 是也默认了中国区：这个时候在回看我们遇到的时间不同步问题，相信聪明的大家已经想到解决办法了，解决办法就是在时间设置中将我们的电脑设置成0时区，来抵消时间差，这样便解决了windows与ubuntu的时间问题。 哈哈哈，是不是非常简单呢？如果你只是简单使用ubuntu这样设置就已经可以了，要是准备深入学习还是建议用专业的方法来解决这个问题。","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"},{"name":"time synchronization","slug":"time-synchronization","permalink":"https://xiao_feng_yang993.gitee.io/tags/time-synchronization/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"给linux终端设置代理","slug":"linux下为终端设置代理","date":"2020-03-07T09:35:36.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/07/linux下为终端设置代理/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/07/linux%E4%B8%8B%E4%B8%BA%E7%BB%88%E7%AB%AF%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/","excerpt":"","text":"在安装showdsocks的情况下，浏览器就可以正常实现通过代理访问了，但是对于linux用户来说，终端是个常用的工具，如何给终端设置代理让终端也能通过代理进行访问呢？ 1. curl，wget这俩是常用的命令，实现代理的方式是 （1）安装polipo1sudo apt-get install polipo （2）配置 polipo1sudo vim &#x2F;etc&#x2F;polipo&#x2F;config 在它的末尾添加以下命令，或者去掉以下命令前面的注释符号；若此文件不存在，则自己创建 12socksParentProxy &#x3D; &quot;localhost:1080&quot;socksProxyType &#x3D; socks5 （3）重新启动 polipo 服务1sudo systemctl restart polipo.service 查看状态 1sudo systemctl status polipo.service 得到类似如下结果 1234567891011121314polipo.service - LSB: Start or stop the polipo web cache Loaded: loaded (&#x2F;etc&#x2F;init.d&#x2F;polipo; generated; vendor preset: enabled) Active: active (running) since Tue 2019-12-03 03:24:15 CST; 34min ago Docs: man:systemd-sysv-generator(8) Process: 4799 ExecStop&#x3D;&#x2F;etc&#x2F;init.d&#x2F;polipo stop (code&#x3D;exited, status&#x3D;0&#x2F;SUCCESS) Process: 4806 ExecStart&#x3D;&#x2F;etc&#x2F;init.d&#x2F;polipo start (code&#x3D;exited, status&#x3D;0&#x2F;SUCCESS) Tasks: 1 (limit: 4915) CGroup: &#x2F;system.slice&#x2F;polipo.service └─4817 &#x2F;usr&#x2F;bin&#x2F;polipo -c &#x2F;etc&#x2F;polipo&#x2F;config pidFile&#x3D;&#x2F;var&#x2F;run&#x2F;polipo&#x2F;polipo.pid daemonise&#x3D;true12月 03 03:24:15 systemd[1]: Starting LSB: Start or stop the polipo web cache...12月 03 03:24:15 polipo[4817]: Established listening socket on port 8123.12月 03 03:24:15 polipo[4806]: Starting polipo: polipo.12月 03 03:24:15 systemd[1]: Started LSB: Start or stop the polipo web cache. （4）终端设置代理环境，如果想长期生效的那么在 .zshrc 或者 .bashrc 下增加12export http_proxy&#x3D;http:&#x2F;&#x2F;localhost:8123 export https_proxy&#x3D;http:&#x2F;&#x2F;localhost:8123 polipo 的默认端口时 8123 这时wget和curl都可以通过代理实现访问了，但是想要通过apt安装软件却任然不行 2. apt在apt的配置文件目录下创建代理配置文件： 123sudo vim &#x2F;etc&#x2F;apt&#x2F;apt.conf.d&#x2F;10proxy #这个文件正常不存在，会新建一个#编辑内容为：Acquire::http::Proxy &quot;http:&#x2F;&#x2F;localhost:8123&quot;; 退出终端，重新打开。此时便可以通过代理使用apt安装软件了。 3. gitgit是软件从业者常用的一个软件，世界上最大的开源社区github由于服务器在国外，下载速度非常慢，常常需要使用代理服务。 设置代理 123git config --global https.proxy http:&#x2F;&#x2F;localhost:8123git config --global https.proxy https:&#x2F;&#x2F;localhost:8123 取消代理 123git config --global --unset http.proxygit config --global --unset https.proxy 测试效果参考：[https://www.cnblogs.com/andrewwang/p/9293031.html]","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"},{"name":"proxy","slug":"proxy","permalink":"https://xiao_feng_yang993.gitee.io/tags/proxy/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-03-07T09:09:09.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/07/hello-world/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://xiao_feng_yang993.gitee.io/tags/hexo/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]}]}