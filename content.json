{"meta":{"title":"yangxiaofeng的博客","subtitle":"","description":"","author":"yangxiaofeng","url":"https://xiao_feng_yang993.gitee.io"},"pages":[{"title":"杨晓峰的个人技术博客","date":"2022-01-29T09:02:30.000Z","updated":"2022-02-23T16:29:40.442Z","comments":true,"path":"about/index.html","permalink":"https://xiao_feng_yang993.gitee.io/about/index.html","excerpt":"","text":"个人简历简历"},{"title":"categories","date":"2020-03-08T11:36:25.013Z","updated":"2020-03-08T05:44:26.852Z","comments":true,"path":"categories/index.html","permalink":"https://xiao_feng_yang993.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-08T05:48:13.194Z","updated":"2020-03-08T05:48:13.194Z","comments":true,"path":"tags/index.html","permalink":"https://xiao_feng_yang993.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"MiniOS-Arm64 bootloader设计实现","slug":"MiniOS-Arm64-bootloader设计实现","date":"2023-06-10T05:59:36.000Z","updated":"2023-06-10T10:42:34.036Z","comments":true,"path":"2023/06/10/MiniOS-Arm64-bootloader设计实现/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2023/06/10/MiniOS-Arm64-bootloader%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"一．概述实现 loader 实现了汇编准备和跳转到 C 程序 EL 等级切换，sp 栈指针，bss 段清理，异常向量和跳转到 C 程序 实现了串口显示 实现了屏幕显示 实现了 sd 读写 实现了 fat32 文件系统及其读取 实现了 mmu 初始化，建立了 2 份页表 加载了 kernel.img 镜像文件，并跳转到 kernel 执 二．具体实现loader 汇编部分树莓派 3 默认从 0x80000 处执行，loader 程序将被加载到内存的物理地址 0x80000 处 链接器脚本 link.ld123456789101112131415161718192021222324252627SECTIONS&#123; .= 0x80000; .text : &#123;KEEP(*(.text.boot)) * (.text.text.*.gnu.linkonce.t *)&#125; .rodata : &#123;*(.rodata.rodata.*.gnu.linkonce.r *)&#125; .= ALIGN(4096); PROVIDE(_data =.); .data : &#123;*(.data.data.*.gnu.linkonce.d *)&#125; .bss(NOLOAD) : &#123; .= ALIGN(16); __bss_start =.; *(.bss.bss.*) * (COMMON) __bss_end =.; &#125; .= ALIGN(0x00001000); /*output format buffer*/ _op_buf =.; .data.opbuf: &#123; .+= (1 &lt;&lt; 12); &#125; .= ALIGN(0x00001000); _fat_buf =.; .data.fatbuf: &#123; .+= (4 * (1 &lt;&lt; 12)); &#125; .= ALIGN(0x00001000); _end =.; / DISCARD /: &#123; *(.comment) * (.gnu *)*(.note *)*(.eh_frame *) &#125;&#125;__bss_size = (__bss_end - __bss_start) &gt;&gt; 3;_kernel_addr = 0xFFFFFF8000200000; 链接器脚本中，首先指定了 elf 程序的起始虚拟地址为 0x80000，接下来是 text 代码段，再往后分别是 rodata，data，bss 段。此外还设置了_op_buf 的 4K 空间用于存储格式化输出显示的 buffer，_fat_buf 的 16k 空间用于存储 fat32 文件系统的数据结构。最 后 是 bss_size 指 明 bss 段 大 小 ，_kernel_addr表明内核加载地址为虚拟地址的0xFFFFFF8000200000。 Start.S1234567891011.section \".text.boot\".global _start_start:// read cpu id, stop slave coresmrs x1, mpidr_el1and x1, x1, #3cbz x1, 2f// cpu id &gt; 0, stop1: wfeb 1b2: // cpu id == 0 _start 表示程序入口地址，section “.text.boot”与 link.ld 里的.text.boot 相对应，表示将.text.boot 段放在.text 下. 1.text : &#123; KEEP(*(.text.boot)) *(.text .text.* .gnu.linkonce.t*) &#125; 程序读取了 cpu 的 id，因为一开始是多核在运行，需要关闭非 0 号核心，对不是 0 的核心跳转到 1 处，运行 wfe 暂停核心进入低功耗模式，并执行死循环。 12345678910111213141516172: // cpu id == 0// set stack before our codeldr x1, =_start// set up EL1mrs x0, CurrentELand x0, x0, #12 // clear reserved bits// running at EL3?cmp x0, #12bne 5f// should never be executed, just for completenessmov x2, #0x5b1msr scr_el3, x2mov x2, #0x3c9msr spsr_el3, x2adr x2, 5fmsr elr_el3, x2eret 将_start 的地址写到 x1 寄存器中，读取 el 等级，判断是否 el3，如果不是 el3 则向后跳转到5处。 123456789101112131415161718192021222324252627282930313233// running at EL2?5: cmp x0, #4beq 5fmsr sp_el1, x1// enable CNTP for EL1mrs x0, cnthctl_el2orr x0, x0, #3msr cnthctl_el2, x0msr cntvoff_el2, xzr// disable coprocessor trapsmov x0, #0x33FFmsr cptr_el2, x0msr hstr_el2, xzrmov x0, #(3 &lt;&lt; 20)msr cpacr_el1, x0// enable AArch64 in EL1mov x0, #(1 &lt;&lt; 31) // AArch64orr x0, x0, #(1 &lt;&lt; 1) // SWIO hardwired on Pi3msr hcr_el2, x0mrs x0, hcr_el2// Setup SCTLR accessmov x2, #0x0800movk x2, #0x30d0, lsl #16msr sctlr_el1, x2// set up exception handlersldr x2, =_vectorsmsr vbar_el1, x2// change execution level to EL1mov x2, #0x3c4msr spsr_el2, x2adr x2, 5fmsr elr_el2, x2eret 判断 el 等级是否 el1，如果是，则设置 sp_el1 寄存器，允许 el2 等级下对 el1 的配置寄存器进行控制。关闭核心陷入，打开 el1 的 64 位模式，设置 mmu 控制权限，设置异常向量寄存vbar_el1，设置 el 异常状态，设置 elr_el2 返回地址，表示 5f 的位置，执行 eret 后将进入el1 异常等级，并从5f 处开始执行。 12345678910111213145: mov sp, x1// clear bssldr x1, =__bss_startldr w2, =__bss_size3: cbz w2, 4fstr xzr, [x1], #8sub w2, w2, #1cbnz w2, 3b// jump to C code, should not return4: bl main// for failsafe, halt this core tooldr x2, =_kernel_addrbr x2b 1b 将代码起点_start 的地址设置为栈指针寄存器的值，将 bss 段内存初始化为 0，带返回地址跳转到 C 程序的 main 函数，跳转到_kernel_addr 位置处执行，最后一个死循环，用于执行异常返回到此后的指令安全。 1234567891011121314// a dummy exception handler in this tutorialexc_handler:eret// important, code has to be properly aligned.align 11_vectors:// synchronous.align 7mov x0, #0mrs x1, esr_el1mrs x2, elr_el1mrs x3, spsr_el1mrs x4, far_el1b exc_handler 这里是一些简单的异常处理，设置了异常向量表，异常处理函数 exc_handler。 C 程序gpio.h12345678910111213141516171819#define MMIO_BASE 0x3F000000#define GPFSEL0 ((volatile unsigned int*)(MMIO_BASE+0x00200000))#define GPFSEL1 ((volatile unsigned int*)(MMIO_BASE+0x00200004))#define GPFSEL2 ((volatile unsigned int*)(MMIO_BASE+0x00200008))#define GPFSEL3 ((volatile unsigned int*)(MMIO_BASE+0x0020000C))#define GPFSEL4 ((volatile unsigned int*)(MMIO_BASE+0x00200010))#define GPFSEL5 ((volatile unsigned int*)(MMIO_BASE+0x00200014))#define GPSET0 ((volatile unsigned int*)(MMIO_BASE+0x0020001C))#define GPSET1 ((volatile unsigned int*)(MMIO_BASE+0x00200020))#define GPCLR0 ((volatile unsigned int*)(MMIO_BASE+0x00200028))#define GPLEV0 ((volatile unsigned int*)(MMIO_BASE+0x00200034))#define GPLEV1 ((volatile unsigned int*)(MMIO_BASE+0x00200038))#define GPEDS0 ((volatile unsigned int*)(MMIO_BASE+0x00200040))#define GPEDS1 ((volatile unsigned int*)(MMIO_BASE+0x00200044))#define GPHEN0 ((volatile unsigned int*)(MMIO_BASE+0x00200064))#define GPHEN1 ((volatile unsigned int*)(MMIO_BASE+0x00200068))#define GPPUD ((volatile unsigned int*)(MMIO_BASE+0x00200094))#define GPPUDCLK0 ((volatile unsigned int*)(MMIO_BASE+0x00200098))#define GPPUDCLK1 ((volatile unsigned int*)(MMIO_BASE+0x0020009C)) GPIO(General -purpose input/output):通用型输入输出。GPIO 可以作为一组的输入输出，通过拉高/拉低可以将每个引脚可以设置为不同的逻辑电平，可以用作模拟信号 IO、计数器/定时器、串口，用户可以通过 GPIO 口和硬件进行数据交互(如 UART)、控制硬件工作(如 LED、蜂鸣器等)、读取硬件的工作状态信号（如中断信号）等。此外，在一些IC（Integrated circuit ）中，GPIO 可能是复用的，所以需要配置引脚的行为。这里定义了每个 gpio 接口映射到内存的位置，MMIO_BASE 内存映射 IO 的起始地址是0x3F000000. main.c123456789101112131415161718192021222324252627282930313233void main()&#123; // set up serial console and linear frame buffer uart_init(); lfb_init(); if (sd_init() != SD_OK) &#123; uart_puts(\"Error in sd_init\\n\"); return -1; &#125; unsigned int cluster; if (!fat_getpartition()) &#123; uart_puts(\"FAT partition not found???\\n\"); return -1; &#125; // find out file in root directory entries cluster = fat_getcluster(\"KER ELF\"); if (cluster) &#123; // read into memory data = fat_readfile(cluster); // uart_dump(fat_readfile(cluster)); &#125; else &#123; uart_puts(\"there is no File\\n\"); &#125; // set up paging mmu_init(); kern_exec(data); return 0;&#125; main.c 阐述了 loader 程序主要的流程，uart 串口初始化，framebuffer 初始化也就是屏幕显示，sd 驱动初始化，获取 fat32 表信息，获取 kernel 文件的簇号，读取 kernel 文件到内存中data 起始地址处，初始化 MMU 建立页表，解析加载 elf 格式的 kernel 程序到_kernel_addr地址处，返回汇编 start.S 中继续执行跳转指令。 mailbox mbox.h 123456789101112131415161718/* a properly aligned buffer */extern volatile unsigned int mbox[36];#define MBOX_REQUEST 0/* channels */#define MBOX_CH_POWER 0#define MBOX_CH_FB 1#define MBOX_CH_VUART 2#define MBOX_CH_VCHIQ 3#define MBOX_CH_LEDS 4#define MBOX_CH_BTNS 5#define MBOX_CH_TOUCH 6#define MBOX_CH_COUNT 7#define MBOX_CH_PROP 8/* tags */#define MBOX_TAG_SETPOWER 0x28001#define MBOX_TAG_SETCLKRATE 0x38002#define MBOX_TAG_LAST 0int mbox_call(unsigned char ch); 声明了 mbox[36]数组，设置了 mailbox 相关的一宏定义——请求，channels 和 tags；声明了 mbox_call 函数。 mbox.c 123456789101112/* mailbox message buffer */volatile unsigned int __attribute__((aligned(16))) mbox[36];#define VIDEOCORE_MBOX (MMIO_BASE+0x0000B880)#define MBOX_READ ((volatile unsigned int*)(VIDEOCORE_MBOX+0x0))#define MBOX_POLL ((volatile unsigned int*)(VIDEOCORE_MBOX+0x10))#define MBOX_SENDER ((volatile unsigned int*)(VIDEOCORE_MBOX+0x14))#define MBOX_STATUS ((volatile unsigned int*)(VIDEOCORE_MBOX+0x18))#define MBOX_CONFIG ((volatile unsigned int*)(VIDEOCORE_MBOX+0x1C))#define MBOX_WRITE ((volatile unsigned int*)(VIDEOCORE_MBOX+0x20))#define MBOX_RESPONSE 0x80000000#define MBOX_FULL 0x80000000#define MBOX_EMPTY 0x40000000 定义了 mailbox 的 framebuffer channel 的相关宏的 mmap 到内存的地址；定义了 mbox[36]数组，且数组按 16 字节对齐，因为 GPU 对消息地址对齐有这一要求。 12345678910111213141516171819202122232425262728/** * Make a mailbox call. Returns 0 on failure, non-zero on success */int mbox_call(unsigned char ch)&#123; unsigned int r = (((unsigned int)((unsigned long)&amp;mbox) &amp; ~0xF) | (ch &amp; 0xF)); /* wait until we can write to the mailbox */ do &#123; asm volatile(\"nop\"); &#125; while (*MBOX_STATUS &amp; MBOX_FULL); /* write the address of our message to the mailbox with channel identifier */ *MBOX_WRITE = r; /* now wait for the response */ while (1) &#123; /* is there a response? */ do &#123; asm volatile(\"nop\"); &#125; while (*MBOX_STATUS &amp; MBOX_EMPTY); /* is it a response to our message? */ if (r == *MBOX_READ) /* is it a valid successful response? */ return mbox[1] == MBOX_RESPONSE; &#125; return 0;&#125; 该函数实现了通过 mbox 与 GPU 通信的功能；首先在 r 中存储（mbox 的起始地址）&amp;（channel） 树莓派 Mailbox 访问一般流程：要从邮箱中读取：1、读取状态寄存器，直到没有设置 empty 标志2、从读寄存器读取数据3、如果低 4 位与所需的通道编号不匹配，则从 1 开始重复4、高 28 位是返回的数据写入邮箱：1、读取状态寄存器，直到未设置 full 标志2、将数据（移入高 28 位）与通道（低 4 位）一起写入写寄存器需要准备 28 bits 的 buffer address 也就是第一条指令处理 mbox 地址4 bits 的 channel，也就是(ch&amp;0xF)，这里一般用的是 channel 8 也即是宏 MBOX_CH_PROP，其含义是 Request from ARM for response by VC当MBOX_STATUS 的值不为 MBOX_FULL 也就是 0x80000000 时，表示 mailbox 已经准备好接收请求数据了；*MBOX_WRITE = r; 向 MBOX_WRITE 处写入准备的 32bits 变量 r 的值。while 循环中读取MBOX_STATUS 状态，直到不为 MBOX_EMPTY，说明非空就是有 GPU 返回的数据了，读取返回的 response，如果正确说明 mbox_call 执行成功，返回的数据在数组mbox 里，这里的*MBOX_READ 只是返回的状态。 Uart 串口Uart.h 1234567void uart_init();void uart_send(unsigned int c);char uart_getc();void uart_puts(char *s);void uart_hex(unsigned int d);void uart_dump(void *ptr);void uart_printf(char *fmt, ...); 定义了串口相关函数的声明，分别是串口初始化，串口发送，串口获取，串口字符串发送，串口 16 进制发送，串口解析二进制，串口格式化显示 printf。 Uart.c 1234567891011/* PL011 UART registers */#define UART0_DR ((volatile unsigned int*)(MMIO_BASE+0x00201000))#define UART0_FR ((volatile unsigned int*)(MMIO_BASE+0x00201018))#define UART0_IBRD ((volatile unsigned int*)(MMIO_BASE+0x00201024))#define UART0_FBRD ((volatile unsigned int*)(MMIO_BASE+0x00201028))#define UART0_LCRH ((volatile unsigned int*)(MMIO_BASE+0x0020102C))#define UART0_CR ((volatile unsigned int*)(MMIO_BASE+0x00201030))#define UART0_IMSC ((volatile unsigned int*)(MMIO_BASE+0x00201038))#define UART0_ICR ((volatile unsigned int*)(MMIO_BASE+0x00201044))// get address from linkerextern volatile unsigned char _op_buf; 这里定义了 uart0 串口的地址，在 MMIO_BASE 基础上添加一个偏移量。这些寄存器的具体含义见 BCM2837-ARM-Peripherals 的第 177 页，寄存器地址表和简介如下图所示 关于表中是 0x7E 为起始地址，但是代码中用 0x3F 作为起点，原因如下此处在总线地址 0x7Ennnnnn 公布的外设在物理地址 0x3Fnnnnnn 可用。 _op_buf 是从 link.ld 中获取的符号，其地址作为 printf 格式化输出用的 buffer 1234567891011121314151617181920212223242526272829303132333435/** * Set baud rate and characteristics (115200 8N1) and map to GPIO */void uart_init()&#123; register unsigned int r; /* initialize UART */ *UART0_CR = 0; // turn off UART0 /* set up clock for consistent divisor values */ mbox[0] = 9 * 4; mbox[1] = MBOX_REQUEST; mbox[2] = MBOX_TAG_SETCLKRATE; // set clock rate mbox[3] = 12; mbox[4] = 8; mbox[5] = 2; // UART clock mbox[6] = 4000000; // 4Mhz mbox[7] = 0; // clear turbo mbox[8] = MBOX_TAG_LAST; mbox_call(MBOX_CH_PROP); /* map UART0 to GPIO pins */ r = *GPFSEL1; r &amp;= ~((7 &lt;&lt; 12) | (7 &lt;&lt; 15)); // gpio14, gpio15 r |= (4 &lt;&lt; 12) | (4 &lt;&lt; 15); // alt0 *GPFSEL1 = r; *GPPUD = 0; // enable pins 14 and 15 wait_cycles(150); *GPPUDCLK0 = (1 &lt;&lt; 14) | (1 &lt;&lt; 15); wait_cycles(150); *GPPUDCLK0 = 0; // flush GPIO setup *UART0_ICR = 0x7FF; // clear interrupts *UART0_IBRD = 2; // 115200 baud *UART0_FBRD = 0xB; *UART0_LCRH = 0b11 &lt;&lt; 5; // 8n1 *UART0_CR = 0x301; // enable Tx, Rx, FIFO&#125; 该函数初始化了 uart0 串口，将 uart0 串口 map 到 gpio 引脚 14 和 15 才能实现输入输出 1234567891011121314151617181920212223242526272829/** * Send a character */void uart_send(unsigned int c)&#123; /* wait until we can send */ do &#123; asm volatile(\"nop\"); &#125; while (*UART0_FR &amp; 0x20); /* write the character to the buffer */ *UART0_DR = c;&#125;/** * Receive a character */char uart_getc()&#123; char r; /* wait until something is in the buffer */ do &#123; asm volatile(\"nop\"); &#125; while (*UART0_FR &amp; 0x10); /* read it and return */ r = (char)(*UART0_DR); /* convert carrige return to newline */ return r == '\\r' ? '\\n' : r;&#125; UART0_DR 是数据寄存器，UART0_FR 是 flag 寄存器，DR 负责读写数据，FR 负责体现 uart状态。写串口的实现就是先判断 flag 是否可用，如果可用则写 DR 位置。读串口也一样，判断 flag 是否可用，可用则读 DR 位置。 1234567891011121314151617181920212223242526272829/** * Display a string */void uart_puts(char *s)&#123; while (*s) &#123; /* convert newline to carrige return + newline */ if (*s == '\\n') uart_send('\\r'); uart_send(*s++); &#125;&#125;/** * Display a binary value in hexadecimal */void uart_hex(unsigned int d)&#123; unsigned int n; int c; for (c = 28; c &gt;= 0; c -= 4) &#123; // get highest tetrad n = (d &gt;&gt; c) &amp; 0xF; // 0-9 =&gt; '0'-'9', 10-15 =&gt; 'A'-'F' n += n &gt; 9 ? 0x37 : 0x30; uart_send(n); &#125;&#125; Puts 和 hex 只是对源数据进行了简单加工，实现了字符串写入和人可读的 16 进制写入 12345678910111213141516171819202122232425262728293031323334353637/** * Dump memory */void uart_dump(void *ptr)&#123; unsigned long a, b, d; unsigned char c; for (a = (unsigned long)ptr; a &lt; (unsigned long)ptr + 0xece0; a += 16) &#123; uart_hex(a); uart_puts(\": \"); for (b = 0; b &lt; 16; b++) &#123; c = *((unsigned char *)(a + b)); d = (unsigned int)c; d &gt;&gt;= 4; d &amp;= 0xF; d += d &gt; 9 ? 0x37 : 0x30; uart_send(d); d = (unsigned int)c; d &amp;= 0xF; d += d &gt; 9 ? 0x37 : 0x30; uart_send(d); uart_send(' '); if (b % 4 == 3) uart_send(' '); &#125; for (b = 0; b &lt; 16; b++) &#123; c = *((unsigned char *)(a + b)); lfb_printf(\"%c\", c &lt; 32 || c &gt;= 127 ? '.' : c); uart_send(c &lt; 32 || c &gt;= 127 ? '.' : c); &#125; uart_send('\\r'); uart_send('\\n'); &#125;&#125; Dump 用于格式化显示内存数据，类似于 xxd 命令功能，效果如下： 123456789101112131415161718192021/** * Display a string */void uart_printf(char *fmt, ...)&#123; __builtin_va_list args; __builtin_va_start(args, fmt); // we don't have memory allocation yet, so we // simply place our string after our code char *s = (char *)&amp;_op_buf; // use sprintf to format our string vsprintf(s, fmt, args); // print out as usual while (*s) &#123; /* convert newline to carrige return + newline */ if (*s == '\\n') uart_send('\\r'); uart_send(*s++); &#125;&#125; uart_printf 调用 vsprintf 将数据按照 format 格式进行解析重组为一个字符串，将字符串传送到 uart_puts 进行打印。 sprintf.c vsprintf 的实现如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139/** * minimal sprintf implementation */unsigned int vsprintf(char *dst, char *fmt, __builtin_va_list args)&#123; long int arg; int len, sign, i; char *p, *orig = dst, tmpstr[19]; // failsafes if (dst == (void *)0 || fmt == (void *)0) &#123; return 0; &#125; // main loop arg = 0; while (*fmt) &#123; // argument access if (*fmt == '%') &#123; fmt++; // literal % if (*fmt == '%') &#123; goto put; &#125; len = 0; // size modifier while (*fmt &gt;= '0' &amp;&amp; *fmt &lt;= '9') &#123; len *= 10; len += *fmt - '0'; fmt++; &#125; // skip long modifier if (*fmt == 'l') &#123; fmt++; &#125; // character if (*fmt == 'c') &#123; arg = __builtin_va_arg(args, int); *dst++ = (char)arg; fmt++; continue; &#125; else // decimal number if (*fmt == 'd') &#123; arg = __builtin_va_arg(args, int); // check input sign = 0; if ((int)arg &lt; 0) &#123; arg *= -1; sign++; &#125; if (arg &gt; 99999999999999999L) &#123; arg = 99999999999999999L; &#125; // convert to string i = 18; tmpstr[i] = 0; do &#123; tmpstr[--i] = '0' + (arg % 10); arg /= 10; &#125; while (arg != 0 &amp;&amp; i &gt; 0); if (sign) &#123; tmpstr[--i] = '-'; &#125; // padding, only space if (len &gt; 0 &amp;&amp; len &lt; 18) &#123; while (i &gt; 18 - len) &#123; tmpstr[--i] = ' '; &#125; &#125; p = &amp;tmpstr[i]; goto copystring; &#125; else // hex number if (*fmt == 'x') &#123; arg = __builtin_va_arg(args, long int); // convert to string i = 16; tmpstr[i] = 0; do &#123; char n = arg &amp; 0xf; // 0-9 =&gt; '0'-'9', 10-15 =&gt; 'A'-'F' tmpstr[--i] = n + (n &gt; 9 ? 0x37 : 0x30); arg &gt;&gt;= 4; &#125; while (arg != 0 &amp;&amp; i &gt; 0); // padding, only leading zeros if (len &gt; 0 &amp;&amp; len &lt;= 16) &#123; while (i &gt; 16 - len) &#123; tmpstr[--i] = '0'; &#125; &#125; p = &amp;tmpstr[i]; goto copystring; &#125; else // string if (*fmt == 's') &#123; p = __builtin_va_arg(args, char *); copystring: if (p == (void *)0) &#123; p = \"(null)\"; &#125; while (*p) &#123; *dst++ = *p++; &#125; &#125; &#125; else &#123; put: *dst++ = *fmt; &#125; fmt++; &#125; *dst = 0; // number of bytes written return dst - orig;&#125; 其内容就是根据 fmt 字符串的格式信息对原始参数字符串进行匹配解析和重组。 framebuffer lbf.h 12345void lfb_init();void lfb_print(char *s);void lfb_proprint(int x, int y, char *s);void lfb_printf(char *fmt, ...);void lfb_clear(); 定义了 framebuffer 初始化，printf 格式化打印，清屏幕，ASCII 编码字符打印(lfb_print)，非ASCII 编码字符打印(lfb_proprint) lfb.c 12345678910111213141516171819202122232425262728293031323334/* PC Screen Font as used by Linux Console */typedef struct&#123; unsigned int magic; unsigned int version; unsigned int headersize; unsigned int flags; unsigned int numglyph; unsigned int bytesperglyph; unsigned int height; unsigned int width; unsigned char glyphs;&#125; __attribute__((packed)) psf_t;extern volatile unsigned char _binary_font_psf_start;/* Scalable Screen Font (https://gitlab.com/bztsrc/scalable-font2) */typedef struct&#123; unsigned char magic[4]; unsigned int size; unsigned char type; unsigned char features; unsigned char width; unsigned char height; unsigned char baseline; unsigned char underline; unsigned short fragments_offs; unsigned int characters_offs; unsigned int ligature_offs; unsigned int kerning_offs; unsigned int cmap_offs;&#125; __attribute__((packed)) sfn_t;extern volatile unsigned char _binary_font_sfn_start;unsigned int width, height, pitch;unsigned char *lfb; 定义了 ASCII 码字符和非 ASCII 字符的数据结构，定义了字体的宽度，高度，pitch。lfb 指针将被指向 frame buffer point。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Set screen resolution to 800*600 */void lfb_init()&#123; mbox[0] = 35 * 4; mbox[1] = MBOX_REQUEST; mbox[2] = 0x48003; // set phy wh mbox[3] = 8; mbox[4] = 8; mbox[5] = 800; // FrameBufferInfo.width mbox[6] = 600; // FrameBufferInfo.height mbox[7] = 0x48004; // set virt wh mbox[8] = 8; mbox[9] = 8; mbox[10] = 800; // FrameBufferInfo.virtual_width mbox[11] = 600; // FrameBufferInfo.virtual_height mbox[12] = 0x48009; // set virt offset mbox[13] = 8; mbox[14] = 8; mbox[15] = 0; // FrameBufferInfo.x_offset mbox[16] = 0; // FrameBufferInfo.y.offset mbox[17] = 0x48005; // set depth mbox[18] = 4; mbox[19] = 4; mbox[20] = 32; // FrameBufferInfo.depth mbox[21] = 0x48006; // set pixel order mbox[22] = 4; mbox[23] = 4; mbox[24] = 1; // RGB, not BGR preferably mbox[25] = 0x40001; // get framebuffer, gets alignment on request mbox[26] = 8; mbox[27] = 8; mbox[28] = 4096; // FrameBufferInfo.pointer mbox[29] = 0; // FrameBufferInfo.size mbox[30] = 0x40008; // get pitch mbox[31] = 4; mbox[32] = 4; mbox[33] = 0; // FrameBufferInfo.pitch mbox[34] = MBOX_TAG_LAST; if (mbox_call(MBOX_CH_PROP) &amp;&amp; mbox[20] == 32 &amp;&amp; mbox[28] != 0) &#123; mbox[28] &amp;= 0x3FFFFFFF; width = mbox[5]; height = mbox[6]; pitch = mbox[33]; lfb = (void *)((unsigned long)mbox[28]); &#125; else &#123; uart_puts(\"Unable to set screen resolution to 1024x768x32\\n\"); &#125;&#125; 该函数的功能是初始化 frame buffer，mbox[36]是 CPU 与 GPU 通信的消息传输媒介，设置对应的 mbox 元素数值，调用 mbox_call 发送到 GPU，GPU 返回结果也是在 mbox 数组的对应元素中，其中 mbox[5]表示实际屏幕宽度，mbox[6]表示实际屏幕高度，mbox[33]是FrameBufferInfo.pitch。lfb 是返回的 framebuffer 的 point，也就是写数据的起始地址，可用简单理解为屏幕左上角第一个像素点的对应的内存地址。framebuffer 初始化的原理见网页 https://github.com/raspberrypi/firmware/wiki/Mailbox-property-interface#frame-buffer 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * Display a string using fixed size PSF */void lfb_print(char *s)&#123; static int x = 0, y = 0; // get our font psf_t *font = (psf_t *)&amp;_binary_font_psf_start; // 到屏幕最右侧自动换下一行，到屏幕最底部重新回到第一行显示 if (y &gt; 589) &#123; y = 0; &#125; if (x &gt; 789) &#123; y += font-&gt;height; x = 0; &#125; // draw next character if it's not zero while (*s) &#123; // get the offset of the glyph. Need to adjust this to support unicode table unsigned char *glyph = (unsigned char *)&amp;_binary_font_psf_start + font-&gt;headersize + (*((unsigned char *)s) &lt; font-&gt;numglyph ? *s : 0) * font-&gt;bytesperglyph; // calculate the offset on screen int offs = (y * pitch) + (x * 4); // variables int i, j, line, mask, bytesperline = (font-&gt;width + 7) / 8; // handle carrige return if (*s == '\\r') &#123; x = 0; &#125; else // new line if (*s == '\\n') &#123; x = 0; y += font-&gt;height; &#125; else &#123; // display a character for (j = 0; j &lt; font-&gt;height; j++) &#123; // display one row line = offs; mask = 1 &lt;&lt; (font-&gt;width - 1); for (i = 0; i &lt; font-&gt;width; i++) &#123; // if bit set, we use white color, otherwise black *((unsigned int *)(lfb + line)) = ((int)*glyph) &amp; mask ? 0xFFFFFF : 0; mask &gt;&gt;= 1; line += 4; &#125; // adjust to next line glyph += bytesperline; offs += pitch; &#125; x += (font-&gt;width + 1); &#125; // next character s++; &#125;&#125; 打印 ASCII 编码的字符，屏幕打印的本质是根据字体信息点亮像素点，在字体结构体中根据像素点数据点亮像素点，自动换行和翻页。 12345678910111213/** * clear the frame */void lfb_clear()&#123; for (int i = 0; i &lt; 600 * 8; i++) &#123; for (int j = 0; j &lt; 800; j++) &#123; *((unsigned int *)(lfb + i * 768 + j)) = 0; &#125; &#125;&#125; 清屏函数，遍历 600*800 的屏幕像素点，设置值为 0 即可，背景黑色的情况下。RGB32 图像每个像素用 32 比特位表示，占 4 个字节，R，G，B 分量分别用 8 个 bit 表示，存储顺序为 B，G，R，最后 8 个字节保留。R = color &amp; 0x0000FF00;G = color &amp; 0x00FF0000;B = color &amp; 0xFF000000;A = color &amp; 0x000000FF; 123456789101112131415/** * format output by frame */void lfb_printf(char *fmt, ...)&#123; __builtin_va_list args; __builtin_va_start(args, fmt); // we don't have memory allocation yet, so we // simply place our string after our code char *s = (char *)&amp;_op_buf; // use sprintf to format our string vsprintf(s, fmt, args); // print out as usual lfb_print(s);&#125; printf 格式化输出，首先根据 fmt 的格式解析重组参数，将重组的字符串传入 lfb_print. SD 卡驱动 sd.h 123456#define SD_OK 0#define SD_TIMEOUT -1#define SD_ERROR -2int sd_init();int sd_readblock(unsigned int lba, unsigned char *buffer, unsigned int num);int sd_writeblock(unsigned char *buffer, unsigned int lba, unsigned int num); 声明了三个 sd 接口函数，分别是初始化，从 lba 位置处读取 num 个块数据到 buffer 缓冲区，在 lba 处写入 buffer 里 num 个块的数据。 sd.c内容较复杂，单独作为文章。见另一篇 关于emmc访问sd卡的实现与分析 F32 文件系统为了减小bootloader的体积，bootloader的文件系统部分不需要太复杂，只需能够从sd卡的第一个分区（fat32文件系统）读取指定的elf文件即可，所以没有多级目录等功能。 fat.h 1234int fat_getpartition(void);unsigned int fat_getcluster(char *fn);char *fat_readfile(unsigned int cluster);void fat_listdirectory(void); 定义了四个函数，fat_getpartition 获取 FAT 表；fat_getcluster 获取文件的第一个簇号；fat_readfile 将文件数据读取到内存中，返回首地址；fat_listdirectory 列出根目录下的内容。 fat.c 123456int memcmp(void *s1, void *s2, int n)&#123;unsigned char *a=s1,*b=s2;while(n--&gt;0)&#123; if(*a!=*b) &#123; return *a-*b; &#125; a++; b++; &#125;return 0;&#125; 定义了一个内存比较函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Get the starting LBA address of the first partition * so that we know where our FAT file system starts, and * read that volume's BIOS Parameter Block */int fat_getpartition(void)&#123; unsigned char *mbr = &amp;_fat_buf; bpb_t *bpb = (bpb_t *)&amp;_fat_buf; // read the partitioning table if (sd_readblock(0, &amp;_fat_buf, 1)) &#123; // check magic if (mbr[510] != 0x55 || mbr[511] != 0xAA) &#123; uart_puts(\"ERROR: Bad magic in MBR\\n\"); return 0; &#125; // check partition type if (mbr[0x1C2] != 0xE /*FAT16 LBA*/ &amp;&amp; mbr[0x1C2] != 0xC /*FAT32 LBA*/) &#123; uart_puts(\"ERROR: Wrong partition type\\n\"); // return 0; &#125; // should be this, but compiler generates bad code... // partitionlba=*((unsigned int*)((unsigned long)&amp;_fat_buf+0x1C6)); partitionlba = mbr[0x1C6] + (mbr[0x1C7] &lt;&lt; 8) + (mbr[0x1C8] &lt;&lt; 16) + (mbr[0x1C9] &lt;&lt; 24); // read the boot record if (!sd_readblock(partitionlba, &amp;_fat_buf, 1)) &#123; uart_puts(\"ERROR: Unable to read boot record\\n\"); return 0; &#125; // check file system type. We don't use cluster numbers for that, but magic bytes if (!(bpb-&gt;fst[0] == 'F' &amp;&amp; bpb-&gt;fst[1] == 'A' &amp;&amp; bpb-&gt;fst[2] == 'T') &amp;&amp; !(bpb-&gt;fst2[0] == 'F' &amp;&amp; bpb-&gt;fst2[1] == 'A' &amp;&amp; bpb-&gt;fst2[2] == 'T')) &#123; uart_puts(\"ERROR: Unknown file system type\\n\"); return 0; &#125; return 1; &#125; return 0;&#125; 读取 sd 的第一个扇区 mbr 分区表，找见 fat32 文件系统所在分区的起始扇区。读取 fat32 文件系统的起始扇区到_fat_buf 位置处，该位置在 link.ld 中已定义。检查文件系统是否是 fat32 类型。 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Find a file in root directory entries */unsigned int fat_getcluster(char *fn)&#123; bpb_t *bpb = (bpb_t *)&amp;_fat_buf; fatdir_t *dir = (fatdir_t *)(&amp;_fat_buf + 512); unsigned int root_sec, s; // find the root directory's LBA root_sec = ((bpb-&gt;spf16 ? bpb-&gt;spf16 : bpb-&gt;spf32) * bpb-&gt;nf) + bpb-&gt;rsc; s = (bpb-&gt;nr0 + (bpb-&gt;nr1 &lt;&lt; 8)) * sizeof(fatdir_t); if (bpb-&gt;spf16 == 0) &#123; // adjust for FAT32 root_sec += (bpb-&gt;rc - 2) * bpb-&gt;spc; &#125; // add partition LBA root_sec += partitionlba; // load the root directory if (sd_readblock(root_sec, (unsigned char *)dir, s / 512 + 1)) &#123; // iterate on each entry and check if it's the one we're looking for for (; dir-&gt;name[0] != 0; dir++) &#123; // is it a valid entry? if (dir-&gt;name[0] == 0xE5 || dir-&gt;attr[0] == 0xF) continue; // filename match? if (!memcmp(dir-&gt;name, fn, 11)) &#123; // if so, return starting cluster return ((unsigned int)dir-&gt;ch) &lt;&lt; 16 | dir-&gt;cl; &#125; &#125; uart_puts(\"ERROR: file not found\\n\"); &#125; else &#123; uart_puts(\"ERROR: Unable to load root directory\\n\"); &#125; return 0;&#125; 查找根据文件名查找 root 根目录下的文件，如果找见该文件，则返回文件的第一个簇号。 123456789101112131415161718192021222324252627282930313233343536373839***Read a file into memory * / char *fat_readfile(unsigned int cluster)&#123; // BIOS Parameter Block bpb_t *bpb = (bpb_t *)&amp;_fat_buf; // File allocation tables. We choose between FAT16 and FAT32 dynamically unsigned int *fat32 = (unsigned int *)(&amp;_fat_buf + bpb-&gt;rsc * 512); unsigned short *fat16 = (unsigned short *)fat32; // Data pointers unsigned int data_sec, s; unsigned char *data, *ptr; // find the LBA of the first data sector data_sec = ((bpb-&gt;spf16 ? bpb-&gt;spf16 : bpb-&gt;spf32) * bpb-&gt;nf) + bpb-&gt;rsc; s = (bpb-&gt;nr0 + (bpb-&gt;nr1 &lt;&lt; 8)) * sizeof(fatdir_t); if (bpb-&gt;spf16 &gt; 0) &#123; // adjust for FAT16 data_sec += (s + 511) &gt;&gt; 9; &#125; // add partition LBA data_sec += partitionlba; // load FAT table s = sd_readblock(partitionlba + 1, (unsigned char *)&amp;_fat_buf + 512, (bpb-&gt;spf16 ? bpb-&gt;spf16 : bpb-&gt;spf32) + bpb-&gt;rsc); // end of FAT in memory // data=ptr=&amp;_fat_buf+512+s; data = ptr = (char *)KERNEL_IMAGE; // iterate on cluster chain while (cluster &gt; 1 &amp;&amp; cluster &lt; 0xFFF8) &#123; // load all sectors in a cluster sd_readblock((cluster - 2) * bpb-&gt;spc + data_sec, ptr, bpb-&gt;spc); // move pointer, sector per cluster * bytes per sector ptr += bpb-&gt;spc * (bpb-&gt;bps0 + (bpb-&gt;bps1 &lt;&lt; 8)); // get the next cluster in chain cluster = bpb-&gt;spf16 &gt; 0 ? fat16[cluster] : fat32[cluster]; &#125; return (char *)data;&#125; 传入参数第一个簇号，计算文件数据第一个扇区的相对 fat32 文件系统分区的 LBA 偏移，将相对偏移添加文件系统起始扇区号变为绝对 LBA 地址，加载 fat 表，根据文件数据的簇号联系读取文件内容到宏定义 KERNEL_IMAGE 位置处，返回文件在内存的起始地址。 MMU mmu.h 12void mmu_init();void setExecPages(unsigned long start_addr, unsigned long end_addr, int attr); 定义了 2 个接口，mmu 初始化，设置页表属性 mmu.c 123456#define NUM_4k 4096#define NUM_1k 1024#define PAGETABLE_LOW_EL1 (0x200000 - 512*NUM_1k) // 0x00000000~0x40000000 映射物理地址 0~1G 到线性地址低端#define PAGETABLE_HIGH_EL1 (0x200000 - 256*NUM_1k) // 0xffffff8000000000~0xffffff8040000000 映射物理地址 0~32M 到线性地址高端 页表初始化时 ttbr0 页表和 ttbr1 页表所在的内存物理地址位置，其中 ttbr0 页表在 1.5MB处，ttbr1 页表在 1.75MB 处，分别是宏定义 PAGETABLE_LOW_EL1 和 PAGETABLE_HIGH_EL1 12345678910111213141516171819#define PAGESIZE 4096// granularity#define PT_PAGE 0b11 // 4k granule#define PT_BLOCK 0b01 // 2M granule// accessibility#define PT_KERNEL (0&lt;&lt;6) // privileged, supervisor EL1 access only#define PT_USER (1&lt;&lt;6) // unprivileged, EL0 access allowed#define PT_RW (0&lt;&lt;7) // read-write#define PT_RO (1&lt;&lt;7) // read-only#define PT_AF (1&lt;&lt;10) // accessed flag#define PT_NX (1UL&lt;&lt;54) // no execute// shareability#define PT_OSH (2&lt;&lt;8) // outter shareable#define PT_ISH (3&lt;&lt;8) // inner shareable// defined in MAIR register#define PT_MEM (0&lt;&lt;2) // normal memory#define PT_DEV (1&lt;&lt;2) // device MMIO#define PT_NC (2&lt;&lt;2) // non-cachable#define TTBR_CNP 1 一些属性相关的宏定义 mmu_init内容较长，分段解释 ttbr0 页表12345678/** * Set up page translation tables and enable virtual memory */void mmu_init()&#123; unsigned long data_page = (unsigned long)&amp;_data / PAGESIZE; unsigned long r, b, *pagingttbr0 = (unsigned long *)PAGETABLE_LOW_EL1; unsigned long *pagingttbr1 = (unsigned long *)PAGETABLE_HIGH_EL1; 用了 2 个 long 类型指针 pagingttbr0 和 pagingttbr1 分别指向 PAGETABLE_LOW_EL1 和PAGETABLE_HIGH_EL1 位置内存。data_page 是 loader 的 data 段与 0x80000 的偏移页表数量。data_page 之前是 text 段，之后是 data 段。 12345678/* create MMU translation tables at PAGETABLE_LOW_EL1 */// TTBR0, identity L1pagingttbr0[0] = (unsigned long)((unsigned char *)PAGETABLE_LOW_EL1 + PAGESIZE) | // physical address PT_PAGE | // it has the \"Present\" flag, which must be set, and we have area in it mapped by pages PT_AF | // accessed flag. Without this we're going to have a Data Abort exception PT_USER | // non-privileged PT_ISH | // inner shareable PT_MEM; // normal memory 建立 ttbr0 的 level 1 页表第一个表项，指向下一个连续的物理页首地址，因为物理内存仅有1G，level 1 页表只占用 1 个表项 12345678// identity L2, first 2M blockpagingttbr0[1 * 512] = (unsigned long)((unsigned char *)PAGETABLE_LOW_EL1 + 2 * PAGESIZE) | // physical address PT_PAGE | // we have area in it mapped by pages PT_AF | // accessed flag PT_USER | // non-privileged PT_ISH | // inner shareable PT_MEM; // normal memory ttbr0 的 level 2 页表，第一个表项指向下一物理页的首地址，以备后续建立 4k map 1234567891011// identity L2 2M blocksb = MMIO_BASE &gt;&gt; 21;// skip 0th, as we're about to map it by L3for (r = 1; r &lt; 512; r++) pagingttbr0[1 * 512 + r] = (unsigned long)((r &lt;&lt; 21)) | // physical address PT_BLOCK | // map 2M block PT_AF | // accessed flag PT_NX | // no execute PT_USER | // non-privileged (r &gt;= b ? PT_OSH | PT_DEV : PT_ISH | PT_MEM); // different attributes for devicememory ttbr0 的 level 2 页表第 1-511 页用于建立 2M 的 map，可用覆盖 2M~1G 这片物理内存地址空间，区分了常规内存和设备内存，其区别在于——设备内存属性为 outter shareable 和device MMIO，常规内存属性为 inner shareable 和 normal memory。 12345678// identity L3for(r=0;r&lt;512;r++)pagingttbr0[2*512+r]=(unsigned long)(r*PAGESIZE) | // physical addressPT_PAGE | // map 4kPT_AF | // accessed flagPT_USER | // non-privilegedPT_ISH | // inner shareable((r&lt;0x80||r&gt;=data_page)? PT_RW|PT_NX : PT_RO); // different for code and data 物理地址 02M 的空间采用了 4k map，位于 level 3 页表上，也就是 loader 所在的地址区间，需要区分程序的代码段和数据段，代码段位于 0x80000data_page*4k 采用只读属性，其余空间采用读写不可执行属性。 ttbr0 的页表结构如下图所示 ttbr1 页表 1234567// TTBR1, kernel L1pagingttbr1[511] = (unsigned long)((unsigned char *)PAGETABLE_HIGH_EL1 + PAGESIZE) | // physical address PT_PAGE | // we have area in it mapped by pages PT_AF | // accessed flag PT_KERNEL | // privileged PT_ISH | // inner shareable PT_MEM; // normal memory ttbr1 的 level 1 页表最后一项指向下一物理页，这一表项以后用于设备内存在 ttbr1 的映射。 123456pagingttbr1[0] = (unsigned long)((unsigned char *)PAGETABLE_HIGH_EL1 + 3 * PAGESIZE) | // physical address PT_PAGE | // we have area in it mapped by pages PT_AF | // accessed flag PT_KERNEL | // privileged PT_ISH | // inner shareable PT_MEM; // normal memory ttbr1 的 level 1 页表第一项指向往后第 3 张页表的起始地址，因为只给内核建立 64MB 空间，所以 level 1 页表只需要一个表项，该表项有特权属性 PT_KERNEL. 12345678// kernel L2pagingttbr1[1 * 512 + 511] = (unsigned long)((unsigned char *)PAGETABLE_HIGH_EL1 + 2 * PAGESIZE) | // physical address PT_PAGE | // we have area in it mapped by pages PT_AF | // accessed flag PT_KERNEL | // privileged PT_ISH | // inner shareable PT_MEM; // normal memory ttbr1 起第二项页表的最后一个表项指向下一个页起始地址 1234567for (r = 0; r &lt; 32; r++) pagingttbr1[3 * 512 + r] = (unsigned long)((unsigned char *)PAGETABLE_HIGH_EL1 + 4 * PAGESIZE + r * PAGESIZE) | // physical address PT_PAGE | // we have area in it mapped by pages PT_AF | // accessed flag PT_KERNEL | // privileged PT_ISH | // inner shareable PT_MEM; // normal memory 在 level 2 页表中建立 32 个表项，来建立 64MB 的 4k map，每项指向后面连续一张物理页。 123456789101112for (int i = 0; i &lt; 32; i++) // 32 * 2M = 64M&#123; for (r = 0; r &lt; 512; r++) &#123; pagingttbr1[(4 + i) * 512 + r] = (unsigned long)(512 * i * PAGESIZE + r * PAGESIZE) | // physical address PT_PAGE | // map 4k PT_AF | // accessed flag PT_KERNEL | // non-privileged PT_ISH | // inner shareable PT_RW | PT_NX; // different for code and data &#125;&#125; ttbr1 的 level 3 页表，共 32 张物理页，每张物理页映射了 2MB 物理内存，每一个表项表示4KB 内存，覆盖了 0~64MB 的物理地址空间，这里内存属性全部暂时默认为了可读写不可执行，因为后续还要加载 kernel elf 文件，需要读写_kernel_addr 位置的内存。 12345678// kernel L3pagingttbr1[2 * 512] = (unsigned long)(MMIO_BASE + 0x00201000) | // physical address PT_PAGE | // map 4k PT_AF | // accessed flag PT_NX | // no execute PT_KERNEL | // privileged PT_OSH | // outter shareable PT_DEV; // device memory 在 ttbr1 起第三张页表的第一项建立 UART 串口读写的映射，也就是之前 uart 章节里的uart_DR 寄存器，实现用 0xffffff8000201000 地址来读写串口实现显示和输出。 enable MMU 设置123456789// check for 4k granule and at least 36 bits physical address bus */asm volatile(\"mrs %0, id_aa64mmfr0_el1\" : \"=r\"(r));b = r &amp; 0xF;if (r &amp; (0xF &lt;&lt; 28) /*4k*/ || b &lt; 1 /*36 bits*/)&#123; uart_puts(\"ERROR: 4k granule or 36 bit address space not supported\\n\"); return;&#125; 检查 AArch64 内存模型特性寄存器 0，AArch64 Memory Model Feature Register 0 的值，判断 cpu 是否支持 4K 和至少 bus 有 36bit 的宽度，因为三级页表+4K 占 3*9+11=36bit。 12345678// first, set Memory Attributes array, indexed by PT_MEM, PT_DEV, PT_NC in ourexample r = (0xFF &lt;&lt; 0) | // AttrIdx=0: normal, IWBWA, OWBWA, NTR (0x04 &lt;&lt; 8) | // AttrIdx=1: device, nGnRE (must be OSH too) (0x44 &lt;&lt; 16); // AttrIdx=2: non cacheableasm volatile(\"msr mair_el1, %0\" : : \"r\"(r)); 设置页表 mair_el1 属性ARM.v8 架构引入了 mair_el1 寄存器。该寄存器由 8 个部分组成，每个部分为 8 位长。每个这样的部分都配置了一组通用属性。然后，描述符仅指定 mair 部分的索引，而不是直接指定所有属性。这允许仅使用描述符中的 3 位来引用 mair 部分。 mair 部分中每个位的含义在 AArch64-Reference-Manual 的第 3557 页 D13.2.95 节进行了描述。在这里，我们只使用了几个可用的属性选项。这是为 mair 寄存器准备值的代码。在这里，我们只使用了 mair 寄存器中 8 个可用插槽中的 3 个。第二个对应于设备内存，第三个对应于普通的不可缓存内存。DEVICE_nGnRnE 和 NORMAL_NOCACHE 是我们将在块描述符中使用的索引，0x04 和 0x44 是我们存储在 mair_el1 寄存器的前 2 个插槽中的值。 123456789101112131415161718// next, specify mapping characteristics in translate control registerr = (0b00LL &lt;&lt; 37) | // TBI=0, no tagging (b &lt;&lt; 32) | // IPS=autodetected (0b10LL &lt;&lt; 30) | // TG1=4k (0b11LL &lt;&lt; 28) | // SH1=3 inner (0b01LL &lt;&lt; 26) | // ORGN1=1 write back (0b01LL &lt;&lt; 24) | // IRGN1=1 write back (0b0LL &lt;&lt; 23) | // EPD1 enable higher half (25LL &lt;&lt; 16) | // T1SZ=25, 3 levels (512G) (0b00LL &lt;&lt; 14) | // TG0=4k (0b11LL &lt;&lt; 12) | // SH0=3 inner (0b01LL &lt;&lt; 10) | // ORGN0=1 write back (0b01LL &lt;&lt; 8) | // IRGN0=1 write back (0b0LL &lt;&lt; 7) | // EPD0 enable lower half (25LL &lt;&lt; 0); // T0SZ=25, 3 levels (512G)asm volatile(\"msr tcr_el1, %0; isb\" : : \"r\"(r)); TCR_EL1 寄存器主要用来控制这 TTBR0 和 TTBR1 两套地址翻译系统，重点是要设置 T0SZ 和T1SZ 为 25，因为我们的页表翻译系统是 3 级页表+4K map，64bit 的地址高 25 位不计入地址翻译。 T1SZ, bits [21:16]和 T0SZ, bits [5:0]定义了虚拟地址的宽度。 TBI1，bit[38]和 TBI0，bit[37]用来控制是否忽略地址的高 8 位（TBI 就是 Top Byte ignored 的意思），如果允许忽略地址的高 8 位，那么 MMU 的硬件在进行地址比对，匹配的时候忽略高八位。 TG1，bits [31:30]和 TG0，bits [15:14]是用来控制 page size 的，可以是 4K，16K 或者 64K。 SH1, bits [29:28]和 SH0, bits [13:12]是用来控制页表所在 memory 的 Shareability attribute。ORGN1, bits [27:26]和 ORGN0, bits [11:10]用来控制页表所在 memory 的 outercachebility attribute 的。 IRGN1, bits [25:24]和IRGN0, bits [9:8]用来控制页表所在memory的inner cachebility attribute的。 最后将 r 的值写入到 tcr_el1 寄存器中。 12345// tell the MMU where our translation tables are. TTBR_CNP bit not documented, but required// lower half, user spaceasm volatile (\"msr ttbr0_el1, %0\" : : \"r\" ((unsigned long)PAGETABLE_LOW_EL1 + TTBR_CNP));// upper half, kernel spaceasm volatile (\"msr ttbr1_el1, %0\" : : \"r\" ((unsigned long)PAGETABLE_HIGH_EL1 + TTBR_CNP)); 这两句汇编指令是设置 ttbr0 和 ttbr1 页表寄存器的页表入口地址，分别是宏定义PAGETABLE_LOW_EL1 和 PAGETABLE_HIGH_EL1，TTBR_CNP 是 ASID - 局部页表的地址空间标识。 地址空间标识 ASID许多现代的操作系统让所有的应用运行在同样的地址区域，这就是我们提到的用户地址空间。实际上，不同的应用需要不同的地址映射。比如，VA 0x8000 实际转换的物理地址取决于当前正在运行的应用，即每个应用程序自己维护一个页表。 理想状态下，我们希望不同的应用的页表项共存于 TLBs 中，防止上下文切换时 TLB 中没有当前应用（准确地讲应该是指进程）的页表项。但是处理器怎么知道不同应用的 VA 0x8000 对应的物理地址呢？在 ARMv8-A 架构中，用的是 Address Space Identifier (ASIDs)。 对于 EL0/EL1 虚拟地址空间，通过页表项属性字段的 nG 位标记页表为 Global(G)或者 Non-Global(nG)。比如，内核地址映射为全局页表，应用程序地址映射为非全局页表。不管当前执行的是哪个应用程序，全局页表都是生效的；非全局页表只有在特定应用执行时才生效。 非全局页表项在 TLBs 中使用 ASID 标记。在进行 TLB 查找时，将当前选择的 ASID 与TLB 页表项中的 ASID 进行比较。如果不匹配，则表示当前 TLB 页表项无效。下图显示了全局页表和局部页表，以及 ASID 标记： 上图展示了不同应用的 TLB 页表项可以在缓存中共存，由 ASID 决定哪一个页表项生效。 ASID 保存在两个 TTBRn_EL1 寄存器之中，通常用户空间使用 TTBR0_EL1 寄存器。因此，TTBRn_EL1 寄存器值的更新会同时更新 ASID 和当前生效的页表项。 TTBR0_ELx 和 TTBR1_ELx BADDR - 起始页表项的物理地址 ASID - 局部页表的地址空间标识 12345678910111213141516// finally, toggle some bits in system control register to enablepage translation asm volatile(\"dsb ish; isb; mrs %0, sctlr_el1\" : \"=r\"(r));r |= 0xC00800; // set mandatory reserved bitsr &amp;= ~((1 &lt;&lt; 25) | // clear EE, little endian translation tables (1 &lt;&lt; 24) | // clear E0E (1 &lt;&lt; 19) | // clear WXN (1 &lt;&lt; 12) | // clear I, no instruction cache (1 &lt;&lt; 4) | // clear SA0 (1 &lt;&lt; 3) | // clear SA (1 &lt;&lt; 2) | // clear C, no cache at all (1 &lt;&lt; 1)); // clear A, no aligment checkr |= (1 &lt;&lt; 0); // set M, enable MMUasm volatile(\"msr sctlr_el1, %0; isb\" : : \"r\"(r)); mmu_init 的最后通过设置 sctlr_el1 启动 EL0 和 EL1 的 MMUSCTLR_EL1 是一个对整个系统（包括 memory system）进行控制的寄存器。C bit[2]是用来 enable 或者 disable EL0 &amp; EL1 的 data cache。具体包括通过 stage 1translation table 访问的 memory 以及对 stage 1 translation table 自身 memory 的访问。I bit[12]是用来 enable 或者 disable EL0 &amp; EL1 的 instruction cache。M bit[0]是用来 enable 或者 disable EL0 &amp; EL1 的 MMU。 其它 bit 位含义介绍见下表 setExecPages 12345678910111213141516171819202122void setExecPages(unsigned long start_addr, unsigned long end_addr, int attr)&#123; unsigned long r, *paging = (unsigned long *)PAGETABLE_HIGH_EL1; unsigned long *pagingttbr0 = (unsigned long *)PAGETABLE_LOW_EL1; if (attr == 0) // 只读不可执行 &#123; for (int i = 0; i &lt; 32; i++) // 32 * 2M = 64M &#123; for (r = 0; r &lt; 512; r++) &#123; if ((i * 512 + r) &gt;= start_addr &gt;&gt; 12 &amp;&amp; (i * 512 + r) &lt; end_addr &gt;&gt; 12) &#123; paging[(4 + i) * 512 + r] = (unsigned long)(512 * i * 4096 + r * 4096) | // physical address PT_PAGE | // map 4k PT_AF | // accessed flag PT_KERNEL | // privileged PT_ISH | // inner shareable PT_RO | PT_NX; // different for code and data &#125; &#125; &#125; &#125; 这段代码显示了函数的形参，起始地址，终止地址，属性；设置了 rodata 段的页表属性 123456789101112131415161718192021222324252627282930313233343536373839else if (attr == 1) // 只读可执行&#123; for (int i = 0; i &lt; 32; i++) // 32 * 2M = 64M &#123; for (r = 0; r &lt; 512; r++) &#123; if ((i * 512 + r) &gt;= start_addr &gt;&gt; 12 &amp;&amp; (i * 512 + r) &lt; end_addr &gt;&gt; 12) &#123; paging[(4 + i) * 512 + r] = (unsigned long)(512 * i * 4096 + r * 4096) | // physical address PT_PAGE | // map 4k PT_AF | // accessed flag PT_KERNEL | // privileged PT_ISH | // inner shareable PT_RO; // different for code and data &#125; &#125; &#125;&#125;else if (attr == 2) // 读写，不可执行&#123; for (int i = 0; i &lt; 32; i++) // 32 * 2M = 64M &#123; for (r = 0; r &lt; 512; r++) &#123; if ((i * 512 + r) &gt;= start_addr &gt;&gt; 12 &amp;&amp; (i * 512 + r) &lt; end_addr &gt;&gt; 12) &#123; paging[(4 + i) * 512 + r] = (unsigned long)(512 * i * 4096 + r * 4096) | // physical address PT_PAGE | // map 4k PT_AF | // accessed flag PT_KERNEL | // privileged PT_ISH | // inner shareable PT_RW | PT_NX; // different for code and data &#125; &#125; &#125;&#125; 这两个 else if 处理了代码段和 data 段的页表属性设置，主要是读写和执行属性 12345678else if (attr == -1) // USER 可执行读写 kernel 代码&#123; pagingttbr0[1 * 512 + 1] = (unsigned long)((1 &lt;&lt; 21)) | // physical address PT_BLOCK | // map 2M block PT_AF | // accessed flag PT_USER | // non-privileged PT_ISH; // different attributes for device memory&#125; 这个 else if 分支让 USER 态可以执行 kernel 的 text 代码段，因为创建的第一个用户态程序的指令是在 kernel 中的，以后 kernel 实现了加载 elf 文件后就不再使用这段代码了。 elf 解析与加载 elf.h 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* The ELF file header. This appears at the start of every ELF file. */typedef struct&#123; unsigned char e_ident[EI_NIDENT]; /* Magic number and other info */ Elf64_Half e_type; /* Object file type */ Elf64_Half e_machine; /* Architecture */ Elf64_Word e_version; /* Object file version */ Elf64_Addr e_entry; /* Entry point virtual address */ Elf64_Off e_phoff; /* Program header table file offset */ Elf64_Off e_shoff; /* Section header table file offset */ Elf64_Word e_flags; /* Processor-specific flags */ Elf64_Half e_ehsize; /* ELF header size in bytes */ Elf64_Half e_phentsize; /* Program header table entry size */ Elf64_Half e_phnum; /* Program header table entry count */ Elf64_Half e_shentsize; /* Section header table entry size */ Elf64_Half e_shnum; /* Section header table entry count */ Elf64_Half e_shstrndx; /* Section header string table index */&#125; Elf64_Ehdr;/* Section header. */typedef struct&#123; Elf64_Word sh_name; /* Section name (string tbl index) */ Elf64_Word sh_type; /* Section type */ Elf64_Xword sh_flags; /* Section flags */ Elf64_Addr sh_addr; /* Section virtual addr at execution */ Elf64_Off sh_offset; /* Section file offset */ Elf64_Xword sh_size; /* Section size in bytes */ Elf64_Word sh_link; /* Link to another section */ Elf64_Word sh_info; /* Additional section information */ Elf64_Xword sh_addralign; /* Section alignment */ Elf64_Xword sh_entsize; /* Entry size if section holds table */&#125; Elf64_Shdr;/* Program segment header. */typedef struct&#123; Elf64_Word p_type; /* Segment type */ Elf64_Word p_flags; /* Segment flags */ Elf64_Off p_offset; /* Segment file offset */ Elf64_Addr p_vaddr; /* Segment virtual address */ Elf64_Addr p_paddr; /* Segment physical address */ Elf64_Xword p_filesz; /* Segment size in file */ Elf64_Xword p_memsz; /* Segment size in memory */ Elf64_Xword p_align; /* Segment alignment */&#125; Elf64_Phdr; 与 x86 的 miniOS 中的 elf.h 一样，只是将数据结构中的成员类型改为 64 位数据结构，参考了 Linux 的/usr/include/elf.h 文件中对 elf header，Program Header 和 Section header 的定义。 elf.c移植自 miniOS-x86，在加载 program 段的时候，做了少许修改，新增内容如下： 123456789101112131415161718192021222324252627282930313233343536else if (Echo_Phdr[ph_num]-&gt;p_flags == 0x7) // 一个 program，多个 section&#123; exec_elfPhdrcpy(fd, Echo_Phdr[ph_num], 1); // 进程 Program for (sh_num = 0; sh_num &lt; Echo_Ehdr-&gt;e_shnum; sh_num++) &#123; if (Echo_Shdr[sh_num]-&gt;sh_flags == 0x6) &#123; // text start_addr = Echo_Shdr[sh_num]-&gt;sh_addr; end_addr = Echo_Shdr[sh_num]-&gt;sh_addr + Echo_Shdr[sh_num]-&gt;sh_size; end_addr = end_addr % 4096 == 0 ? end_addr : end_addr + (4096 - end_addr % 4096); start_addr &amp;= 0x0000007fffffffff; end_addr &amp;= 0x0000007fffffffff; setExecPages(start_addr, end_addr, 1); &#125; else if (Echo_Shdr[sh_num]-&gt;sh_flags == 0x32) &#123; // rodata start_addr = Echo_Shdr[sh_num]-&gt;sh_addr; end_addr = Echo_Shdr[sh_num]-&gt;sh_addr + Echo_Shdr[sh_num]-&gt;sh_size; end_addr = end_addr % 4096 == 0 ? end_addr : end_addr + (4096 - end_addr % 4096); start_addr &amp;= 0x0000007fffffffff; end_addr &amp;= 0x0000007fffffffff; setExecPages(start_addr, end_addr, 0); &#125; else if (Echo_Shdr[sh_num]-&gt;sh_flags == 0x3) &#123; // bss data start_addr = Echo_Shdr[sh_num]-&gt;sh_addr; end_addr = Echo_Shdr[sh_num]-&gt;sh_addr + Echo_Shdr[sh_num]-&gt;sh_size; end_addr = end_addr % 4096 == 0 ? end_addr : end_addr + (4096 - end_addr % 4096); start_addr &amp;= 0x0000007fffffffff; end_addr &amp;= 0x0000007fffffffff; setExecPages(start_addr, end_addr, 2); &#125; else &#123; continue; &#125; exec_load 函数中，本次的 kernel 只有一个 LOAD 段，需要对具体的 section 做进一步处理，在 Echo_Phdr[ph_num]-&gt;p_flags 的分类讨论添加一种情况，表示该 LOAD 段属性既有读写又有执行，即 flags==0x7；exec_elfPhdrcpy 用法与 miniOS-x86 一样, 这里需要对不同的段设置页表属性。section 中 text 段，计算完起始页表物理地址后传入 setExecPages 函数设置页表属性为只读可执行section 中 rodata 段，计算完起始页表物理地址后传入 setExecPages 函数设置页表属性为只读不可执行section 中 data，bss 段，计算完起始页表物理地址后传入 setExecPages 函数设置页表属性为可读写不可执行 1234567891011/** * read and load kernel.elf */int kern_exec(char *data)&#123; Elf64_Ehdr *Echo_Ehdr; Elf64_Phdr *Echo_Phdr[10]; Elf64_Shdr *Echo_Shdr[20]; read_elf(data, &amp;Echo_Ehdr, Echo_Phdr, Echo_Shdr); exec_load(data, Echo_Ehdr, Echo_Phdr, Echo_Shdr);&#125; kern_exec 接口函数将被 main.c 调用，实现 kernel elf 文件的加载和解析。原理与 miniOS\u0002x86 一样，不做过多叙述。 kernel 的 link.ld 里指定了 kernel.elf 的起始虚拟地址是 0xffffff8000200000","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"},{"name":"树莓派","slug":"树莓派","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"汇编","slug":"汇编","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E6%B1%87%E7%BC%96/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"开源镜像站建设","slug":"开源镜像站建设","date":"2022-11-17T08:55:43.000Z","updated":"2023-06-05T06:08:03.361Z","comments":true,"path":"2022/11/17/开源镜像站建设/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2022/11/17/%E5%BC%80%E6%BA%90%E9%95%9C%E5%83%8F%E7%AB%99%E5%BB%BA%E8%AE%BE/","excerpt":"","text":"1. 背景在单位局域网下的计算机设备由于没有连接到Internet，每次要安装什么软件的时候都很麻烦，需要手动下载安装包再上传，当安装包有众多依赖包的时候，很是麻烦。国内有多家单位都建设了镜像站，为国内开发人员提供了很大便利，但是对于不能访问Internet的局域网服务器来说，还是用不了。那么为何不自己建设一个镜像站呢。 2. 准备工作2.1. 硬件设备 一台局域网中可以连接Internet的计算机 足够大的存储磁盘根据自己要同步的镜像大小选择合适大小的磁盘，镜像大小详情参见：http://mirrors.ustc.edu.cn/status/我有个剩余不足2T空间的磁盘，可以用来作为Centos的镜像站了 2.2. 软件准备 后端准备tunasync是清华大学TUNA镜像源目前使用的镜像方案，github地址：https://github.com/tuna/tunasync 前端准备如果只简单的要个html页面的话， 可以看 https://github.com/weyo/mirrors，它风格类似于163镜像站如果想要些美化以及配置生成工具的话可以参考哈工大镜像前端项目 https://github.com/hitlug/mirror-web，界面样式如下 3. 开始部署1、安装依赖 1yum install rsync wget 2、下载tunasync 1234wget https://github.com/tuna/tunasync/releases/download/v0.3.7/tunasync-linux-bin.tar.gztar xf tunasync-linux-bin.tar.gzmv tunasync /usr/bin/mv tunasynctl /usr/bin/ 3、创建仓库目录 1mkdir -p /data/mirrors 4、创建日志目录 1mkdir -p /data/logs/tunasync 5、创建tunasync配置文件 1mkdir /etc/tunasync 6、创建manager.conf配置文件 1vi /etc/tunasync/manager.conf 12345678910[server]addr = \"127.0.0.1\"port = 12345ssl_cert = \"\"ssl_key = \"\"[files]db_type = \"bolt\"db_file = \"/etc/tunasync/manager.db\"ca_cert = \"\" manager部分参数说明：addr：manager服务监听地址port：manager服务监听端口ssl_cert和ssl_key：证书配置db_file：数据库文件位置 7、创建worker.conf配置文件 1vi /etc/tunasync/worker.conf 1234567891011121314151617181920212223242526272829303132333435[global]name = \"test_worker\"log_dir = \"/data/logs/tunasync/&#123;&#123;.Name&#125;&#125;\"mirror_dir = \"/data/mirrors\"concurrent = 10interval = 240[manager]api_base = \"http://127.0.0.1:12345\"token = \"\"ca_cert = \"\"[cgroup]enable = falsebase_path = \"/sys/fs/cgroup\"group = \"tunasync\"[server]hostname = \"localhost\"listen_addr = \"127.0.0.1\"listen_port = 6000ssl_cert = \"\"ssl_key = \"\"[[mirrors]]name = \"centos\"provider = \"rsync\"upstream = \"rsync://mirrors.tuna.tsinghua.edu.cn/centos/\"use_ipv6 = false[[mirrors]]name = \"epel\"provider = \"rsync\"upstream = \"rsync://mirrors.tuna.tsinghua.edu.cn/epel/\"use_ipv6 = false 注：更多worker.conf配置参见 https://github.com/tuna/tunasync/blob/master/docs/zh_CN/workers.conf worker部分参数说明：log_dir：tunasync日志路径mirror_dir：镜像的路径concurrent：线程数interval：同步周期，单位分钟api_base：manager地址name：镜像名称upstream：upstream同步地址 8、下载tunasync启动停止脚本 1234wget -P /etc/init.d/ https://raw.githubusercontent.com/whsir/tunasync-bin/master/tunasync-managerwget -P /etc/init.d/ https://raw.githubusercontent.com/whsir/tunasync-bin/master/tunasync-workerchmod +x /etc/init.d/tunasync-managerchmod +x /etc/init.d/tunasync-worker 9、启动服务 12/etc/init.d/tunasync-manager start/etc/init.d/tunasync-worker start 10、查看同步状态此处12345为manager的端口 1tunasynctl list -p 12345 --all 11、添加计划任务 1wget -q http://127.0.0.1:12345/jobs -O /data/mirrors/jobs.json jobs.json中记录着当前的镜像列表和状态 12、配置前端web安装nginx采用nginx来实现，docker镜像或yum安装包都可 1）yum安装 1yum install nginx 2）docker 安装 1docker pull nginx:1.23.2 修改配置文件nginx.conf 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091# For more information on configuration, see:# * Official English Documentation: http://nginx.org/en/docs/# * Official Russian Documentation: http://nginx.org/ru/docs/user nginx;worker_processes auto;error_log /var/log/nginx/error.log;pid /run/nginx.pid;# Load dynamic modules. See /usr/share/doc/nginx/README.dynamic.include /usr/share/nginx/modules/*.conf;events &#123; worker_connections 1024;&#125;http &#123; autoindex on; #开启nginx目录浏览功能 autoindex_exact_size off; #文件大小从KB开始显示 autoindex_localtime on; #显示文件修改时间为服务器本地时间 log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' '$status $body_bytes_sent \"$http_referer\" ' '\"$http_user_agent\" \"$http_x_forwarded_for\"'; access_log /var/log/nginx/access.log main; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 4096; include /etc/nginx/mime.types; default_type application/octet-stream; # Load modular configuration files from the /etc/nginx/conf.d directory. # See http://nginx.org/en/docs/ngx_core_module.html#include # for more information. include /etc/nginx/conf.d/*.conf; server &#123; listen 80; listen [::]:80; server_name _; root /data/mirrors/; #Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; &#125; error_page 404 /404.html; location = /404.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125;# Settings for a TLS enabled server.# server &#123; listen 443 ssl http2; listen [::]:443 ssl http2; server_name _a; root /data/mirrors/; ssl_certificate \"/etc/nginx/server.crt\"; ssl_certificate_key \"/etc/nginx/server.key\"; ssl_session_cache shared:SSL:1m; ssl_session_timeout 10m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; # Load configuration files for the default server block. include /etc/nginx/default.d/*.conf; location / &#123; &#125; error_page 404 /404.html; location = /40x.html &#123; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; &#125; &#125;&#125; 配置文件中，我们同时启用了http和https 13、设置前端web下载哈工大开源镜像站前端项目，根据我们的实际情况稍作修改这里的获取镜像列表，而我们再服务器上生成的是名为jobs.json的文件，需要将原来的jobs改为jobs.json，通过读取本地文件来获取jobs信息。 为了从网页看到每个镜像的大小信息，在这里添加一列显示镜像大小 原来的下载链接生成器和配置生成器的数据位于/public/static/下的json文件修改这些json文件，适配实际环境 如果要添加新的镜像说明文档，在docPage目录下，添加md,js文件，并在menu.json中添加 目录结构.├── doc│ ├── …│ ├── js│ │ ├── docHome.js│ │ └── …│ └── markdown│ ├── docHome.md│ └── …├── …└── menu.json 结构说明./doc/markdown: 存放所有 Markdown 文档 ./doc/js: 存放所有 JavaScript 代码 命名规则: 请检查 ./menu.json 文件中对应的 path 项。若 path 为 /doc/MyDoc ，则 js 文件应命名为 MyDoc.js 请在 js 中引入您的 Markdown 文档，方式为: 1import doc from \"../markdown/YourMarkdown.md\"; 调用方式: 1&lt;DocTemplate doc=&#123;doc&#125;/&gt; ./menu.json: 目录文件，存放文档页面左侧的导航栏相关信息 key: 可选，会将提供 key 的项目排序后置顶；若不提供，则按照 title 的字典序显示在下面 title: 将作为导航栏 MenuItem 的标题 name: 镜像名称，应与主页的对应项目和对应的 js 文件名相同，用于在主页添加帮助文档的链接及帮助文档的路由路径 编译运行 1npm run build 上传build目录下内容到服务器的/data/mirrors路径下 启动nginx服务 1） 系统安装启动/etc/init.d/nginx restart 2） docker启动 1docker run --name mirrors-web -p 80:80 -p 443:443 -v /etc/nginx/:/etc/nginx/:ro -v /data/mirrors/:/data/mirrors/ -v /data/sdc1/epel/:/data/sdc1/epel/ -v /var/log/:/var/log/ -d nginx:1.23.2 将/etc/nginx映射到docker的相应目录下，镜像安装位置为/data/mirrors，镜像目录支持软连接指向，所以开源将其他磁盘链接进来增加空间 14、访问测试小工具测试配置文档测试更新系统源修改/etc/yum.repo.d下的CentOS-Base.repo，将域名换成nginx服务所在服务器域名或IP。 15、 配置更新修改worker.conf文件，添加镜像 热重载 worker.conf 12tunasynctl reload -w &lt;worker_id&gt;tunasynctl flush 更新镜像的大小 1tunasynctl set-size -w &lt;worker_id&gt; &lt;mirror_name&gt; &lt;size&gt; 4. 配置网关服务器虽然我搭建了镜像站，但是镜像站的IP是不能被其他集群的计算节点访问的，因为镜像站节点只和其他集群的登陆节点在一个网段，集群 计算节点的IP是集群内的IP，无法访问外部网络。但是集群的计算节点上要安装软件就要用到镜像站，所以需要给登录节点配置成网关服务器，让集群的计算节点以集群的登录节点为网关访问镜像站服务器。 大致的示意图就像这样，拥有外网访问能力的服务器作为网关服务器。 1. 网关服务器配置方法123456789101112131415161718192021# step 1：关闭并永久禁用firewalld服务systemctl stop firewalld systemctl disable firewalld # step 2：安装iptables-servicesyum -y install iptables-services# step 3：开启内核转发vim /etc/sysctl.conf 添加一条：net.ipv4.ip_forward = 1sysctl -p #使之生效 # step 4：配置iptables转发规则iptables -t nat -A POSTROUTING -s 10.10.0.0/16 -j MASQUERADE#step 5：保存iptables规则service iptables save #如果不执行save，重启失效 以上第step 4步骤中： MASQUERADE ：它是用于动态获取IP地址连接的。 也可以静态指定外网IP： 1iptables -t nat -A POSTROUTING -s 10.10.0.0/16 -j SNAT --to 202.117.249.6 2.计算节点配置默认路由将登录节点的集群内IP地址作为计算节点的默认网关地址 1route add default gw 10.10.10.253 路由表结果如下图所示 测试ping集群外IP地址 至此，集群的计算节点就可以配置为自建镜像站的软件源实现yum或apt安装软件了。","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"如何调试真机上的 OS","slug":"如何调试真机上的-OS","date":"2022-11-17T07:50:39.000Z","updated":"2022-11-18T02:21:50.394Z","comments":true,"path":"2022/11/17/如何调试真机上的-OS/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2022/11/17/%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95%E7%9C%9F%E6%9C%BA%E4%B8%8A%E7%9A%84-OS/","excerpt":"","text":"1 技术背景1.1 stub 初探GDB作为 GNU 项目一款知名的调试工具大家应该都不陌生，我们可以通过其很方便地对本地代码进行调试。当我们在本地调试不便的时候，也可以选择在目标机上启动gdbserver，在调试机上运行 GDB 并通过 IP 地址和端口号连接到目标机，从而实现远程调试。 但是 gdbserver 存在其本身的限制：它所需要的操作系统环境基本上与 GDB 所需要的环境是一致的。换句话来说，也就是目标机和调试机都要拥有可以运行 GDB 的操作系统环境。那么如果我们要自己编写一个操作系统并运行在真实的硬件上时，能够采用什么方法来调试呢？ 在这个时候，remote stub技术就派上用场了。我们可以通过一根串口线（例如 RS-232）连接两台主机：一台作为目标机（存放了自己编写的 OS），另一台作为调试机运行 GDB。如何让两台机器通过串口进行通信呢？这需要我们在两端都实现串口的通信协议。stub 就是那个在目标端实现了串口通信协议的文件，我们会将它与自己的 OS 共同编译；而调试端的串口通信协议由 GDB 在remote.c源文件中进行了实现。 1.2 串口略讲上文提及了串口的概念，这里便多说两句。 串口是 IBM-PC 兼容计算机上常见的传统通信端口，但其已被 USB 和其他现代外围设备接口逐渐取代。但操作系统开发人员对串行端口青睐有加，因为它们比 USB 更容易实现驱动程序，并且在许多 x86 系统中仍然很常见。现代串行端口通常实现 RS-232 标准，并且可以使用各种不同的连接器接口。DE-9 接口是现代系统中串行端口最常用的一种连接器。 至于有关串口更详细的概念以及如何调试串口，互联网上有许多不错的资料，本文也就不再赘述了。但在实际操作中，有以下几点要提醒大家注意： RS-232 的串口线包含直连和交叉两种，根据两端设备的不同，我们需要选择不同的串口线。选购的方式可以参考这个回答。因为计算机的内置串口是数据终端（DTE）设备，我在这里选用了交叉线。 简单交叉线 简单直连线 如果要判断串口数据收发是否正常，可以用面包线短接计算机串口的 2、3 引脚，并使用串口调试程序进行判断（Linux 下我用的 cutecom，Windows 下用的 UartAssist）。 正常情况下，Linux 下串口的设备名为ttyS0，Windows 下为COM1。 1.3 RSP 概述在 1.1 节中我们介绍到 stub 需要实现串口的通信协议，而该协议就是 RSP（Remote Serial Protocal）。RSP 是一种简单的，通过串口线、网络等至少支持半双工通信的媒介进行ASCII消息传输的协议。 如果一个目标机的体系结构已经在 GDB 中被定义过，并且该目标机实现了 RSP 协议的服务器端，那么调试器将能够远程连接到该目标。 该协议支持多种连接类型：直接串行设备、UDP/IP、TCP/IP 和 POSIX 管道。该协议是分层的，大致遵循下图的 OSI 模型。 1.3.1 客户端-服务器 关系 GDB 程序作为 RSP 的客户端，目标机作为 RSP 的服务器。客户端发出数据包，这些数据包是对信息或行动的请求。根据客户端数据包的性质，服务器可能会用自己的数据包来回应。 服务器发送数据包的唯一情况就是回复来自客户端的需要相应的数据包。 1.3.2 表示层：数据包传输RSP 包的基本格式如下图所示。 RSP 包以$号作为数据包的开始，后跟一个或多个用于组成要发送的消息的 ASCII 字节，并以#作为数据包的结束。随后，还有两个 16 进制的 ASCII 字符checksum作为要发送的消息的校验和，其具体的计算方式是数据包中所有字符求和再用 256 求余数。 消息的接收方会返回 ‘+’ 表示正确接收数据，检验和有效，或 ‘-‘ 表示没有正确接收数据。当返回 ‘-‘ 时，GDB会将错误码返回给用户，并无条件挂起GDB进程。 1.3.3 应用层：远程串行协议 从客户端到服务器的 RSP 命令是文本字符串，后面可以有参数。每条命令都在自己的数据包中发送。这些数据包可分为四组： 不需要确认的数据包。这些命令是：f、i、I、k、R、t 和 vFlashDone。 需要一个简单的确认包的数据包。这种确认要么是 OK，要么是 Enn（其中 nn 是错误号码），或者对于某些命令返回空包（意味着 “不支持”）。这些命令是：!、A、D、G、H、M、P、Qxxxx、T、vFlashErase、vFlashWrite、X、z 和 Z。 返回结果数据或错误代码的数据包。这些命令是 ：?，c，C，g，m，p，qxxxx，s，S 和 vxxxx。 不应再使用的已弃用数据包。这些命令是：b、B、d 和 r。 数据包命令的详细说明可参考官方文档。部分 GDB 命令的实现如下： 1.3.4 实例 如果要将 0xc320 写入内存 0x4015cc 中，GDB 会调用set 0x4015cc = 0xc320。 其底层的通信为： $M4015CC,2:C320#6d 其中 ‘M’ 命令的格式是 ‘M addr,length:XX…’ 。意为将数据 XX… 写入从地址 addr 开始的 length 个可寻址的内存单元中。 目标机收到数据并验证检验码后正确，会首先返回 + 接着返回状态 $OK#9a 这样，一个通过 GDB 操作内存数据的通信协议就完成了。关于 RSP 协议的更详细的内容，大家可以参考 Howto: GDB Remote Serial Protocol。 2 gdbstub2.1 概览GDB 源码中内置了多种计算机体系结构下适用的 stub，如i386-stub.c、sparc-stub.c等，但无一例外需要二次开发，针对串口的地址进行读写，从而实现收发数据包、实现异常处理等功能。为了简化流程，我们可以使用已开发得较为完善的gdbstub。 gdbstub 依赖于 32 位的 x86 架构。该项目的各个文件中有两个文件起到了核心作用——gdbstub_x86_int.nasm和gdbstub.h。接下来我会以这两个文件为依据，梳理一下 gdbstub 起作用的总体流程。 2.2 处理流程gdbstub 的处理流程非常清晰：生成异常处理函数向量表；获取 OS 的 IDT 并将 IDT 的 1 号和 3 号异常与对应的异常处理函数进行绑定（1 号异常是单步异常，3 号异常是断点异常）；在每一次 1 号和 3 号异常被触发的时候执行对应的异常处理程序。 2.2.1 生成异常处理函数向量表 在gdbstub_x86_int.nasm文件中，我们看到其定义了一个全局变量gdb_x86_int_handlers数组，该数组的每个元素是个 32 位的地址，该地址指向何处？我们接着往下看。 在此，我们发现了数组元素指向的位置。它对应着一段与数组序号对应的代码段。这段代码会将异常号压栈，并跳转到gdb_x86_int_handler_common所在的位置。 可能大家会对上述代码有所疑惑：为什么有的异常处理需要将 0 压栈，有的却不需要呢？这是因为有些异常是拥有错误码的，在这些拥有错误码的异常触发时会自动将错误码压栈。因此，为了使栈中的各元素序列保持一致，我们在处理没有错误码的异常时，需要将 0 压栈，表示什么也不做。 好了，言归正传，现在我们来看看gdb_x86_int_handler_common都做了什么吧。由下图可以看出，这段代码首先是将各个寄存器压栈（作为gdb_x86_int_handler的参数），然后调用了gdb_x86_int_handler函数，最后再将压栈的寄存器弹出，恢复现场，然后返回。 到这里为止，异常处理函数向量表的全貌就展现在我们的眼前了。gdb_x86_int_handlers数组的每一个元素都会指向一个地址，最终调用gdb_x86_int_handler函数，也就是自定义的异常处理函数。至于gdb_x86_int_handler的具体实现逻辑，我会在之后进行说明。 2.2.2 绑定异常处理函数 gdbstub.h中我们将gdb_sys_init()作为 stub 的入口。它将 1 号异常（Debug）和 3 号异常（Breakpoint）与对应的异常处理函数进行绑定，随后调用int3开启 3 号中断，等待调试机上的 GDB 发送数据包并进行相应的处理。 123456789void gdb_sys_init(void)&#123; /* Hook current IDT. */ gdb_x86_hook_idt(1, gdb_x86_int_handlers[1]); gdb_x86_hook_idt(3, gdb_x86_int_handlers[3]); /* Interrupt to start debugging. */ asm volatile (\"int3\");&#125; 在以下代码中，我们可以了解程序是如何将异常号与异常处理函数进行绑定的。 通过sidt指令获取到 IDTR 中的基址，该基址指向中断描述符表 IDT 的地址。 通过中断向量号索引当前中断在 IDT 中的位置，也就是门描述符。 将中断处理程序所在段的段选择子和段内偏移地址、特权级等写入门描述符内对应的位置。 这样一来，就实现了绑定功能。 12345678910111213141516171819202122232425262728293031323334353637383940// Get current IDT.static void gdb_x86_store_idt(struct gdb_idtr *idtr)&#123; asm volatile ( \"sidt %0\" /* Outputs */ : \"=m\" (*idtr) /* Inputs */ : /* None */ /* Clobbers */ : /* None */ );&#125;// Get current code segment (CS register).static uint32_t gdb_x86_get_cs(void)&#123; uint32_t cs; asm volatile ( \"push %%cs;\" \"pop %%eax;\" /* Outputs */ : \"=a\" (cs) /* Inputs */ : /* None */ /* Clobbers */ : /* None */ ); return cs;&#125;// Hook a vector of the current IDT.static void gdb_x86_hook_idt(uint8_t vector, const void *function)&#123; struct gdb_idtr idtr; struct gdb_idt_gate *gates; gdb_x86_store_idt(&amp;idtr); gates = (struct gdb_idt_gate *)idtr.offset; gates[vector].flags = 0x8E00; gates[vector].segment = gdb_x86_get_cs(); gates[vector].offset_low = (((uint32_t)function) ) &amp; 0xffff; gates[vector].offset_high = (((uint32_t)function) &gt;&gt; 16) &amp; 0xffff;&#125; 中断描述符表寄存器 IDTR 为 48 位，其中高 32 位存放着中断描述符表 IDT 的地址。 保护模式下，中断描述符表每个描述符占有 8 字节，该描述符被称为门。门有不同的种类，包括任务门、陷阱门、中断门等等，我们此处用的就是中断门。中断门描述符的格式如下所示。 2.2.3 异常处理函数的实现 好了，终于要窥探中断处理函数的内部细节了。还记得在 2.2.1 节的gdb_x86_int_handler_common中调用的gdb_x86_int_handler()方法吗？它就是异常处理函数的入口，我们可以看到它调用了gdb_x86_interrupt()方法。在该方法中顺序执行了以下步骤： 判断当前是否是 1 号或 3 号中断，如果是，则将 GDB 信号设置为3，即 SIGTRAP；否则设置为 7。 将上下文环境赋给 gdb_state.registers[]。 调用gdb_main()方法。 更新上下文环境。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455void gdb_x86_int_handler(struct gdb_interrupt_state *istate)&#123; gdb_x86_interrupt(istate);&#125;/* * Debug interrupt handler. */static void gdb_x86_interrupt(struct gdb_interrupt_state *istate)&#123; /* Translate vector to signal */ switch (istate-&gt;vector) &#123; case 1: gdb_state.signum = 5; break; case 3: gdb_state.signum = 5; break; default: gdb_state.signum = 7; &#125; /* Load Registers */ gdb_state.registers[GDB_CPU_I386_REG_EAX] = istate-&gt;eax; gdb_state.registers[GDB_CPU_I386_REG_ECX] = istate-&gt;ecx; gdb_state.registers[GDB_CPU_I386_REG_EDX] = istate-&gt;edx; gdb_state.registers[GDB_CPU_I386_REG_EBX] = istate-&gt;ebx; gdb_state.registers[GDB_CPU_I386_REG_ESP] = istate-&gt;esp; gdb_state.registers[GDB_CPU_I386_REG_EBP] = istate-&gt;ebp; gdb_state.registers[GDB_CPU_I386_REG_ESI] = istate-&gt;esi; gdb_state.registers[GDB_CPU_I386_REG_EDI] = istate-&gt;edi; gdb_state.registers[GDB_CPU_I386_REG_PC] = istate-&gt;eip; gdb_state.registers[GDB_CPU_I386_REG_CS] = istate-&gt;cs; gdb_state.registers[GDB_CPU_I386_REG_PS] = istate-&gt;eflags; gdb_state.registers[GDB_CPU_I386_REG_SS] = istate-&gt;ss; gdb_state.registers[GDB_CPU_I386_REG_DS] = istate-&gt;ds; gdb_state.registers[GDB_CPU_I386_REG_ES] = istate-&gt;es; gdb_state.registers[GDB_CPU_I386_REG_FS] = istate-&gt;fs; gdb_state.registers[GDB_CPU_I386_REG_GS] = istate-&gt;gs; gdb_main(&amp;gdb_state); /* Restore Registers */ istate-&gt;eax = gdb_state.registers[GDB_CPU_I386_REG_EAX]; istate-&gt;ecx = gdb_state.registers[GDB_CPU_I386_REG_ECX]; istate-&gt;edx = gdb_state.registers[GDB_CPU_I386_REG_EDX]; istate-&gt;ebx = gdb_state.registers[GDB_CPU_I386_REG_EBX]; istate-&gt;esp = gdb_state.registers[GDB_CPU_I386_REG_ESP]; istate-&gt;ebp = gdb_state.registers[GDB_CPU_I386_REG_EBP]; istate-&gt;esi = gdb_state.registers[GDB_CPU_I386_REG_ESI]; istate-&gt;edi = gdb_state.registers[GDB_CPU_I386_REG_EDI]; istate-&gt;eip = gdb_state.registers[GDB_CPU_I386_REG_PC]; istate-&gt;cs = gdb_state.registers[GDB_CPU_I386_REG_CS]; istate-&gt;eflags = gdb_state.registers[GDB_CPU_I386_REG_PS]; istate-&gt;ss = gdb_state.registers[GDB_CPU_I386_REG_SS]; istate-&gt;ds = gdb_state.registers[GDB_CPU_I386_REG_DS]; istate-&gt;es = gdb_state.registers[GDB_CPU_I386_REG_ES]; istate-&gt;fs = gdb_state.registers[GDB_CPU_I386_REG_FS]; istate-&gt;gs = gdb_state.registers[GDB_CPU_I386_REG_GS];&#125; 我们主要来看gdb_main()方法的实现。该方法就是对串口进行驱动编程，实现 RSP 服务器端的响应。 从宏观上看，该方法的内部是通过一个while()循环在不断地读取从调试机发送来的数据包，并进行解析，根据不同的 RSP 命令执行不同的操作并返回相应的数据包。这一逻辑过程的实现可以抽象成三个部分：从串口收/发数据包、解析/编码数据包以及根据指令进行相应的处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990int gdb_main(struct gdb_state *state)&#123; address addr; char pkt_buf[256]; int status; unsigned int length; unsigned int pkt_len; const char *ptr_next; gdb_send_signal_packet(state, pkt_buf, sizeof(pkt_buf), state-&gt;signum); while (1) &#123; /* Receive the next packet */ status = gdb_recv_packet(state, pkt_buf, sizeof(pkt_buf), &amp;pkt_len); if (status == GDB_EOF) &#123; break; &#125; if (pkt_len == 0) &#123; /* Received empty packet.. */ continue; &#125; ptr_next = pkt_buf; /* * Handle one letter commands */ switch (pkt_buf[0]) &#123; /* * 省略…… */ /* * Read Registers * Command Format: g */ case 'g': /* Encode registers */ status = gdb_enc_hex(pkt_buf, sizeof(pkt_buf), (char *)&amp;(state-&gt;registers), sizeof(state-&gt;registers)); if (status == GDB_EOF) &#123; goto error; &#125; pkt_len = status; gdb_send_packet(state, pkt_buf, pkt_len); break; /* * 省略…… */ /* * Continue * Command Format: c [addr] */ case 'c': gdb_continue(state); return 0; /* * Single-step * Command Format: s [addr] */ case 's': gdb_step(state); return 0; case '?': gdb_send_signal_packet(state, pkt_buf, sizeof(pkt_buf), state-&gt;signum); break; /* * Unsupported Command */ default: gdb_send_packet(state, NULL, 0); &#125; continue; error: gdb_send_error_packet(state, pkt_buf, sizeof(pkt_buf), 0x00); &#125; return 0;&#125; 2.2.3.1 从串口收/发数据包 收/发数据包的处理逻辑非常类似，两者之间是逆过程，因此我们以发送数据包为例，自底向上地了解其实现的具体细节。在开始之前，我梳理了一下发送数据包这一过程的方法调用链，如下所示。 最底层的串口通信方法非常简单，将值写入串口号对应的寄存器即可。关于串口各端口的含义，我会在后文进行介绍。 123456789static void gdb_x86_io_write_8(uint16_t port, uint8_t val)&#123; asm volatile ( \"outb %%al, %%dx;\" /* Outputs */ : /* None */ /* Inputs */ : \"a\" (val), \"d\" (port) /* Clobbers */ : /* None */ );&#125; 其上一层的方法对其做了一层封装，需要判断当前的传输缓冲区是否为空，非空无法传送数据。这里用到了串口编程的知识，详细内容可翻看 2.4 节。 1234567static int gdb_x86_serial_putchar(int ch)&#123; /* Wait for THRE (bit 5) to be high */ while ((gdb_x86_io_read_8(SERIAL_PORT + SERIAL_LSR) &amp; (1&lt;&lt;5)) == 0); gdb_x86_io_write_8(SERIAL_PORT + SERIAL_THR, ch); return ch;&#125; 再上一层没有什么好说的，单纯的调用，应该是为后期支持不同的系统架构抽象出的接口。 int gdb_sys_putchar(struct gdb_state *state, int ch) { return gdb_x86_serial_putchar(ch); } 此处再封装一层，通过对之前方法的重复调用，实现向串口写入一系列字节的目的。 1234567891011121314151617/* * Write a sequence of bytes. * * Returns: * 0 if successful * GDB_EOF if failed to write all bytes */static int gdb_write(struct gdb_state *state, const char *buf, unsigned int len)&#123; while (len--) &#123; if (gdb_sys_putchar(state, *buf++) == GDB_EOF) &#123; return GDB_EOF; &#125; &#125; return 0;&#125; 下面的方法是整个数据包能够发送的核心。还记得 RSP 包的基本格式吗？$&lt;packet-data&gt;#&lt;checksum&gt;，遗忘的朋友可翻看 1.3.2 节的内容。该方法发送的数据包严格遵守该格式：首先发送$字符，接着借助上文的gdb_write()方法发送具体的数据序列（注：该数据序列为 ASCII 码格式，会由上层函数进行保证，下文会提及），最后将#与计算出的检验和共同发送到串口。发送完之后不要忘记从串口中读取一个字符——这是调试机上 GDB 返回的响应。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/* * Transmits a packet of data. * Packets are of the form: $&lt;packet-data&gt;#&lt;checksum&gt; * * Returns: * 0 if the packet was transmitted and acknowledged * 1 if the packet was transmitted but not acknowledged * GDB_EOF otherwise */static int gdb_send_packet(struct gdb_state *state, const char *pkt_data, unsigned int pkt_len)&#123; char buf[3]; char csum; /* Send packet start */ if (gdb_sys_putchar(state, '$') == GDB_EOF) &#123; return GDB_EOF; &#125; /* Send packet data */ if (gdb_write(state, pkt_data, pkt_len) == GDB_EOF) &#123; return GDB_EOF; &#125; /* Send the checksum */ buf[0] = '#'; csum = gdb_checksum(pkt_data, pkt_len); if ((gdb_enc_hex(buf+1, sizeof(buf)-1, &amp;csum, 1) == GDB_EOF) || (gdb_write(state, buf, sizeof(buf)) == GDB_EOF)) &#123; return GDB_EOF; &#125; return gdb_recv_ack(state);&#125;static int gdb_recv_ack(struct gdb_state *state)&#123; int response; /* Wait for packet ack */ switch (response = gdb_sys_getc(state)) &#123; case '+': /* Packet acknowledged */ return 0; case '-': /* Packet negative acknowledged */ return 1; default: /* Bad response! */ GDB_PRINT(\"received bad packet response: 0x%2x\\n\", response); return GDB_EOF; &#125;&#125; 最上层的四个方法都是针对不同的场景，对gdb_send_packet()进行特定封装。我们以 gdb_send_error_packet()为例，它向串口发送一个错误数据包，以 ‘E’ 开头，后面接着具体的数据。上个方法gdb_send_packet()中发送的数据序列需要保证其为 ASCII 格式，就是在此处进行编码的。 12345678910111213141516171819202122/* * Send a error packet (E AA). */static int gdb_send_error_packet(struct gdb_state *state, char *buf, unsigned int buf_len, char error)&#123; unsigned int size; int status; if (buf_len &lt; 4) &#123; /* Buffer too small */ return GDB_EOF; &#125; buf[0] = 'E'; status = gdb_enc_hex(&amp;buf[1], buf_len-1, &amp;error, 1); if (status == GDB_EOF) &#123; return GDB_EOF; &#125; size = 1 + status; return gdb_send_packet(state, buf, size);&#125; 好了，到此为止，我们整个数据包发送的流程就已经理清了。接收数据包的过程非常类似，大家可以自行阅读相关代码并理解。 2.2.3.2 解析/编码数据包 这一部分的代码较为简单，不作详细讲解。我将相关代码整理并贴在下方，大家可自行阅读。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/* * Decode data from its hex-value representation to a buffer. * * Returns: * 0 if successful * GDB_EOF if the buffer is too small */static int gdb_dec_hex(const char *buf, unsigned int buf_len, char *data, unsigned int data_len)&#123; unsigned int pos; int tmp; if (buf_len != data_len*2) &#123; /* Buffer too small */ return GDB_EOF; &#125; for (pos = 0; pos &lt; data_len; pos++) &#123; /* Decode high nibble */ tmp = gdb_get_val(*buf++, 16); if (tmp == GDB_EOF) &#123; /* Buffer contained junk. */ GDB_ASSERT(0); return GDB_EOF; &#125; data[pos] = tmp &lt;&lt; 4; /* Decode low nibble */ tmp = gdb_get_val(*buf++, 16); if (tmp == GDB_EOF) &#123; /* Buffer contained junk. */ GDB_ASSERT(0); return GDB_EOF; &#125; data[pos] |= tmp; &#125; return 0;&#125;/* * Get the corresponding value for a ASCII digit character. * * Supports bases 2-16. */static int gdb_get_val(char digit, int base)&#123; int value; if ((digit &gt;= '0') &amp;&amp; (digit &lt;= '9')) &#123; value = digit-'0'; &#125; else if ((digit &gt;= 'a') &amp;&amp; (digit &lt;= 'f')) &#123; value = digit-'a'+0xa; &#125; else if ((digit &gt;= 'A') &amp;&amp; (digit &lt;= 'F')) &#123; value = digit-'A'+0xa; &#125; else &#123; return GDB_EOF; &#125; return (value &lt; base) ? value : GDB_EOF;&#125;/* * Encode data to its hex-value representation in a buffer. * * Returns: * 0+ number of bytes written to buf * GDB_EOF if the buffer is too small */static int gdb_enc_hex(char *buf, unsigned int buf_len, const char *data, unsigned int data_len)&#123; unsigned int pos; if (buf_len &lt; data_len*2) &#123; /* Buffer too small */ return GDB_EOF; &#125; for (pos = 0; pos &lt; data_len; pos++) &#123; *buf++ = gdb_get_digit((data[pos] &gt;&gt; 4) &amp; 0xf); *buf++ = gdb_get_digit((data[pos] ) &amp; 0xf); &#125; return data_len*2;&#125;/* * Get the corresponding ASCII hex digit character for a value. */static char gdb_get_digit(int val)&#123; if ((val &gt;= 0) &amp;&amp; (val &lt;= 0xf)) &#123; return digits[val]; &#125; else &#123; return GDB_EOF; &#125;&#125;static const char digits[] = \"0123456789abcdef\"; 2.2.3.3 根据指令进行相应的处理对指令的处理过程我们以 ‘g’ 为例。’g’ 指令的作用是读取寄存器的值。我们将寄存器的值存储在state-&gt;registers中，只需要对这些值进行编码，转换成 ASCII 格式并将其封装为数据包发送至串口即可。其余指令的实现大体上都是以 2.2.3.1 节和 2.2.3.2 节为基础，再进行特定的逻辑处理，也就不在此赘述了。 123456789101112131415/* * Read Registers * Command Format: g */case 'g': /* Encode registers */ status = gdb_enc_hex(pkt_buf, sizeof(pkt_buf), (char *)&amp;(state-&gt;registers), sizeof(state-&gt;registers)); if (status == GDB_EOF) &#123; goto error; &#125; pkt_len = status; gdb_send_packet(state, pkt_buf, pkt_len); break; 这里尤其要强调一下 ‘s’ 与 ‘c’ 指令。大家注意，在执行完这两个指令对应的处理过程后，其所在的函数gdb_main()直接返回了，返回到我们上文提及的gdb_x86_interrupt()方法去更新上下文环境；接着返回到gdb_x86_int_handler()，完成了中断处理的整个过程，执行被调试程序的下一条指令。遗忘这一层调用关系的朋友可以重新回看本小节的开头。 123456789101112131415/* * Continue * Command Format: c [addr] */case 'c': gdb_continue(state); return 0;/* * Single-step * Command Format: s [addr] */case 's': gdb_step(state); return 0; 我们接着看看gdb_continue()与gdb_step()究竟做了什么。持续往下跟进，我们可以看到这两个方法都修改了gdb_state.registers[GDB_CPU_I386_REG_PS]第 8 位的值。而gdb_state.registers[GDB_CPU_I386_REG_PS]已经在之前的gdb_x86_interrupt()方法中被赋值为eflags寄存器的值。那么eflags寄存器的第 8 位究竟有什么作用呢？ 1234567891011121314151617181920212223242526272829303132333435/* * Continue program execution at PC. */int gdb_continue(struct gdb_state *state)&#123; gdb_sys_continue(state); return 0;&#125;/* * Step one instruction. */int gdb_step(struct gdb_state *state)&#123; gdb_sys_step(state); return 0;&#125;/* * Continue program execution. */int gdb_sys_continue(struct gdb_state *state)&#123; gdb_state.registers[GDB_CPU_I386_REG_PS] &amp;= ~(1&lt;&lt;8); return 0;&#125;/* * Single step the next instruction. */int gdb_sys_step(struct gdb_state *state)&#123; gdb_state.registers[GDB_CPU_I386_REG_PS] |= 1&lt;&lt;8; return 0;&#125; eflags寄存器第 8 位为 Trap Flag。当该位为 1 时，CPU 执行完一条指令后会产生单步异常（1 号异常），进入异常处理程序后 TF 自动置 0。调试器通过处理这个单步异常实现对程序的中断控制。持续地把 TF 置 1，程序就可以每执行一句中断一次，从而实现调试器的单步跟踪功能。 在上方的代码中可以很明显地看出 ‘s’ 指令将 TF 置 1，为之后的单步调试做准备；而 ‘c’ 指令要不间断地执行被调试程序（遇到 breakpoint 的情况除外），为了不触发单步异常，因此要将 TF 置 0。 2.3 修改 gdbstub对于整个 gdbstub 在 x86 架构上的运作流程，我们已经在上文介绍得很清楚了。但为了其能够更加适配我们自己的系统，还要对它进行微调。 在gdbstub.h文件的开头加上如下定义。这是为了启用 x86 架构，否则默认为模拟的系统结构。 由于我们编写的 mini-os 中已经声明过uint8_t、uint16_t、uint32_t，为了避免重复，我在这里将其注释，并增加了&lt;stdint.h&gt;头文件。 增加串口初始化方法init_serial()，并在gdb_sys_init()中进行调用。 2.4 对串口 IO 端口进行编程2.4.1 端口地址 首先，我们需要确定串口 IO 端口的地址。由于与机器的连接方式以及 BIOS 的配置方式不同，IO 端口的地址也有可能发生改变，但一般来说，各 COM 口对应的 IO 端口地址如下所示。当然，我们也可以在 BIOS 的 Data Area 中查询到该信息。 通讯端口 IO 端口 COM1 0x3F8 COM2 0x2F8 在获得 COM 口的基地址后，我们可以添加一个偏移值以访问其中的数据寄存器。 IO 端口偏移 DLAB的设置 映射到此端口的寄存器 +0 0 数据寄存器。从接收缓冲区读取此寄存器。写入该寄存器会写入发送缓冲区。 +1 0 中断使能寄存器。 +0 1 当 DLAB 设置为 1 时，这是用于设置波特率的除数的最低有效字节。 +1 1 DLAB 设置为 1 时，这是除数的最高有效字节。 +2 - 中断识别和 FIFO 控制寄存器 +3 - 线路控制寄存器。该寄存器的最高有效位是 DLAB。 +4 - MODEM 控制寄存器。 +5 - 线路状态寄存器。 +6 - MODEM 状态寄存器。 +7 - 暂存器。 2.4.2 线路协议 通过电线传输的串行数据可以有许多不同的参数设置。通常情况下，发送设备和接收设备需要向每个串行控制器写入相同的协议参数值，以便通信成功。 一般情况下 8N1（8位，无奇偶性，一个停止位）几乎是默认的。 2.4.2.1 波特率* 串行控制器（UART）有一个内部时钟，以每秒 115200 次的速度运行，还有一个时钟除数，用来控制波特率。这与可编程中断定时器（PIT）使用的系统类型完全相同。 为了设置端口的速度，计算给定波特率所需的除数，并将其编入除数寄存器。例如，除数为 1 会得到115200 波特，除数为 2 会得到 57600 波特，3 会得到 38400 波特，等等。 不要试图使用 0 的除数来获得无限的波特率，这是不可行的。大多数串行控制器将产生一个未指定的和不可预测的波特率（无论如何，无限波特将意味着无限的传输错误，因为它们是成比例的）。 给控制器设置除数的步骤： 设置线路控制寄存器的最有效位。这是DLAB位，允许访问除数寄存器。 将除数值的最小有效字节发送到[PORT + 0]。 将除数值的最有意义的字节发送到 [PORT + 1]。 清除线路控制寄存器的最重要位。 2.4.2.2 数据位 一个字符中的比特数是可变的。当然，位数越少越快，但它们储存的信息越少。如果你只发送 ASCII 文本，你可能只需要 7 位。 通过写入行控制寄存器 [PORT + 3 ]的两个最小有效位来设置这个值。 Bit 1 Bit 0 Character Length (bits) 0 0 5 0 1 6 1 0 7 1 1 8 2.4.2.3 停止位 串行控制器可以被配置为在每个数据字符后发送一些比特。这些可靠的位可以被控制器用来验证发送和接收设备是否处于相位。 如果字符长度具体为 5 位，停止位只能设置为 1 或 1.5。对于其他长度的字符，停止位只能设置为 1 或 2。 要设置停止位的数量，设置线路控制寄存器 PORT + 3] 的第 2 位。 Bit 2 Stop Bits 0 1 1 1.5 / 2 (depending on character length) 2.4.2.4 奇偶校验位 可以使控制器在传输的每个数据字符的末尾增加或期待一个奇偶校验位。有了这个奇偶校验位，如果数据的一个位被干扰颠倒了，就可以提出一个奇偶校验错误。奇偶校验类型可以是 NONE、EVEN、ODD、MARK 或 SPACE。 如果奇偶校验设置为 NONE，将不添加奇偶校验位，也不期望有奇偶校验。如果发射器发送了一个，而接收器却没有预期到，这很可能会导致错误。 如果奇偶校验设置为 MARK 或 SPACE，奇偶校验位将分别被期望总是设置为 1 或 0。 如果奇偶校验被设置为 EVEN 或 ODD，控制器通过将所有数据位和奇偶校验位的值相加来计算奇偶校验的准确性。如果端口被设置为 EVEN 奇偶校验，其结果必须是偶数。如果它被设置为 ODD 奇偶校验，结果必须是奇数。 要设置端口奇偶校验，请设置线路控制寄存器 [PORT + 3] 的第 3、4 和 5 位。 Bit 5 Bit 4 Bit 3 Parity - - 0 NONE 0 0 1 ODD 0 1 1 EVEN 1 0 1 MARK 1 1 1 SPACE 2.4.3 中断使能寄存器 要在中断模式下与串口通信，必须正确设置中断使能寄存器。为了确定哪些中断应该被启用，必须向中断使能寄存器写入一个具有下列位的值（0 = 禁用，1 = 启用）。 Bit Interrupt 0 Data available 1 Transmitter empty 2 Break/error 3 Status change 4-7 Unused 2.4.4 MODEM 控制寄存器 MODEM 控制寄存器是硬件握手寄存器的一半。虽然大多数串行设备不再使用硬件握手，但在所有与16550 兼容的 UARTS 中仍然包括这些线路。这些可以作为一般用途的输出端口，也可以用来实际执行握手。通过写入调制解调器控制寄存器，它将把这些线设置为有效。 Bit Name Meaning 0 Data Terminal Ready (DTR) Controls the Data Terminal Ready Pin 1 Request to Send (RTS) Controls the Request to Send Pin 2 Out 1 Controls a hardware pin (OUT1) which is unused in PC implementations 3 Out 2 Controls a hardware pin (OUT2) which is used to enable the IRQ in PC implementations 4 Loop Provides a local loopback feature for diagnostic testing of the UART 5 0 Unused 6 0 Unused 7 0 Unused 2.4.5 线路状态寄存器 线路状态寄存器对于检查错误和启用轮询非常有用。 Bit Name Meaning 0 Data ready (DR) Set if there is data that can be read 1 Overrun error (OE) Set if there has been data lost 2 Parity error (PE) Set if there was an error in the transmission as detected by parity 3 Framing error (FE) Set if a stop bit was missing 4 Break indicator (BI) Set if there is a break in data input 5 Transmitter holding register empty (THRE) Set if the transmission buffer is empty (i.e. data can be sent) 6 Transmitter empty (TEMT) Set if the transmitter is not doing anything 7 Impending Error Set if there is an error with a word in the input buffer 2.4.6 MODEM 状态寄存器 该寄存器提供来自外围设备的控制线的当前状态。除了这些当前状态信息，MODEM 状态寄存器的四个位提供了变化信息。每当来自 MODEM 的控制输入改变状态时，这些位被设置为逻辑 1。每当 CPU 读取MODEM 状态寄存器时，它们就被重置为逻辑 0。 Bit Name Meaning 0 Delta Clear to Send (DCTS) Indicates that CTS input has changed state since the last time it was read 1 Delta Data Set Ready (DDSR) Indicates that DSR input has changed state since the last time it was read 2 Trailing Edge of Ring Indicator (TERI) Indicates that RI input to the chip has changed from a low to a high state 3 Delta Data Carrier Detect (DDCD) Indicates that DCD input has changed state since the last time it ware read 4 Clear to Send (CTS) Inverted CTS Signal 5 Data Set Ready (DSR) Inverted DSR Signal 6 Ring Indicator (RI) Inverted RI Signal 7 Data Carrier Detect (DCD) Inverted DCD Signal 如果 MCR 的第 4 位（LOOP 位）被设置，上面的 4 位将反映调制解调器控制寄存器中设置的 4 条状态输出线。 2.4.7 实例 以之前提到的串口初始化程序为例，我们来说明如何对串口 IO 端口进行编程。 1234567void init_serial() &#123; gdb_x86_io_write_8(SERIAL_PORT + 1, 0x00); // Disable all interrupts gdb_x86_io_write_8(SERIAL_PORT + 3, 0x80); // Enable DLAB (set baud rate divisor) gdb_x86_io_write_8(SERIAL_PORT + 0, 0x03); // Set divisor to 3 (lo byte) 38400 baud gdb_x86_io_write_8(SERIAL_PORT + 1, 0x00); // (hi byte) gdb_x86_io_write_8(SERIAL_PORT + 3, 0x03); // 8 bits, no parity, one stop bit&#125; 向相对于基地址 0x3F8 偏移量为 1 的中断使能寄存器中写入 0x00，意为关闭所有的串口中断。 向相对于基地址 0x3F8 偏移量为 3 的线路控制寄存器中写入 0x80。线路控制寄存器的最高位为 DLAB(Divisor Latch Access Bit)，即除数锁存存取位，这是为后面设置波特率做准备。 向相对于基地址 0x3F8 偏移量为 0 的寄存器中写入 0x03。当 DLAB 设置为 1 时，这是用于设置波特率的除数的最低有效字节。例如，除数 1 将产生 115200 波特，除数 2 将产生 57600 波特，3 将产生 38400 波特等。 向相对于基地址 0x3F8 偏移量为 1 的寄存器中写入 0x00，意味设置波特率的除数的最高有效字节为 0。 相对于基地址 0x3F8 偏移量为 3 的线路控制寄存器中写入 0x03，意为关闭 DLAB，并设置为无奇偶校验位与 1 位停止位。 对串口的 IO 端口编程就简单介绍到这里，各个端口各个位的具体含义大家可以参考 Serial Port 和 PORTS。 3 编译、运行与测试3.1 编译 在项目中新建一个 gdbstub 文件夹，内含gdbstub_x86_int.nasm和gdbstub.h两个文件。 在 mini-os 的main.c中引入gdbstub.h头文件，并在函数kernel_main()中调用gdb_sys_init()方法。 在os/Makefile文件增加如下的编译命令。 ) 3.2 运行 在调试机上设置波特率。由于之前初始化串口时，我们设置目标机的波特率为 38400，为保证两机通信正常，需要设置同样的波特率。 1sudo stty -F /dev/ttyS0 ispeed 38400 ospeed 38400 cs8 将目标机上编译好的代码文件（mini-os）复制一份放入调试机中，并用如下命令启动 GDB。其中kernel.gdb.bin是带调试符号的可执行文件。 1sudo gdb kernel.gdb.bin 用如下命令连接串口。其中/dev/ttyS0是本机的串口号。 1target remote /dev/ttyS0 经过上述步骤就可以愉快地调试程序啦！ 4 总结由于查阅许多资料，依然没能找到一篇系统地讲解如何调试真机上的 OS 的文章，因此决定将自己这一探索经历分享出来，希望可以帮助到更多的人。 在这次实践中，有过许多次难有进展的时间段，只能不断地查资料、编码、编译、运行、重启电脑、Debug，反反复复，甚至在临睡前、骑车回寝室的路上都会思考接下来的步骤（插入一句，骑车回去的时候头脑最清楚）。这篇文章展现出来的都是成功的尝试，只是总体过程的冰山一角。 但是在这一过程中我也复习了很多之前没怎么注意的细小的知识点，重新回顾了 Makefile 文件的用法、ELF 文件的基本格式、汇编语言，了解了串口编程，加深了对底层的了解，的确是一次很有收获的经历。","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"},{"name":"调试","slug":"调试","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E8%B0%83%E8%AF%95/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"树莓派3——DMA技术访问SD卡的实现与分析","slug":"树莓派3——DMA技术访问SD卡的实现与分析","date":"2022-09-22T12:44:32.000Z","updated":"2022-09-29T11:37:32.408Z","comments":true,"path":"2022/09/22/树莓派3——DMA技术访问SD卡的实现与分析/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2022/09/22/%E6%A0%91%E8%8E%93%E6%B4%BE3%E2%80%94%E2%80%94DMA%E6%8A%80%E6%9C%AF%E8%AE%BF%E9%97%AESD%E5%8D%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/","excerpt":"","text":"概述在SD卡读写和framebuffer拷贝功能上用DMA实现 添加了dma.c和dma.h源码文件，定义了dma接口和实现 在sd.c的sd_readblock和sd_writeblock函数中添加了DMA相关函数调用实现数据传输。 树莓派dma简介概述BCM2835 中的大多数硬件流水线和外设都是总线主控器，使它们能够有效地满足自己的数据需求。这降低了 DMA 控制器对块到块内存传输的要求，并支持一些更简单的外设。此外，DMA 控制器提供只读预取模式，以允许将数据带入 L2 高速缓存以供以后使用。 注意 DMA 控制器直接连接到外围设备。因此，DMA控制器必须设置为使用外设的物理（硬件）地址。 BCM2835 DMA 控制器总共提供 16 个 DMA 通道。每个通道独立于其他通道运行，并在内部仲裁到 3 条系统总线之一。这意味着 DMA 通道可能消耗的带宽量可以通过仲裁器设置来控制。 每个 DMA 通道通过将控制块 (control block) 数据结构从内存加载到内部寄存器来运行。控制块定义所需的 DMA 操作。一旦当前控制块中描述的操作完成，每个控制块都可以指向另一个要加载和执行的控制块。以这种方式，可以构建控制块的链接列表，以便在没有软件干预的情况下执行一系列 DMA 操作。 外设到 DMA 通道的分配是可编程的。DMA 可以处理字节对齐的传输，并通过缓冲和打包未对齐的访问来最小化总线流量。每个 DMA 通道都可以通过顶级电源寄存器完全禁用以节省功耗。 DMA 控制器寄存器DMA 控制器由几个相同的 DMA 通道组成，具体取决于所需的配置。每个单独的 DMA 通道都有一个相同的寄存器映射（尽管 LITE 通道的功能较少，因此寄存器较少）。DMA 通道 0 位于地址 0x7E007000，通道 1 位于 0x7E007100，通道 2 位于 0x7E007200，依此类推。因此相邻的 DMA 通道偏移 0x100。然而，DMA 通道 15 在物理上从其他 DMA 通道中移除，因此具有不同的地址基址 0x7EE05000。 DMA 通道寄存器地址映射每个 DMA 通道都有一个相同的寄存器映射，只是每个通道的基地址不同。地址映射顶部有一个全局启用寄存器，可以禁用每个 DMA 以实现节能。每个通道寄存器集中只有三个寄存器是可直接写的（CS、CONBLK_AD 和 DEBUG）。其他寄存器（TI、SOURCE_AD、DEST_AD、TXFR_LEN、STRIDE 和 NEXTCONBK）从外部存储器中保存的控制块数据结构自动加载。 控制块数据结构控制块 (CB) 的长度为 8 个字（256 位），并且必须从 256 位对齐的地址开始。CB 数据结构在内存中的格式如下图所示。在 DMA 传输开始时，控制块的每个 32 位字会自动加载到相应的 32 位 DMA 控制块寄存器中。这些寄存器的描述也定义了内存中CB数据结构中对应的位位置。 &emsp;&emsp;通过将 CB 结构的地址写入 CONBLK_AD 寄存器然后设置 ACTIVE 位来启动 DMA。 DMA 将从该 reg 的 SCB_ADDR 字段中设置的地址获取 CB，并将其加载到下面描述的只读寄存器中。然后它将根据 CB 中的信息开始 DMA 传输。&emsp;&emsp;当它完成当前的 DMA 传输（长度 =&gt; 0）时，DMA 将使用 NEXTCONBK 寄存器的内容更新 CONBLK_AD 寄存器，从该地址获取一个新的 CB，并再次开始整个过程。&emsp;&emsp;当 DMA 完成 DMA 传输并且 NEXTCONBK 寄存器设置为 0x0000_0000 时，DMA 将停止（并清除 ACTIVE 位）。它将将此值加载到 CONBLK_AD reg 中，然后停止。&emsp;&emsp;大多数控制块寄存器不能直接写入，因为它们是从内存中自动加载的。可以读取它们以提供状态信息，并指示当前 DMA 传输的进度。加载到 NEXTCONBK 寄存器中的值可以被覆盖，以便控制块数据结构的链表可以动态更改。然而，只有在 DMA 暂停时才可以安全地执行此操作。 Register Mapdma寄存器映射到内存上的地址详情见下表：每个channel有一组寄存器，每个通道的寄存器占0x100的内存，channel 0寄存器相对于0x7E007000的偏移是0，channel 1的寄存器相对0x7E007000的偏移是0x100，依次递增 CS寄存器DMA 控制和状态寄存器包含该 DMA 通道的主要控制和状态位。最高位是RESET位，设置为1时初始化DMA第3位是Data request位，指示所选 DREQ（数据请求）信号的状态，即。由传输信息的 PERMAP 字段选择的 DREQ。 1 = 请求数据。这仅在 DMA 启动并且 PERMAP 字段已从 CB 加载后才有效。它将保持有效，指示选定的 DREQ 信号，直到加载新的 CB。如果 PERMAP 设置为零（无节奏传输），则该位将读回为 1。 0 = 无数据请求。第0，1，2位分别是传输启动位和当前control block传输结束位，active位还表示所有的control _block传输结束 TI寄存器保存了DMA 传输信息PERMAP表示外设编号 (1-31)，其就绪信号将用于控制传输速率，其紧急信号将在 DMA AXI 总线上输出。设置为 0 表示连续的无节奏传输。 这三个SRC开头的位，表示了对源数据的设置，SRC_INC表示源地址是否增长，如果为1， 则每次增长，否则不变。 SRC_WITDH表示源数据传输时地址宽度，如果是0则每次32bit，否则128bit SRC_DREQ如果该位是1，PER_MAP 选择的 DREQ 将选通源读取否则DREQ位没有影响 DEST开头的三个位，与SRC含义相同，只是作用于目标数据而已 INTEN表示INT enable，用于允许CS 寄存器的INT位变化 TXFR寄存器DMA 传输长度。这指定要传输的数据量（以字节为单位）。在正常（非 2D）模式下，这指定了要传输的字节数。在 2D 模式下，它被解释为 X 和 Y 长度，并且 DMA 将执行 Y 传输，每个长度为 X 字节，并在传输的每个 X 支路之后将跨度添加到地址上。随着传输的进行，DMA 引擎会更新长度寄存器，因此它将指示剩余要传输的数据。 ENABLE寄存器每个通道的全局使能位，每个比特表示第几个dma channel被允许 外设到 DREQ 的映射如下) 这里是TI寄存器的PERMAP位可选的值，对应SD卡的读写，选择11号外设，也就是EMMC，因为在sd.c中用的是EMMC协议完成的与sd交互 实现dma.hperipherals/dma.h定义control _block数据结构 123456789typedef struct &#123; unsigned int transfer_info; unsigned int src_addr; unsigned int dest_addr; unsigned int transfer_length; unsigned int mode_2d_stride; unsigned int next_block_addr; unsigned int res[2];&#125; dma_control_block; 定义dma通道寄存器组对应的数据结构 12345typedef struct &#123; unsigned int control; unsigned int control_block_addr; dma_control_block block;&#125; dma_channel_regs; DMA通道寄存器组偏移计算，每个通道的寄存器占0x100字节宽度其中KERNEL_MMIO_BASE被定义为 1#define KERNEL_MMIO_BASE 0xFFFFFFFFFF000000 物理地址0x3F000000被映射到线性地址的0xffffffffff000000地址处 enable寄存器和status寄存器的宏定义 dma.h在dma.h中定义了dma通道结构体，和channel类型。dma_channel的channel成员表示通道序号，从0~14.block成员是个指向dma_control_block结构体的指针status成员是当前通道最近一次数据传输的状态 1234567891011#include \"peripherals/dma.h\"#define IO_TO_BUS(x) (void*)((unsigned int)(x) &amp; 0x00ffffff | 0x7e000000)typedef struct &#123; unsigned int channel; dma_control_block *block; int status;&#125; dma_channel;typedef enum &#123; CT_NONE = -1, CT_NORMAL = 0x81&#125; dma_channel_type; 暴露的dma功能函数接口，打开一个channel，关闭一个channel，dma实现内存拷贝，dma传输启动, dma等待 12345dma_channel *dma_open_channel(unsigned int channel);void dma_close_channel(dma_channel *channel);void dma_setup_mem_copy(dma_channel *channel, void *dest, void *src, unsigned int length, unsigned int burst_length);void dma_start(dma_channel *channel);int dma_wait(dma_channel *channel); dma.c定义控制块变量，分别用于framebuffer和sd卡读写；定义通道数组 dma_open_channel函数，从dma_channel结构体数组选出参数channel对应的channel，并让结构体的block指针指向对应的控制块变量。sd卡用0号channel，framebuffer使用2号channel。通过REGS_DMA_ENABLE 指向的enable寄存器的值的变化，使能对应的dma_channel设备。通过REGS_DMA(dma-&gt;channel)-&gt;control 指向的CS寄存器让对应的dma channel完成重置。语句REGS_DMA(dma-&gt;channel)-&gt;control &amp; CS_RESET 检查CS寄存器的RESET位，直至不为1表示reset过程完成。返回对应的dma_channel结构体指针。 1234567891011121314151617181920212223242526272829dma_channel *dma_open_channel(unsigned int channel)&#123; unsigned int _channel = allocate_channel(channel); if (_channel == CT_NONE) &#123; lfb_color_printf(0x0000ff, \"INVALID CHANNEL! %d\\n\", channel); return 0; &#125; dma_channel *dma = (dma_channel *)&amp;channels[_channel]; dma-&gt;channel = _channel; if(channel == 0) dma-&gt;block = &amp;sd_control_block; else if(channel == 2) dma-&gt;block = &amp;lfb_control_block; dma-&gt;block-&gt;res[0] = 0; dma-&gt;block-&gt;res[1] = 0; REGS_DMA_ENABLE |= (1 &lt;&lt; dma-&gt;channel); delay(300); REGS_DMA(dma-&gt;channel)-&gt;control |= CS_RESET; while (REGS_DMA(dma-&gt;channel)-&gt;control &amp; CS_RESET) ; return dma;&#125; dma_start启动dma数据传输，首先设置控制块的地址，需要将线性地址转换为物理地址。使用ACTIVE位启动数据传输，END让当前控制块的dma传输结束时中断，INT允许中断， dma_wait函数，判断当前dma通道的CS寄存器的active位是否为1，当所有的控制块表示的dma传输完成时，CS寄存器的active位变为0读取CS寄存器的error位，作为本地dma传输的status状态返回 dma_setup_mem_copy的实现在dma.c中这里与sd卡读写的dma设置有所不同，其源地址和目的地址在数据传输过程中都是要递增的，所以要给transfer_info设置TI_SRC_WIDTH，TI_SRC_INC，TI_DEST_WITDH，TI_DEST_INC属性 sd.c在sd_init函数的最后使用dma_open_channel打开0号通道，完成初始化。 在sd_readblock函数中发送读取命令后，如果不使用DMA，那么就用循环的方法从EMMC_DATA处读取数据到buf中。如果使用DMA的话，设置DMA的源地址和目的地址，使用TI_SRC_DREQ表示从外围设备获取数据，TI_DEST_INC, TI_DEST_WITDH表示目的地址递增，TI_PERMAP_EMMC表示外围设备类型是EMMC。完成控制块的构造后，调用dma_start启动dma数据传输，调用dma_wait等待dma数据传输完成。如果不用dma，则需要判断emmc的命令是否执行完成 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657while( c &lt; num ) &#123; if(!(sd_scr[0] &amp; SCR_SUPP_CCS)) &#123; sd_cmd(CMD_READ_SINGLE,(lba+c)*512); if(sd_err) return 0; &#125; if (!use_dma) &#123; if ((r = sd_int(INT_READ_RDY))) &#123; uart_puts(\"\\rERROR: Timeout waiting for ready to read\\n\"); sd_err = r; return 0; &#125; for (d = 0; d &lt; 128; d++) buf[d] = *EMMC_DATA; buf += 128; &#125; c++; &#125; if(use_dma) &#123; dma_sd_channel-&gt;block-&gt;src_addr = IO_TO_BUS(EMMC_DATA); dma_sd_channel-&gt;block-&gt;dest_addr = K_LIN2PHY(buf); dma_sd_channel-&gt;block-&gt;transfer_info = TI_INTEN | TI_WAIT_RESP | TI_DEST_INC | TI_DEST_WIDTH | TI_SRC_DREQ | TI_PERMAP_EMMC; dma_sd_channel-&gt;block-&gt;next_block_addr = 0; dma_sd_channel-&gt;block-&gt;transfer_length = num*512; dma_sd_channel-&gt;block-&gt;mode_2d_stride = 0; dma_start(dma_sd_channel); if(dma_wait(dma_sd_channel) == 0) &#123; uart_puts(\"ERROR in dma read\\n\"); while (1) &#123; /* code */ &#125; &#125; &#125; if (!use_dma) &#123; if ((r = sd_int(INT_DATA_DONE))) &#123; uart_puts(\"\\rERROR: Timeout waiting for data done\\n\"); sd_err = r; return 0; &#125; &#125;&#125; 对于sd_writeblock函数，只需要将目的地址和源地址交换，在transfer_info中设置TI_DEST_DREQ，TI_SRC_INC,TI_SRC_WITDH, TI_PERMAP_EMMC表示是从内存到外设。","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"树莓派","slug":"树莓派","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"EMMC","slug":"EMMC","permalink":"https://xiao_feng_yang993.gitee.io/tags/EMMC/"},{"name":"DMA","slug":"DMA","permalink":"https://xiao_feng_yang993.gitee.io/tags/DMA/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"树莓派3——EMMC访问SD卡的实现与分析","slug":"树莓派3——EMMC访问SD卡的实现与分析","date":"2022-05-24T15:54:21.000Z","updated":"2022-09-29T11:37:32.408Z","comments":true,"path":"2022/05/24/树莓派3——EMMC访问SD卡的实现与分析/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2022/05/24/%E6%A0%91%E8%8E%93%E6%B4%BE3%E2%80%94%E2%80%94EMMC%E8%AE%BF%E9%97%AESD%E5%8D%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%88%86%E6%9E%90/","excerpt":"","text":"相关知识The External Mass Media Controller（EMMC)是 Arasan™ 提供的嵌入式 MultiMedia™ 和 SD™ 卡接口。 卡的接口使用它自己的时钟 clk_emmc，它由时钟管理器模块提供。该时钟的频率应在 50 MHz 和 100 MHz 之间选择。即使 VideoCore 以降低的时钟频率运行，拥有单独的时钟也可以对卡进行高性能访问。 EMMC 模块包含自己的内部时钟分频器，用于从 clk_emmc 生成卡的时钟。此外，来自卡的响应和数据的采样时钟最多可以延迟 40 步，可配置的延迟通常在每步 200 ps 到 1100 ps 之间。延迟是为了取消读取时卡内部的内部延迟（最长 14ns）。每步的延迟将随温度和电源电压而变化。因此，最好使用比必要更大的延迟，因为最大延迟没有限制。EMMC 模块自动处理命令和数据线上的握手过程以及所有 CRC 处理。在将任何所需的参数加载到 ARG1 寄存器后，通过将命令和适当的标志写入 CMDTM 寄存器来开始命令执行。 EMMC 模块计算 CRC 校验和，将命令传送到卡，接收响应并检查其 CRC。一旦命令已执行或超时，寄存器 INTERRUPT 的位 0 将被设置。请注意，中断寄存器不是自清零的，因此软件必须先通过写入 1 来复位它，然后才能使用它来检测命令是否完成。该软件负责检查卡响应的状态位，以验证卡是否成功处理。为了从/向卡寄存器传输数据，在配置主机并使用 CMDTM寄存器向卡发送相应的命令后访问数据。因为 EMMC 模块不解释发送到卡的命令，所以将其配置为与使用 CONTROL0 寄存器的卡设置相同是很重要的。应特别注意确保主机和卡的数据总线宽度配置相同。通过适当地关闭其时钟，卡与数据流同步。握手信号 dma_req 可用于有节奏的数据传输。 INTERRUPT 寄存器的位 1 可用于确定数据传输是否完成。请注意，中断寄存器不是自清零的，所以软件在使用它来检测数据传输是否完成之前，必须首先通过写入 1 来复位它。EMMC 模块将最大块大小限制为内部数据 FIFO 的大小，即 1k 字节。为了获得数据传输的最大性能，有必要使用多块数据传输。在这种情况下，EMMC 模块在乒乓模式下使用两个 FIFO，即一个用于向/从卡传输数据，而另一个则由 DMA 通过 AXI 总线同时访问。如果 EMMC 模块配置为单块传输，则仅使用一个 FIFO，因此在向卡传输数据或从卡传输数据时无法进行 DMA 访问，反之亦然，从而导致较长的死区时间。＃ EMMCEMMC 模块寄存器只能作为 32 位寄存器访问树莓派3EMMC寄存器基地址为0x7E300000树莓派4EMMC寄存器基地址为0x7E300000此处在总线地址 0x7Ennnnnn 相当于在物理地址0x3Fnnnnnn可用EMMC相关寄存器及其地址如下表所示：在这些寄存器里，经常被使用（指的是读写数据情景）的是ARG1，CMDTM，DATA，INTERRUPT这四个寄存器。其他寄存器在EMMC initialization阶段使用过后一般不再涉及。 读写数据场景寄存器介绍 ARG1 RegisterThis register contains the arguments for all commands except for the SD card specific command ACMD23 which uses ARG2. ARG1 must be set before the command is issued using the CMDTM register.ARG1寄存器是负责保存参数的，用于和EMMC模块进行命令式的通信时使用 CMDTM Register该寄存器用于向卡发出命令。除了命令之外，它还包含标志，通知 EMMC 模块什么卡响应和期望的数据传输类型。不正确的标志会导致错误的行为 对于数据传输，支持两种模式：传输单个数据块或多个相同大小的块。 SD 卡使用两组不同的命令来区分它们，但需要使用 TM_MULTI_BLOCK 额外配置主机。重要的是，对于发送到卡的命令，该位设置正确，即 CMD18 和 CMD25 为 1，CMD17 和 CMD24 为 0。多块传输提供了更好的性能。 BLKSIZECNT 寄存器用于配置要传输的块的大小和数量。如果该寄存器的 TM_BLKCNT_EN 位置位，则在传输了 BLKSIZECNT 寄存器中配置的数据块数量后传输自动停止。 TM_AUTO_CMD_EN 位可用于使主机在 BLKSIZECNT 寄存器中的 BLKCNT 位为 0 时自动向卡发送命令，告知其数据传输已完成。 CMDTM寄存器具体每个bit的含义见下表 3. DATA Register该寄存器用于向/从卡传输数据。 INTERRUPT 寄存器的位 1 可用于检查数据是否可用。对于paced DMA 传输，可以使用高电平有效信号 dma_req。4. INTERRUPT Register该寄存器保存中断标志。可以使用 IRPT_MASK 寄存器中的相应位禁用每个标志。 其中与读写数据场景相关的bit见下表 READ_RDY位于interrupt 寄存器的第5 bit，值为1表示已经准备好要被读取来自SD卡的数据，一般用在读请求返回数据时WRITE_RDY位于interrupt 寄存器的第4bit，值为1表示已经准备好接收要被写入SD卡的数据，一般用在写请求写入数据时 DATA_DONE 位于interrupt 寄存器第1 bit，值为1表示数据传输完成 工作流程1234#define CMD_READ_SINGLE 0x11220010#define CMD_READ_MULTI 0x12220032#define CMD_WRITE_SINGLE 0x18220000#define CMD_WRITE_MULTI 0x19220022 CMD命令指令值宏定义，更多CMD格式见EMMC_JESD84-A441.pdf的7.10章节在一些项目中，宏定义命名为CMDn，这里用的命名是Abbreviation名称 READ（代码只是基本流程，并非实际编码实现） 发送读命令，传入lba参数1sd_cmd(CMD_READ_SINGLE, lba); sd_cmd的实现如下12*EMMC_ARG1 = lba;*EMMC_CMDTM = CMD_READ_SINGLE; sd_cmd运行后等待结果1234567891011121314151617181920while(times &lt; timeout) &#123; u32 reg = *EMMC_INTERRUPT; if (reg &amp; 0x8001) &#123; //CMD_DONE break; &#125; timer_sleep(1); times++;&#125;while(times &lt; timeout) &#123; u32 reg = *EMMC_INTERRUPT; if (reg &amp; 0x8020) &#123; //READ_RDY break; &#125; timer_sleep(1); times++;&#125;long buffer[128];for (d = 0; d &lt; 128; d++) buffer[d] = *EMMC_DATA; 检查interrupt 寄存器的CMD_DONE 所在bit是否为1，如果是0说明命令未完成继续等待直到CMD_DONE bit值为1检查interrupt 寄存器的READ_RDY 所在bit是否为1，如果是0说明数据没ready继续等待直到READ_ RDY bit值为1READ_RDY满足条件后，从EMMC的DATA寄存器中读一个block的数据到缓冲区数组buffer中。 如果要修改block大小，可以通过CMD16来实现，sd_cmd(CMD16, BlockSizeInBytes) WRITE（代码只是基本流程，并非实际编码实现） 发送读命令，传入lba参数1sd_cmd(CMD_WRITE_SINGLE, lba); sd_cmd的实现如下12*EMMC_ARG1 = lba;*EMMC_CMDTM = CMD_WRITE_SINGLE; sd_cmd运行后等待结果1234567891011121314151617181920while(times &lt; timeout) &#123; u32 reg = *EMMC_INTERRUPT; if (reg &amp; 0x8001) &#123; //CMD_DONE break; &#125; timer_sleep(1); times++;&#125;while(times &lt; timeout) &#123; u32 reg = *EMMC_INTERRUPT; if (reg &amp; 0x8010) &#123; //WRITE_RDY break; &#125; timer_sleep(1); times++;&#125;long buffer[128];for (d = 0; d &lt; 128; d++) *EMMC_DATA = buf[d]; 检查interrupt 寄存器的CMD_DONE 所在bit是否为1，如果是0说明命令未完成继续等待直到CMD_DONE bit值为1检查interrupt 寄存器的READ_RDY 所在bit是否为1，如果是0说明数据没ready继续等待直到WRITE_ RDY bit值为1WRITE_RDY满足条件后，从到缓冲区数组buffer向EMMC的DATA寄存器中写一个block的数据。 EMMC初始化场景寄存器介绍EMMC寄存器 CONTROL0 Register该寄存器用于配置 EMMC 模块。 CONTROL1 Register该寄存器用于配置 EMMC 模块。CLK_STABLE 似乎与其名称相反，只是表示 clk_emmc 输入上有一个上升沿，但并不表示该时钟的频率实际上是稳定的。其中的SRST_DATA，SRST_CMD，SRST_HC是Reset设备的控制bit，在一开始就要被处理CLK_XXX是时钟相关的Field IRPT_MASK Register该寄存器用于屏蔽 INTERRUPT 寄存器中的中断标志。 IRPT_EN Register该寄存器用于启用 INTERRUPT 寄存器中的不同中断，以在 int_to_arm 输出上产生中断。 STATUS Register该寄存器包含用于调试的信息。它的值会根据硬件自动改变。由于它涉及不同时钟域之间的重新同步，它仅在一些延迟后才会改变，并且很容易过早地对值进行采样。因此不推荐使用该寄存器进行轮询。取而代之的是使用实现握手机制的INTERRUPT Register，这使得轮询时不可能错过更改。 INTERRUPT Register该寄存器保存中断标志。可以使用 IRPT_MASK 寄存器中的相应位禁用每个标志 SLOTISR_VER Register该寄存器包含版本信息和插槽中断状态。 BLKSIZECNT Register它包含要传输的数据块的数量和大小（以字节为单位）。请注意，EMMC 模块将最大块大小限制为内部数据 FIFO 的大小，即 1k 字节。BLKCNT 用于告诉主机要传输多少数据块。一旦数据传输开始并且 CMDTM 寄存器中的 TM_BLKCNT_EN 位置位，EMMC 模块会随着数据块的传输自动减小 BNTCNT 值，并在 BLKCNT 达到 0 时停止传输。当卡和主机之间的任何数据传输正在进行时，不得访问或修改此寄存器。 GPIO 寄存器GPIO High Detect Enable Registers (GPHENn)高电平检测使能寄存器定义在事件检测状态寄存器 (GPEDSn) 中设置高电平位的引脚。如果尝试清除 GPEDSn 中的状态位时引脚仍然为高电平，则状态位将保持设置状态。 GPIO Function Select Registers (GPFSELn)功能选择寄存器用于定义通用 I/O 引脚的操作。 54 个 GPIO 引脚中的每一个都至少具有第 16.2 节中定义的两个替代功能。 FSEL{n} 字段确定第 n 个 GPIO 引脚的功能。所有未使用的替代功能线都接地，如果选择，将输出“0”。所有引脚复位为正常 GPIO 输入操作。 GPIO Event Detect Status Registers (GPEDSn)事件检测状态寄存器用于记录 GPIO 引脚上的电平和边沿事件。事件检测状态寄存器中的相关位在以下情况下设置： 1) 检测到与上升/下降沿检测启用寄存器中编程的边沿类型相匹配的边沿，或 2) 检测到与编程电平类型相匹配的电平在高/低电平检测使能寄存器。通过向相关位写入“1”来清除该位。可以对中断控制器进行编程，以在设置任何状态位时中断处理器。 GPIO 外设具有三个专用中断线。每个 GPIO bank 可以产生一个独立的中断。每当设置任何位时，第三行都会生成一个中断。 GPIO Pull-up/down Register (GPPUD)GPIO 上拉/下拉寄存器控制内部上拉/下拉控制线对所有 GPIO 引脚的驱动。该寄存器必须与 2 个 GPPUDCLKn 寄存器一起使用。请注意，无法回读当前的上拉/下拉设置，因此用户有责任“记住”哪些上拉/下拉处于活动状态。这样做的原因是，即使在掉电模式下，当内核关闭时，GPIO 上拉也保持不变，此时备用功能表也具有掉电后应用的上拉状态。 GPIO Pull-up/down Clock Registers (GPPUDCLKn)GPIO 上拉/下拉时钟寄存器控制相应 GPIO 引脚上内部下拉的驱动。这些寄存器必须与 GPPUD 寄存器一起使用，以实现 GPIO 上拉/下拉更改。需要以下事件序列： 写入 GPPUD 以设置所需的控制信号（即上拉或下拉或都不删除当前的上拉/下拉） 等待 150 个周期——这提供了所需的控制信号的建立时间 写入 GPPUDCLK0/1 以将控制信号时钟输入您希望修改的 GPIO 焊盘 – 注意只有接收时钟的焊盘将被修改，所有其他焊盘将保持其先前状态。 等待 150 个周期——这为控制信号提供了所需的保持时间 写入 GPPUD 以移除控制信号 写入 GPPUDCLK0/1 以移除时钟 SD卡接口寄存器在卡接口内定义了六个寄存器：OCR、CID、CSD、EXT_CSD、RCA 和 DSR。这些只能通过相应的命令访问（参见EMMC_JESD84-A441.pdf第85 页的第 7.10 节）。 OCR、CID 和 CSD 寄存器携带卡/内容特定信息，而 RCA 和 DSR 寄存器是存储实际配置参数的配置寄存器。 EXT_CSD 寄存器携带卡特定信息和实际配置参数。 OCR register32 位操作条件寄存器 (OCR) 存储卡的 VDD 电压曲线和访问模式指示。此外，该寄存器包含一个状态信息位。如果卡上电过程已完成，则设置此状态位。 OCR寄存器应由所有卡实现。 CID register卡识别 (CID) 寄存器为 128 位宽。它包含在卡识别阶段（MultiMediaCard 协议）使用的卡识别信息。每个单独的闪存或 I/O 卡都应具有唯一的标识号。每种类型的 MultiMediaCard ROM 卡（由内容定义）都应具有唯一的标识号。第 114 页的表 42 列出了这些标识符。 CSD register卡特定数据 (CSD) 寄存器提供有关如何访问卡内容的信息。 CSD 定义了数据格式、纠错类型、最大数据访问时间、数据传输速度、是否可以使用 DSR 寄存器等。寄存器的可编程部分（由 W 或 E 标记的条目，见下文）可以通过以下方式更改CMD27。 Extended CSD register扩展 CSD 寄存器定义卡属性和选择的模式。它有 512 个字节长。最重要的 320 字节是 Properties 段，它定义了卡的功能并且不能被主机修改。低 192 字节是 Modes 段，它定义了卡的工作配置。主机可以通过 SWITCH 命令更改这些模式。 RCA register可写的 16 位相对卡地址（RCA）寄存器携带主机在识别卡时分配的卡地址。该地址用于在卡识别过程之后寻址的主机卡通信。 RCA 寄存器的默认值为 0x0001。保留值 0x0000 以使用 CMD7 将所有卡设置为待机状态。 DSR register16 位驱动级寄存器 (DSR) 在第 169 页的第 12.4 节中进行了详细描述。它可以选择性地用于提高扩展操作条件下的总线性能（取决于总线长度、传输速率或牌）。 CSD 寄存器携带有关 DSR 寄存器使用情况的信息。 DSR寄存器的默认值为0x404 工作流程GPIO引脚初始化结合BCM2837说明文档，每条指令的含义标注在代码注释中 1234567891011121314151617181920212223242526272829303132333435363738long r, cnt, ccs = 0;// GPIO_CDr = *GPFSEL4; // GPIO Alternate function select register 4r &amp;= ~(7 &lt;&lt; (7 * 3)); //FSEL47 GPIO Pin 47 takes alternate function 3*GPFSEL4 = r;*GPPUD = 2; //enable pull up controlwait_cycles(150);*GPPUDCLK1 = (1 &lt;&lt; 15); //assert clock on line 47wait_cycles(150);*GPPUD = 0; //OFF disable pull down/up*GPPUDCLK1 = 0; //No Effectr = *GPHEN1;r |= 1 &lt;&lt; 15;*GPHEN1 = r; //High on GPIO pin 47 sets corresponding bit in GPEDS// GPIO_CLK, GPIO_CMDr = *GPFSEL4; // GPIO Alternate function select register 4r |= (7 &lt;&lt; (8 * 3)) | (7 &lt;&lt; (9 * 3)); //GPIO Pin 48,49 takes alternate function 3*GPFSEL4 = r;*GPPUD = 2; //enable pull up controlwait_cycles(150);*GPPUDCLK1 = (1 &lt;&lt; 16) | (1 &lt;&lt; 17); //assert clock on line 48,49wait_cycles(150);*GPPUD = 0; //OFF disable pull down/up*GPPUDCLK1 = 0; //No Effect// GPIO_DAT0, GPIO_DAT1, GPIO_DAT2, GPIO_DAT3r = *GPFSEL5; // GPIO Alternate function select register 5r |= (7 &lt;&lt; (0 * 3)) | (7 &lt;&lt; (1 * 3)) | (7 &lt;&lt; (2 * 3)) | (7 &lt;&lt; (3 * 3));// GPIO Pin 50,51,52,53 takes alternate function 3*GPFSEL5 = r;*GPPUD = 2; //enable pull up controlwait_cycles(150);*GPPUDCLK1 = (1 &lt;&lt; 18) | (1 &lt;&lt; 19) | (1 &lt;&lt; 20) | (1 &lt;&lt; 21); //assert clock on line 50,51,52,53wait_cycles(150);*GPPUD = 0; //OFF disable pull down/up*GPPUDCLK1 = 0; //No Effectuart_puts(\"EMMC: GPIO set up\\n\"); 这段代码的含义是，将GPIO4753 引脚全部 pull Up；目的是将GPIO47 引脚设置为GPIO_CD；将GPIO48，49引分别设置为CLK和CMD，GPIO5053做dat0~3四路数据line EMMC初始化1sd_hv = (*EMMC_SLOTISR_VER &amp; HOST_SPEC_NUM) &gt;&gt; HOST_SPEC_NUM_SHIFT; 读取Host Controller specification version信息 12345678910111213/ Reset the card.*EMMC_CONTROL0 = 0;*EMMC_CONTROL1 |= C1_SRST_HC;cnt = 10000;do&#123; wait_msec(10);&#125; while ((*EMMC_CONTROL1 &amp; C1_SRST_HC) &amp;&amp; cnt--);if (cnt &lt;= 0)&#123; uart_puts(\"ERROR: failed to reset EMMC\\n\"); return SD_ERROR;&#125; 通过control0寄存器来reset complete host circuit，reset成功后SRST_HC bit将变成0 12345//This enabled VDD1 bus power for SD card, needed for RPI 4. #ifdef RPI_VERSION == 4 *EMMC_CONTROL1 |= 0x0F &lt;&lt; 8; wait_msec(10); #endif 如果是树莓派4，则需要给control1的第8~11 bit设置为1，来enable VDD1 bus power for SD card 12*EMMC_CONTROL1 |= C1_CLK_INTLEN | C1_TOUNIT_MAX;wait_msec(10); 设置了Data timeout unit exponent:和Clock enable for internal EMMC clocks for power saving 123456// Set clock to setup frequency. if ((r = sd_clk(400000))) return r;//允许所有中断产生，设置中断掩码，作用于interrupt 寄存器 *EMMC_INT_EN = 0xffffffff; *EMMC_INT_MASK = 0xffffffff; 设置了时钟频率，开启了中断和masksd_clk的实现如下 123456789101112131415161718192021222324252627282930*EMMC_CONTROL1 &amp;= ~C1_CLK_EN; //disable clk wait_msec(10);/***************************/计算频率/***************************/if (sd_hv &gt; HOST_SPEC_V2) //判断是否是sdhc卡，也就是二代SD卡 d = c;else d = (1 &lt;&lt; s);if (d &lt;= 2)&#123; d = 2; s = 0;&#125;uart_puts(\"sd_clk divisor \");uart_hex(d);uart_puts(\", shift \");uart_hex(s);if (sd_hv &gt; HOST_SPEC_V2) h = (d &amp; 0x300) &gt;&gt; 2;d = (((d &amp; 0x0ff) &lt;&lt; 8) | h);*EMMC_CONTROL1 = (*EMMC_CONTROL1 &amp; 0xffff003f) | d; //设置时钟频率wait_msec(10);*EMMC_CONTROL1 |= C1_CLK_EN; //enable clkwait_msec(10);cnt = 10000;while (!(*EMMC_CONTROL1 &amp; C1_CLK_STABLE) &amp;&amp; cnt--) //判断是否生效 wait_msec(10); sd_clk到此结束 1sd_cmd(CMD_GO_IDLE, 0); Resets the card to idle statesd_cmd的实现与之前在读写数据场景章节中的类似，通过的是CMDTM传命令和ARG传参数实现。 1sd_cmd(CMD_SEND_IF_COND, 0x000001AA); //The card sends its EXT_CSD register as a block of data. CMD8 用读data的方式获取EXT_CSD寄存器的内容，从接⼝状态命令判断是否⽀持SD V2.0 1r = sd_cmd(CMD_SEND_OP_COND, ACMD41_ARG_HC); //Asks the card, in idle state, to send its Operating Conditions Register(OCR register) contents in the response on the CMD line. 用CMD response 的方式让sd卡发送OCR寄存器的数据。SD_SEND_OP_COND (ACMD41)命令来识别或者拒绝不匹配host主机供电电压范围的卡。如果SD卡在主机规定的电压范围内不能实现数据传输，卡将放弃下一步的总线操作而进入不活动状态(Inactive State)。 1sd_cmd(CMD_ALL_SEND_CID, 0); 让SD卡发送它的CID寄存器的值到CMD line 上，在卡发送它的CID之后，卡进入识别状态（Identification State）。 1sd_rca = sd_cmd(CMD_SEND_REL_ADDR, 0); 获取 card的地址，RCA是一个比CID短的，并且将来在数据传输模式中使用的地址。 1sd_cmd(CMD_CARD_SELECT, sd_rca); 选择根据 sd_cra来选择card，并且将卡带入传输状态(Transfer State)。在同一个时间内，只有一张卡能进入传输状态。当发送的CMD7的RCA地址参数为”0x0000”，所有卡将跳回到准备状态（Stand-by State ）。 123456789*EMMC_BLKSIZECNT = (1 &lt;&lt; 16) | 8;sd_cmd(CMD_SEND_SCR, 0); //SD Configuration Registerif (sd_int(INT_READ_RDY)) return SD_TIMEOUT;while (r &lt; 2 &amp;&amp; cnt)&#123;if (*EMMC_STATUS &amp; SR_READ_AVAILABLE) sd_scr[r++] = *EMMC_DATA; //SD Configuration Register&#125; 读取SCR寄存器到sd_scr数组中，可以得到设备的版本信息，支持的bus width等。用于进一步可选的配置。SCR 寄存器：SCR（SD 配置）寄存器总共 64 bits，定义了卡片的一些特殊功能；该寄存器由厂商编程，主机不能对它进行编程 至此 EMMC初始化完成","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"},{"name":"树莓派","slug":"树莓派","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"EMMC","slug":"EMMC","permalink":"https://xiao_feng_yang993.gitee.io/tags/EMMC/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"vscode图形界面在qemu上调试裸机程序","slug":"vscode图形界面在qemu上调试裸机程序","date":"2022-02-23T15:14:44.000Z","updated":"2022-09-29T11:37:32.407Z","comments":true,"path":"2022/02/23/vscode图形界面在qemu上调试裸机程序/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2022/02/23/vscode%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%E5%9C%A8qemu%E4%B8%8A%E8%B0%83%E8%AF%95%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F/","excerpt":"","text":"1. 准备工作1）从扩展安装ms-vscode.cpptools插件2）配置文件launch.json&emsp;&emsp;从顶层目录打开miniOS项目，编辑debug配置文件launch.json，点击debug，创建launch.json文件，输入以下内容，重点在miDebuggerServerAddress设置为qemu对外暴露的调试端口IP填写qemu虚拟机所在的主机IP。program填写调试目标文件路径，绝对路径或相对路径都可，workspace表示项目目录，fileDirname表示当前focus所在编辑页面的文件目录。MIMode填写gdb，miDebuggerPath填写gdb程序的路径，如果是ARM程序需要使用ARM版GDB，x86程序使用x86的GDB。 1234567891011121314151617181920\"version\": \"0.2.0\",\"configurations\": [&#123; \"name\": \"kernel-debug\", \"type\": \"cppdbg\", \"request\": \"launch\", \"miDebuggerServerAddress\": \"127.0.0.1:1234\", \"program\": \"$&#123;fileDirname&#125;/kernel.gdb.bin\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"$&#123;fileDirname&#125;\", \"environment\": [], \"externalConsole\": false, \"logging\": &#123; \"engineLogging\": false &#125;, \"MIMode\": \"gdb\", \"miDebuggerPath\": \"/usr/bin/gdb\",&#125;] 2. 启动调试1）首先在命令行界面启动带gdb调试的qemu1qemu-system-i386 -m 2048 -hda b.img -boot order=a -ctrl-grab -gdb tcp::1234 -S -monitor stdio 2) 在vscode中启动调试可以看到左侧有调试窗口分别是变量，监视，调用堆栈，断点。 C语言部分的调试已经很熟悉了，重点说一下汇编的调试.&emsp;&emsp;汇编部分要先设置断点后启动vscode调试程序，这点很重要，否则程序将直接执行到C语言的main函数入口。比如要调试kernel.asm的_start函数，则在断点窗口添加_start断点，注意由于汇编程序不能通过鼠标在源码上设置断点，只能在断点窗口输入断点位置后启动debuger程序，程序将停在_start函数入口处。如下图所示：&emsp;&emsp;虽然停在_start了，可是编辑器的源码上没有任何光标指示，只能在调试控制台根据提示 用-exec disassemble这样的命令来执行GDB指令。&emsp;&emsp;这样的原因推测是miniOS项目用的是nasm编译器来编译汇编程序，与GDB兼容性低造成的，因为ARM移植工作的miniOS完全采用gcc编译器，就能显示光标在源文件上，如下图所示为使用GCC编译汇编程序的调试效果。&emsp;&emsp;虽然x86的汇编上没有光标，但是可以通过反汇编来实现汇编级别的图形化调试，如下所示。可以看到反汇编的指令&emsp;&emsp;这样还是有问题，发现有几条反汇编的指令与汇编源码不同，这是因为编译和反汇编采用的编译器不同造成的。但除了前2条指令其他反汇编指令还算正常，所以在通过图形界面设置断点的时候不能设置在错误的反汇编指令上，否则是不能起作用的甚至可能奔溃。可以在调试控制台 -exec b xxx来设置正确的断点。&emsp;&emsp;总之对于用nasm编译的汇编程序更推荐在调试控制台来调试，反汇编界面只作为参考。&emsp;&emsp;即使要用图形界面调试汇编也要先用-exec ni在调试控制台将反汇编错误的指令过去了再用图形界面调试。 3）错误的反汇编指令例子：&emsp;&emsp;可以看到当前指令的前面2条指令反汇编结果错误，在反汇编无误的时候才能在图形界面设置断点和单步调试。否则vscode会奔溃。","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"汇编","slug":"汇编","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E6%B1%87%E7%BC%96/"},{"name":"vscode","slug":"vscode","permalink":"https://xiao_feng_yang993.gitee.io/tags/vscode/"},{"name":"调试","slug":"调试","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E8%B0%83%E8%AF%95/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"内嵌汇编","slug":"内嵌汇编","date":"2020-11-19T15:38:26.000Z","updated":"2022-09-29T11:37:32.407Z","comments":true,"path":"2020/11/19/内嵌汇编/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/11/19/%E5%86%85%E5%B5%8C%E6%B1%87%E7%BC%96/","excerpt":"","text":"内嵌汇编学习操作系统高级教程上面需要阅读Linux内核0.11的源码，其中在书《Linux内核设计的一书》第2.5节异常处理类中段服务程序挂接的部分，遇到了嵌入在C语言中的汇编代码，之前从来没有学习过汇编，因此记录下。 AT&amp;T基础知识内嵌汇编使用的是AT&amp;T汇编，所以首先稍微讲解下AT&amp;T的汇编指令的基础知识。 1234### 操作数前缀movl $8,%eax movl $0xffff,%ebx int $0x80 看到在AT%T汇编中诸如”%eax”、”%ebx”之类的寄存器名字前都要加上”%”；”$8”、”$0xffff”这样的立即数之前都要加上”$”。 源/目的操作数顺序在Intel语法中，第一个操作数是目的操作数，第二个操作数源操作数。而在AT&amp;T中，第一个数是源操作数，第二个数是目的操作数。 // INTEL语法MOV EAX,8 //EAX是目的操作数， 8是源操作数// AT&amp;T语法movl $8,%eax //8是源操作数 EAX是目的操作数 标识长度的操作码后缀在AT&amp;T的操作码后面有时还会有一个后缀，其含义就是指出操作码的大小。“l”表示长整数（32位），“w”表示字（16位），“b”表示字节（8位）。 1234movb %bl,%almovw %bx,%axmovl %ebx,%eaxmovl (%ebx),%eax GCC内嵌汇编Linux操作系统内核代码绝大部分使用C语言编写，只有一小部分使用汇编语言编写，例如与特定体系结构相关的代码和对性能影响很大的代码。GCC提供了内嵌汇编的功能，可以在C代码中直接内嵌汇编语言语句，大大方便了程序设计。 基本行内汇编基本行内汇编很容易理解，一般是按照下面的格式： 1asm(“statements”); 在“asm”后面有时也会加上“volatile”表示编译器不要优化代码，后面的指令保留原样 1__asm__ __volatile__(&quot;hlt&quot;); 如果有很多行汇编，则每一行后要加上“\\n\\t” ： 123asm( &quot;pushl %eax\\n\\t&quot; &quot;movl $0,%eax\\n\\t&quot;&quot;popl %eax&quot;); 或者我们也可以分成几行来写，如： 123asm(&quot;movl %eax,%ebx&quot;);asm(&quot;xorl %ebx,%edx&quot;);asm(&quot;movl $0,_booga); 通常使用汇编语句最方便的方式是把它们放在一个宏内，而宏语句需要在一行上定义，因此使用反斜杠\\将这些语句连成一行，所以上述语句如果在宏中定义的话就是： 123asm( &quot;pushl %eax; \\ movl $0,%eax; \\popl %eax&quot;); 扩展的行内汇编在扩展的行内汇编中，可以将C语言表达式（比如C语言中的变量）指定为汇编指令的操作数，而且不用去管如何将C语言表达式的值读入寄存器，以及如何将计算结果写回C变量，你只要告诉程序中C语言表达式与汇编指令操作数之间的对应关系即可， GCC会自动插入代码完成必要的操作。 使用内嵌汇编，要先编写汇编指令模板，然后将C语言表达式与指令的操作数相关联，并告诉GCC对这些操作有哪些限制条件。例如下面的内嵌汇编语句： 1234567int main()&#123; int input = 8; int result = 0; __asm__ __violate__ (\"movl %1,%0\" : \"=r\" (result) : \"r\" (input)); printf(\"%d\\n\",result); return 0;&#125; “movl %1,%0”是指令模板；“%0”和“%1”代表指令的操作数，称为占位符，“=r”代表它之后是输入变量且需用到寄存器，指令模板后面用小括号括起来的是C语言表达式 ，其中input是输入变量，该指令会完成把input的值复制到result中的操作 。 扩展的行内汇编的语法内嵌汇编语法如下： 1234567asm(&quot;汇编语句模块&quot;:输出寄存器 :输入寄存器 :会被修改的寄存器); 即格式为asm ( “statements” : output_regs : input_regs : clobbered_regs) 汇编语句模块必不可少，其他三部分可选，如果使用了后面的部分，而前面部分为空，也需要用“:”格开，相应部分内容为空。 汇编语句模块汇编语句模块由汇编语句序列组成，语句之间使用“;”、“\\n”或“\\n\\t”分开。指令中的操作数可以使用占位符引用C语言变量，操作数占位符最多10个，名称如下：%0，%1…，%9。指令中使用占位符表示的操作数，总被视为long型（4，个字节），但对其施加的操作根据指令可以是字或者字节，当把操作数当作字或者字节使用时，默认为低字或者低字节。对字节操作可以显式的指明是低字节还是次字节。方法是在%和序号之间插入一个字母，“b”代表低字节，“h”代表高字节，例如：%h1。 占位符的理解：将汇编输出寄存器与输入寄存器从输出寄存器行开始左到右从上到下进行编号分别为：%0，%1…，%9。比如有代码： 12345678910#define get_seg_byte(seg,addr) \\(&#123; \\register char __res; \\__asm__(\"push %%fs; \\mov %%ax,%%fs; \\movb %%fs:%2,%%al; \\pop %%fs\" \\:\"=a\" (__res) \\:\"\" (seg),\"m\" (*(addr))); \\__res;&#125;) 输出寄存器”=a”eax记为%0,输入寄存器””(依然是eax)记为%1,输入寄存器”m”为%2。 输出寄存器描述输出操作数，不同的操作数描述符之间用逗号格开，每个操作数描述符由限定字符串和C语言变量组成。每个输出操作数的限定字符串必须包含“=”，表示它是一个输出操作数。例如： 1__asm__ __volatile__ (\"pushfl ; popl %0 ; cli\":\"=g\" (x) ) 在这里“x”便是最终存放输出结果的C程序变量，而“=g”则是限定字符串，限定字符串表示了对它之后的变量的限制条件 。 输入寄存器描述输入操作数，不同的操作数描述符之间使用逗号格开，每个操作数描述符同样也由限定字符串和C语言表达式或者C语言变量组成。例： asm volatile__ (“lidt %0” : : “m” (real_mode_idt));其中%0是占位操作符，而输出寄存器为空，输入寄存器的值为C语言表达式real_mode_idt。 限定字符串又叫做寄存器加载代码 限定字符 描述 限定字符 描述 a 使用寄存器eax m 使用内存地址 b 使用寄存器ebx o 使用内存地址并可以加偏移值 c 使用寄存器ecx I 使用常数0~31 立即数 d 使用寄存器edx V 操作数是内存变量，但不是偏移寻址 s 使用寄存器esi , 操作数为内存变量，但寻址方式为自动增量 g、X 寄存器或内存 J 使用常数0~63 立即数 i 立即数 K 使用常数0~255立即数 n 立即数，有些系统不支持除字以外的立即数 p 操作数是一个合法的内存地址（指针） D 使用edi L 使用常数0~65535 立即数 q 使用动态分配字节可寻址寄存器（eax、ebx、ecx或edx） M 使用常数0~3 立即数 r 使用任意动态分配的寄存器 N 使用1字节常数（0~255）立即数 g 使用通用有效的地址即可（eax、ebx、ecx、edx或内存变量） O 使用常数0~31 立即数 A 使用eax与edx联合（64位） = 操作数在指令中是只写的（输出操作数） + 操作数在指令中是读写类型的（输入输出操作数） t 第一个浮点寄存器 u 第二个浮点寄存器 G 标准的80387 例子直接摘抄自《Linux内核完全注释》第5.2.2 traps.c程序的第82页 例子1： 1234567891001 #define get_seg_byte(seg,addr) \\02 (&#123; \\03 register char __res; \\04 __asm__(\"push %%fs; \\05 mov %%ax,%%fs; \\06 movb %%fs:%2,%%al; \\07 pop %%fs\" \\08 :\"=a\" (__res) \\09 :\"\" (seg),\"m\" (*(addr))); \\10 __res;&#125;) 第1 行定义了宏的名称，也即是宏函数名称 get_seg_byte(seg,addr) 。第 3 行定义了一个寄存器变量 res 。第 4 行上的 asm表示嵌入汇编语句的开始。从第 4 行到第 7 行的 4 条语句是 AT&amp;T 格式的汇编语句。 第 8 行即是输出寄存器，这句的含义是在这段代码运行结束后将 eax 所代表的寄存器的值放入__res变量中，作为本函数的输出值， “=a” 中的 “a” 称为加载代码， “=” 表示这是输出寄存器。第 9 行表示在这段代码开始运行时将 seg 放到 eax 寄存器中， “” 表示使用与上面同个位置的输出相同的寄存器。而 ((addr))表示一个内存偏移地址值。为了在上面汇编语句中使用该地址值，嵌入汇编程序规定把输出和输入寄存器统一按顺序编号，顺序是从输出寄存器序列从左到右从上到下以 “%0” 开始，分别记为 %0 、 %1 、 …%9 。因此，输出寄存器的编号是 %0 （这里只有一个输出寄存器），输入寄存器前一部分 (“” (seg)) 的编号是 %1 ，而后部分的编号是 %2 。上面第 6 行上的 %2 即代表 ((addr)) 这个内存偏移量。现在我们来研究 4—7 行上的代码的作用。第一句将 fs 段寄存器的内容入栈；第二句将 eax 中的段值赋给 fs 段寄存器；第三句是把 fs:(*(addr)) 所指定的字节放入 al 寄存器中。当执行完汇编语句后，输出寄存器 eax 的值将被放入 __res ，作为该宏函数（块结构表达式）的返回值。 通过上面分析，我们知道，宏名称中的 seg 代表一指定的内存段值，而 addr 表示一内存偏移地址量。到现在为止，我们应该很清楚这段程序的功能了吧！该宏函数的功能是从指定段和偏移值的内存地址处取一个字节。 通过上面的例子说明，阅读这段代码时应该像CPU处理指令时的逻辑一样，先从输出输入寄存器语句开始知道输入输出是什么，然后再阅读汇编语句，处理完后再看最后的返回是什么。 例子2再来看下Linux 内核中main()中对中断异常挂接的trap_init()中的设计到的一个GCC内嵌汇编。代码路径为；include\\asm\\system.h 123456789101 #define _set_gate(gate_addr,type,dpl,addr) \\2 __asm__ (\"movw %%dx,%%ax\\n\\t\" \\3 \"movw %0,%%dx\\n\\t\" \\4 \"movl %%eax,%1\\n\\t\" \\5 \"movl %%edx,%2\" \\6 : \\7 : \"i\" ((short) (0x8000+(dpl&lt;&lt;13)+(type&lt;&lt;8))), \\8 \"o\" (*((char *) (gate_addr))), \\9 \"o\" (*(4+(char *) (gate_addr))), \\10 \"d\" ((char *) (addr)),\"a\" (0x00080000)) 首先从第6行输出寄存器开始阅读：输出寄存器为空。然后是第7至10行的输入寄存器。第%0个输入寄存器使用“i”表示输入立即数，第%1个输入寄存器使用“o”表示使用内存地址并可以加偏移值，第%2个输入寄存器依然使用“o”代码，第%3个寄存器使用“d”表示使用寄存器edx，第%4个寄存器使用“a”表示使用寄存器eax。 之后再看下汇编语句：依次进行值的传递。","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"汇编","slug":"汇编","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E6%B1%87%E7%BC%96/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"Docker学习笔记 一：Docker 架构及工作原理","slug":"Docker学习笔记-一：Docker-架构及工作原理","date":"2020-10-10T18:20:11.000Z","updated":"2022-09-29T11:37:32.407Z","comments":true,"path":"2020/10/11/Docker学习笔记-一：Docker-架构及工作原理/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/10/11/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80%EF%BC%9ADocker-%E6%9E%B6%E6%9E%84%E5%8F%8A%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","excerpt":"","text":"Docker 架构及工作原理摘要：Docker 是一个客户端-服务器（C/S）架构程序。Docker 客户端只需要向 Docker 服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker 提供了一个命令行工具 Docker 以及一整套 RESTful API。 通过下图可以得知，Docker 在运行时分为 Docker 引擎（服务端守护进程） 和 客户端工具，我们日常使用各种 docker 命令，其实就是在使用 客户端工具 与 Docker 引擎 进行交互。 Client 客户端Docker 是一个客户端-服务器（C/S）架构程序。Docker 客户端只需要向 Docker 服务器或者守护进程发出请求，服务器或者守护进程将完成所有工作并返回结果。Docker 提供了一个命令行工具 Docker 以及一整套 RESTful API。你可以在同一台宿主机上运行 Docker 守护进程和客户端，也可以从本地的 Docker 客户端连接到运行在另一台宿主机上的远程 Docker 守护进程。 Host 主机(Docker 引擎)一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。 Image 镜像什么是 Docker 镜像？简单的理解，Docker 镜像就是一个 Linux 的文件系统（Root FileSystem），这个文件系统里面包含可以运行在 Linux 内核的程序以及相应的数据。通过镜像启动一个容器，一个镜像就是一个可执行的包，其中包括运行应用程序所需要的所有内容：包含代码，运行时间，库，环境变量和配置文件等。Docker 把 App 文件打包成为一个镜像，并且采用类似多次快照的存储技术，可以实现： 多个 App 可以共用相同的底层镜像（初始的操作系统镜像）；App 运行时的 IO 操作和镜像文件隔离；通过挂载包含不同配置/数据文件的目录或者卷（Volume），单个 App 镜像可以用来运行无数个不同业务的容器。 Container 容器镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。 镜像分层Docker 支持通过扩展现有镜像，创建新的镜像。实际上，Docker Hub 中 99% 的镜像都是通过在 base 镜像中安装和配置需要的软件构建出来的。从上图可以看到，新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。镜像分层最大的一个好处就是共享资源。比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。如果多个容器共享一份基础镜像，当某个容器修改了基础镜像的内容，比如 /etc 下的文件，这时其他容器的 /etc 是不会被修改的，修改只会被限制在单个容器内。这就是容器 Copy-on-Write 特性。 可写的容器层当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。 镜像层数量可能会很多，所有镜像层会联合在一起组成一个统一的文件系统。如果不同层中有一个相同路径的文件，比如 /a，上层的 /a 会覆盖下层的 /a，也就是说用户只能访问到上层中的文件 /a。在容器层中，用户看到的是一个叠加之后的文件系统。 只有当需要修改时才复制一份数据，这种特性被称作 Copy-on-Write。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。 Copy-on-Write:123写入时复制（英语：Copy-on-write，简称COW）是一种计算机程序设计领域的优化策略。其核心思想是，如果有多个调用者（callers）同时请求相同资源（如内存或磁盘上的数据存储），他们会共同获取相同的指针指向相同的资源，直到某个调用者试图修改资源的内容时，系统才会真正复制一份专用副本（private copy）给该调用者，而其他调用者所见到的最初的资源仍然保持不变。以 linux 为例，当通过系统调用（syscall）从一个已经存在的进程 P1 中 fork 出一个子进程 P2，OS会为 P2 创建一套与 P1 保持一致映射关系的虚拟内存空间，从而实现了 P1 和 P2 对物理空间的共享，这样做的目的是为了减少对物理内存的消耗，毕竟两份完全一样的数据没必要额外占用多一倍物理内存空间。此后，如果 P1 或 P2 需要更改某段内存，则须为其按需分配额外物理内存，将共享数据拷贝出来，供其修改，这里注意，无论父还是子进程，只要有修改，就会涉及到内存拷贝，这里的影响粒度范围是内存页，linux 内存页大小为 4KB。 总结下来就是：容器层记录对镜像的修改，所有镜像层都是只读的，不会被容器修改，所以镜像可以被多个容器共享。 Volume 数据卷实际上我们的容器就好像是一个简易版的操作系统，只不过系统中只安装了我们的程序运行所需要的环境，前边说到我们的容器是可以删除的，那如果删除了，容器中的程序产生的需要持久化的数据怎么办呢？容器运行的时候我们可以进容器去查看，容器一旦删除就什么都没有了。 所以数据卷就是来解决这个问题的，是用来将数据持久化到我们宿主机上，与容器间实现数据共享，简单的说就是将宿主机的目录映射到容器中的目录，应用程序在容器中的目录读写数据会同步到宿主机上，这样容器产生的数据就可以持久化了，比如我们的数据库容器，就可以把数据存储到我们宿主机上的真实磁盘中。 Registry 注册中心Docker 用 Registry 来保存用户构建的镜像。Registry 分为公共和私有两种。Docker 公司运营公共的 Registry 叫做 Docker Hub。用户可以在 Docker Hub 注册账号，分享并保存自己的镜像。 Docker 公司提供了公共的镜像仓库 hub.docker.com（Docker 称之为 Repository）提供了庞大的镜像集合供使用。 一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。 通常，一个仓库会包含同一个软件不同版本的镜像，而标签对应该软件的各个版本。我们可以通过 &lt;仓库名&gt;:&lt;标签&gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。 总结Docker 官网写着这样一句话：Build and Ship any Application Anywhere，再结合刚才我们所理解的内容，总结下来就是：一次构建，到处运行。此外，Docker 公司提供了公共的镜像仓库 hub.docker.com（Docker 称之为 Repository），GitHub connect，自动构建镜像，大大简化了应用分发、部署、升级流程。加上 Docker 可以非常方便的建立各种自定义的镜像文件，这些都是 Docker 成为最流行的容器技术的重要因素。 通过以上这些技术的组合，最后的结果就是：绝大部分应用，开发者都可以通过 docker build 创建镜像，通过 docker push 上传镜像，用户通过 docker pull 下载镜像，使用 docker run 运行容器应用。用户不再需要去关心如何搭建环境，如何安装，如何解决不同发行版的库冲突——而且通常不会消耗更多的硬件资源，不会明显降低性能。","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"},{"name":"docker","slug":"docker","permalink":"https://xiao_feng_yang993.gitee.io/tags/docker/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"石子合并","slug":"石子合并","date":"2020-07-16T16:31:59.000Z","updated":"2022-09-29T11:37:32.408Z","comments":true,"path":"2020/07/17/石子合并/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/07/17/%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6/","excerpt":"","text":"题目有一个石子归并的游戏。最开始的时候，有n堆石子排成一列，目标是要将所有的石子合并成一堆。合并规则如下： 每一次可以合并相邻位置的两堆石子每次合并的代价为所合并的两堆石子的重量之和求出最小的合并代价。 样例样例 1: 输入: [3, 4, 3]输出: 17样例 2: 输入: [4, 1, 1, 4]输出: 18解释: 合并第二堆和第三堆 =&gt; [4, 2, 4], score = 2 合并前两堆 =&gt; [6, 4]，score = 8 合并剩余的两堆 =&gt; [10], score = 18解题思路用DP[i][j]来表示把A[i…j]搬到一起需要的score。DP[left][right]可以表示成DP[left][j] + DP[j+1][right] + sum(i,j) 元素i到j求和，可以前缀和求得；即首先形成这两团需要的score，和把这两团加在一起的score（前缀和）。 len要大于等于2才有意义，因为要长度至少为2才能累加。枚举的区间长度，左边是i，右边是i + len - 1。 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123;public: /** * @param A: An integer array * @return: An integer */ int stoneGame(vector&lt;int&gt; &amp;A) &#123; // write your code here int n = A.size(); if(n==0)return 0; if(n==1)return 0; int *sum = (int *)malloc(sizeof(int)*n+1); sum[0]=0; for(int i=1;i&lt;=n;i++)sum[i]=sum[i-1]+A[i-1]; // int dp[][]=new int[n][n]; int **dp; dp=(int **)malloc(sizeof(int *)*n); for(int i=0;i&lt;n;i++)&#123; dp[i]=(int *)malloc(sizeof(int)*n); &#125; for(int i=0;i&lt;n-1;i++)&#123; dp[i][i]=0; dp[i][i+1]=A[i]+A[i+1]; &#125; dp[n-1][n-1]=0; for(int len = 3;len&lt;=n;len++)&#123; for(int i=0;i&lt;=n-len;i++)&#123; int j=i+len-1; dp[i][j]=999999; for(int k=i;k&lt;j;k++)&#123; dp[i][j]=(dp[i][k]+dp[k+1][j]+sum[j+1]-sum[i]) &lt; dp[i][j]?(dp[i][k]+dp[k+1][j]+sum[j+1]-sum[i]):dp[i][j]; &#125; &#125; &#125; return dp[0][n-1]; &#125;&#125;;","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"dp","slug":"dp","permalink":"https://xiao_feng_yang993.gitee.io/tags/dp/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"软件工程-复习总结","slug":"软件工程-复习总结","date":"2020-07-02T17:32:57.000Z","updated":"2022-09-29T11:37:32.408Z","comments":true,"path":"2020/07/03/软件工程-复习总结/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/07/03/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/","excerpt":"","text":"第一章 软件工程 什么是软件？软件的特点？ 软件是计算机系统中与硬件相互依存的另一部分；它是包括程序，数据，文档的完整集合 软件危机的定义 软件开发和维护过程中所遇到的这一系列严重问题为软件危机： 软件十分复杂，价格昂贵，供需差日益则大 软件开发时常受挫，质量差，进度和完成日期不按时，研制失去控制 软件危机的原因 软件的复杂性：代码量大，系统类型多 软件产品的特殊性：一致性，可变性，不可见性 人们认识的局限性：忽视需求分析，当作编写程序，缺少度量标准，忽视软件维护 什么是软件工程 将系统化的，规范化的，可度量的方法应用于软件开发，运行，维护的过程，将工程化应用于软件中 软件工程是应用计算机科学，数学及管理科学等原理开发软件的工程。借鉴传统工程的原则，方法，以提高质量降低成本为目的 软件工程研究的内容是什么 软件工程以关注软件质量为目标，包括过程，方法和工具三个要素 过程：支持软件生命周期的所有活动 方法：为软件开发过程提供“如何做”的技术 工具：为软件开发方法提供自动或半自动的软件支撑环境 提高软件质量的手段 可靠性：正确性和健壮，正确性和对异常值边界值的处理能力 可维护性：可读性，可修改性，可测试性，完整性 可理解性：简单性，清晰性，可用性 效率： 什么是软件生命周期 一个软件被提出开始研制至软件最终被废弃不再使用为止的全过程，成为软件生命期，包括：软件定义，软件开发及软件运行维护 瀑布模型每一阶段的含义 可行性研究与计划 需求分析 设计 编码 测试 运行维护 瀑布模型的优缺点 优点： 强调开发的阶段性：阶段间具有顺序性和依赖性 强调早期计划及需求调查：推迟实现的观点 强调评审，强调产品测试：质量保证的观点 缺点： 依赖于早期进行的唯一一次需求调查，不能适应需求的变化 由于是单一流程，开发过程中的经验教训不能反馈于应用于本产品的过程 风险往往迟滞后期的开发阶段才显露，因而失去趁早纠正的机会。 文档驱动的，对于非专业用户难以阅读和理解 软件生命模型各自的特点 螺旋模型： 1)螺旋模型将瀑布模型与原型模型结合起来， 并且加入两种模型均忽略了的风险分析。 2)螺旋模型沿着螺线旋转，自内向外每旋转一 圈便开发出更完善的一个新版本。 ◆ 制定计划 确定软件目标，选定实施方案， 弄清项目开发的限制条件； ◆ 风险分析 分析所选方案，考虑如何识别和 消除风险； ◆ 实施工程 实施软件开发 ◆ 客户评估 评价开发，提出修正建议。 增量模型： 1)增量模型是迭代和演进的过程。 2)增量模型把软件产品分解成一系列的增量构件 ，在增量开发迭代中逐步加入。 3)每个构件由多个相互作用的模块构成，并且能够完成特定的功能。 4)早先完成的增量可以为后期的增量提供服务。 5)增量开发方法的新演进版本叫做“极限程序设 计（eXtreme Programming）” 原型模型： 1)原型模型是迭代的。因为软件与所有的复杂系统一样，必须经过不断演化才能完善。 2)原型模型先开发一个“原型”软件，完成部 分主要功能，展示给用户并征求意见，然后 逐步完善，最终获得满意的软件产品。 3)业务和产品需求在变化中，采用线性开发方 式是不实际的。 4)快速实现和提交一个有限的版本，可以应付 市场竞争的压力。 敏捷模型解决什么问题 敏捷过程为了使软件开发团队具有高效工作和快速响应变化的能力。 快速的市场进入时间，要求高生产率 快速变化的需求，需求模糊且经常改变 快速发展的技术 第二章 可行性研究 什么是可行性分析 弄清楚要计算机解决的问题根本所在，确定新系统的作用域，以及项目所需资源和经费 可行性分析的目的 用最小的代价在尽可能短的时间内确定问题能否解决 可行性分析的内容 经济可行性，技术可行性，操作可行性 步骤：研究当前正在运行的系统确定项目的规模和目标建立新系统的高层逻辑模型导出和评价各种方案推荐可行方案编写可行性研究报告 什么是人月，人月是什么单位 第三章 需求分析 需求分析的内容 需求分析的过程 需求获取 需求分析 规格说明 需求验证：确保需求编写正确。必须全面理解用户的各项要求，准确表达被接受的用户要求。 需求基线 需求管理：管理需求变化的过程，涉及需求变更如何被处理的策略、规程和过程 需求分析的方法 面向数据的结构化分析法（SA） 面向对象的分析方法（OOA） 需求报告的作用，需求报告主要内容，写作注意事项 作用：作为用户和软件人员之间的合同，为双方互相了解提供基础反映出问题结构，可用作为软件人员进行设计和编写的基础作为验收的依据，即作为选取测试用例和进行形式验证的依据 内容： 注意事项： 简洁：保持语句和段落的简短 一致：需求陈述应该具有一致的样式 必须避免模糊的、主观的术语，减少不确定性 避免使用比较性词汇 不应该把多个需求集中在一个冗长的叙述段落中 需求文档的质量属性 完整，无二义性，可验证，正确，一致 结构化分析的分析模型 建立系统的功能模型 利用数据流图（Data Flow Diagram，DFD）将 大问题分割成若干个小问题，采用分层的数据流图， 先建立系统环境图（顶层），再逐步求精。 建立数据字典 采用结构化英语，小说明，补充材料等列出。 E-R图 数据流图 数据守恒与数据封闭原则 加工分解的原则 子图与父图的“平衡“ 合理使用文件 数据字典 状态迁移图 描述系统的状态如何响应外部的事件进行推 移的一种图形表示 判断树，判定表 在某些数据处理中，某数据流图的加工需要依赖于多 个逻辑条件的取值，就是说完成这一加工的一组动作是由 于某一组条件取值的组合而引发的。这时使用判定表来描 述比较合适 判定树是判定表的变种，它也能清晰地表达复杂的条件组 合与所对应的操作之间的关系。判定树的优点在于它无须任 何说明，一眼就能看出其含义，易于理解和使用 第四章 总体设计 总体设计的内容 将系统划分成模块 决定每个模块的功能 决定模块调用关系 决定模块界面，即模块间传递的数据 模块化设计的重要指导思想是什么 分解，信息隐蔽，确保模块独立 什么是耦合，具体哪些耦合方式 耦合是对一个软件结构内不同模块之间互联程度的度量。耦合的强弱取决于模块间接口的复杂程度，进入模或访问一个模块的点以及通过接口的数据 简单耦合 数据耦合 标记耦合 控制耦合 外部耦合 公共耦合 内容耦合 模块之间联系的原则 尽量使用数据耦合，少使用控制耦合，限制公共耦合范围，完全不用内容耦合 模块间互相调用时，传递参数最好只有一个 什么是内聚，内聚有哪些类型。设计时因追求什么内聚 内聚标志着一个模块内部各个元素间彼此结合的紧密程度。 功能内聚： 模块内所有处理元素属于一个整体，完成一个单一的功能 顺序内聚： 一个模块内部各个组成部分的处理动作是按顺序执行的，且前一个处理动作和输出数据是下一个处理动作的输入数据 通信内聚： 一个模块内各个组成部分的处理动作都引用相同的输入数据或产生相同的输出数据 过程内聚： 一个模块内部各个组成部分的处理动作各不相同，彼此也没有什么关系，但它们都受同一个控制流支配，决定它们的执行顺序 时间内聚： 一个模块各组成部分，它们处理动作和时间有关 逻辑内聚： 逻辑相关的函数或数据出现在同一个模型里 偶然内聚： 无关的函数，过程或数据出现在同一个模块里 模块化的基本原则 高内聚，低耦合。内聚比耦合更重要 模块的评价标准 可分解，可组装，可理解，连续性，保护性 什么是模块的深度和广度 扇入于扇出 扇出：一个模块之间调用/控制的模块数 3&lt;=fan-out&lt;=9 扇入：之间调用该模块的模块数 不破坏独立性的前提下，fan-in大的比较好 控制域作用域 作用域是指该模块中一个判断所影响的所有其它模块 控制域指该模块本身以及所有直接或间接从属于它的模块 模块设计时的启发式规则 低耦合，高内聚；模块规模适中；适当控制深度宽度；降低接口复杂程度；争取单入单出；模块功能可预测 第五章 详细设计 详细设计的内容 以总体设计阶段的工作为基础 在总体设计阶段，数据项和数据结构以比较抽象的方式描述，而详细设计阶段则应在此基础上给出足够详细描述。 详细设计要提供关于算法的更多的细节 详细设计的任务和原则 任务： 确定每个模块算法 确定每一个模块的数据组织 为每一个模块设计一组测试用例 编写详细设计说明书 原则 模块的逻辑描述正确可靠 采用结构化程序设计方法，改善控制结构，降低程序复杂度，提高程序可读性，可测试性和可维护性 详细设计的工具，优缺点 程序流程图 优点：比较直观 和清晰地描述过程的控制流程 缺点： 不是逐步求 精的好工具，忽略了程序的全局结构 随意转移控制 表示数据结构方面存在不足。 H-S图 功能域 控制转移不能任意规定 容易确定局部数据和全局数据的作用域 容易表现嵌套关系，也可以表示模块的层次结构 pad图 清晰度和结构化程度高。 PAD图中的最左面的线是程序的主干线,即程序的第一层结构。随着程序层次的增加，PAD图逐渐 向右延伸。因此，PAD图可读性强。 利用PAD图设计出的程序必定是结构化的程序。 容易将PAD图转化成高级语言源程序。 PAD图支持自顶向下逐步求精的方法。 环形复杂度，如何计算 绘制流图：程序流程图中的顺序的处理框序列和菱形判定框， 可以映射成流图中的一个结点，仅仅描绘程序的控制流程，完全不表现对数据的具体操 作以及分支或循环的具体条件 流图中区域数（包括图外区域） 流图边数-节点数 + 2 判定结点数+1 环形复杂度对编程的指导意义 环形复杂度高 的程序，往往是最困难、最容易出问题的程序. 模块规模以V(G)≤10为宜，也就是说，V(G)=10 是模块规模的一个更科学更精确的上限 第六章 编码 编程语言共有的特性有哪些 名字说明 类型说明 初始化 程序对象的局部性 程序模块 循环控制结构 分支控制结构 异常处理 独立编译 什么是编码规范，枚举常用的编码规范 编码风格实际上是一种编码原则。编码的目标从强调效率转变到强调 清晰。与此相应，编码风格也从追求“聪明”和 “技巧” ，变为提倡“简明”和“直接” 。人们 逐渐认识到，良好的编码风格能在一定程度上弥 补程序设计语言存在的缺点。反之，如果不注意 编码风格，即使使用了结构化的现代语言，也很 难写出高质量的程序。 1). 序言性注释 2). 描述性注释 3). 变量名选择合理 4). 表达式书写 5). 循环语句设计 什么是程序内文档，如何做程序内文档 指编码时适当选择标识符的名字、适当安排注释和注重程序的整个组织形式。 提升代码效率的方法 准则： 效率是一种性能需求，目标值应该在需求分析阶段设定。软件效率应该以需求为准，不应该以人力所及为准 好的设计可用提高效率 代码效率与代码简单性相关 方法： （1）应先简化算术和逻辑的表达式。 （2）仔细研究嵌套的循环，以确定是否有语句可以 从内层往外移。 （3）尽量避免使用多维数组。 （4）尽量避免使用指针和复杂的列表。 （5）使用执行时间短的算术运算。 （6）即使语言允许，一般也不要采用混合数据类型。 （7）尽量使用整数表达式和布尔表达式。 第八章 维护 维护的种类 纠错性维护 适应性维护 完善性维护 预防性维护 什么是再工程（预防性维护） 再工程是一个重构活动，软件再工程是一类软件工程活动，是一个工程过程,它将逆向工程，重构和正向工程组合起来，将现存系统重新构造为新的形式 文档是影响软件可维护性的决定性因素","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"顺时针打印矩阵","slug":"顺时针打印矩阵","date":"2020-06-28T21:54:28.000Z","updated":"2022-09-29T11:37:32.408Z","comments":true,"path":"2020/06/29/顺时针打印矩阵/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/06/29/%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/","excerpt":"","text":"题目输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 解析一圈一圈向内靠近，每轮减少两行两列，最后处理剩余不足2行2列的情况 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889class Solution &#123;public: typedef struct point&#123; int x; int y; &#125;point; vector&lt;int&gt; printMatrix(vector&lt;vector&lt;int&gt; &gt; matrix) &#123; int lenx,leny; vector&lt;int&gt; ans; lenx=matrix.size(); leny=matrix[0].size(); point p[4]; p[0].x=0; p[0].y=0; p[1].x=0; p[1].y=leny-1; p[2].x=lenx-1; p[2].y=leny-1; p[3].x=lenx-1; p[3].y=0; bool first=true; while(1)&#123; if(first)&#123; if(p[0].x==p[3].x&amp;&amp;p[0].y==p[3].y)&#123; for(int i=p[0].y;i&lt;=p[1].y;i++)&#123; ans.push_back(matrix[p[0].x][i]); &#125; break; &#125; else if(p[0].x==p[1].x&amp;&amp;p[0].y==p[1].y)&#123; for(int i=p[1].x;i&lt;=p[2].x;i++)&#123; ans.push_back(matrix[i][p[1].y]); &#125; break; &#125; &#125; first=false; for(int i=p[0].y;i&lt;p[1].y;i++)&#123; ans.push_back(matrix[p[0].x][i]); &#125; for(int i=p[1].x;i&lt;p[2].x;i++)&#123; ans.push_back(matrix[i][p[1].y]); &#125; for(int i=p[2].y;i&gt;p[3].y;i--)&#123; ans.push_back(matrix[p[2].x][i]); &#125; for(int i=p[3].x;i&gt;p[0].x;i--)&#123; ans.push_back(matrix[i][p[3].y]); &#125; p[0].x++; p[0].y++; p[1].x++; p[1].y--; p[2].x--; p[2].y--; p[3].x--; p[3].y++; if(p[0].x&gt;p[3].x||p[0].y&gt;p[1].y)&#123; break; &#125; if(p[0].x==p[3].x&amp;&amp;p[0].y==p[3].y)&#123; for(int i=p[0].y;i&lt;=p[1].y;i++)&#123; ans.push_back(matrix[p[0].x][i]); &#125; break; &#125; else if(p[0].x==p[1].x&amp;&amp;p[0].y==p[1].y)&#123; for(int i=p[1].x;i&lt;=p[2].x;i++)&#123; ans.push_back(matrix[i][p[1].y]); &#125; break; &#125; &#125; return ans; &#125;&#125;;","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E7%AE%97%E6%B3%95/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"topK","slug":"topK","date":"2020-06-20T13:42:09.000Z","updated":"2022-09-29T11:37:32.407Z","comments":true,"path":"2020/06/20/topK/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/06/20/topK/","excerpt":"","text":"描述在数组中找到第 k 大的元素。 你可以交换数组中的元素的位置 样例样例 1： 输入：n = 1, nums = [1,3,4,2]输出：4样例 2： 输入：n = 3, nums = [9,3,2,4,8]输出：4 挑战要求时间复杂度为O(n)，空间复杂度为O(1)。 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution &#123;public: /** * @param n: An integer * @param nums: An array * @return: the Kth largest element */ static bool cmp(int a, int b) &#123; return a &gt; b; &#125;void quicksort(vector&lt;int&gt;&amp; a, int left, int right, int n)&#123; int temp = a[left]; int i, j; i = left; j = right; while (i &lt; j) &#123; while (i &lt; j &amp;&amp; a[j] &lt;= temp) j--; a[i] = a[j]; while (i &lt; j &amp;&amp; a[i] &gt;= temp) i++; a[j] = a[i]; &#125; a[i] = temp; if (i &lt; n) &#123; quicksort(a, i+1, right, n); &#125; else if (i &gt; n) &#123; quicksort(a, left, i - 1, n); &#125; else &#123; sort(a.begin()+left, a.begin()+i+1, cmp); &#125;&#125;int kthLargestElement(int n, vector&lt;int&gt;&amp; nums)&#123; int l, r; l = 0; r = nums.size() - 1; n--; quicksort(nums, l, r, n); return nums[n];&#125;&#125;;","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E6%8E%92%E5%BA%8F/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"翻转链表","slug":"翻转链表","date":"2020-06-18T15:57:14.000Z","updated":"2022-09-29T11:37:32.408Z","comments":true,"path":"2020/06/18/翻转链表/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/06/18/%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/","excerpt":"","text":"翻转链表中第m个节点到第n个节点的部分样例例1:输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4,输出: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL. 例2:输入: 1-&gt;2-&gt;3-&gt;4-&gt;NULL, m = 2 and n = 3,输出: 1-&gt;3-&gt;2-&gt;4-&gt;NULL. 挑战Reverse it in-place and in one-pass 注意事项m，n满足1 ≤ m ≤ n ≤ 链表长度 源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * Definition of singly-linked-list: * class ListNode &#123; * public: * int val; * ListNode *next; * ListNode(int val) &#123; * this-&gt;val = val; * this-&gt;next = NULL; * &#125; * &#125; */class Solution &#123;public: /** * @param head: ListNode head is the head of the linked list * @param m: An integer * @param n: An integer * @return: The head of the reversed ListNode */ ListNode * reverseBetween(ListNode * head, int m, int n) &#123; // write your code here ListNode * p1,*psre,*pere,*ps,*pe,*penext; if(m==n)return head; p1=head; pe=ps=p1; if(p1-&gt;next!=NULL) for(int i=1;p1!=NULL;i++,p1=p1-&gt;next)&#123; if(i==m)&#123; ps=p1; &#125; if(i==n)&#123; pe=p1; &#125; if(i&lt;m)&#123; psre=p1; &#125; if(i&lt;n)&#123; pere=p1; &#125; &#125; // if(p1-&gt;next!=NULL) penext=pe-&gt;next; if(m!=1) psre-&gt;next=pe; else&#123; head=pe; &#125; ListNode *tp,*tpnext,*temp; tp=ps; if(head-&gt;next!=NULL)&#123; tpnext=ps-&gt;next; ps-&gt;next=penext; &#125; if(n-m!=0)&#123; for(int i=0;i&lt;n-m;i++)&#123; temp=tpnext-&gt;next; tpnext-&gt;next=tp; tp=tpnext; tpnext=temp; &#125; &#125; return head; &#125;&#125;;","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"链表","slug":"链表","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E9%93%BE%E8%A1%A8/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"struct","slug":"struct","date":"2020-06-17T08:55:59.000Z","updated":"2022-09-29T11:37:32.407Z","comments":true,"path":"2020/06/17/struct/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/06/17/struct/","excerpt":"","text":"1.C中struct在C中struct只单纯的用作数据的复合类型，也就是说，在结构体声明中只能将数据成员放在里面，而不能将函数放在里面。在C结构体声明中不能使用C++访问修饰符，如：public、protected、private 而在C++中可以使用。在C中定义结构体变量，如果使用了下面定义必须加struct。C的结构体不能继承（没有这一概念）。若结构体的名字与函数名相同，可以正常运行且正常的调用！例如：可以定义与 struct Base 不冲突的 void Base() {}。 完整案例：1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;struct Base &#123; // public int v1; // public: //error int v2; //private: int v3; //void print()&#123; // c中不能在结构体中嵌入函数 // printf(\"%s\\n\",\"hello world\"); //&#125;; //error!&#125;;void Base()&#123; printf(\"%s\\n\",\"I am Base func\");&#125;//struct Base base1; //ok//Base base2; //errorint main() &#123; struct Base base; base.v1=1; //base.print(); printf(\"%d\\n\",base.v1); Base(); return 0;&#125; 最后输出： 1I am Base func 2.C++中struct与C对比如下：C++结构体中不仅可以定义数据，还可以定义函数。C++结构体中可以使用访问修饰符，如：public、protected、private 。C++结构体使用可以直接使用不带struct。C++继承若结构体的名字与函数名相同，可以正常运行且正常的调用！但是定义结构体变量时候只用用带struct的！例如： 情形1：不适用typedef定义结构体别名未添加同名函数前： 123456struct Student &#123;&#125;;Student()&#123;&#125;Struct Student s; //okStudent s; //ok 添加同名函数后： 123456struct Student &#123;&#125;;Student()&#123;&#125;Struct Student s; //okStudent s; //error 情形二：使用typedef定义结构体别名12345678910typedef struct Base1 &#123; int v1;// private: //error! int v3; public: //显示声明public int v2; void print()&#123; printf(\"%s\\n\",\"hello world\"); &#125;; &#125;B; //void B() {} //error! 符号 “B” 已经被定义为一个 “struct Base1” 的别名 前三种案例12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;stdio.h&gt;struct Base &#123; int v1;// private: //error! int v3; public: //显示声明public int v2; void print()&#123; printf(\"%s\\n\",\"hello world\"); &#125;; &#125;;int main() &#123; struct Base base1; //ok Base base2; //ok Base base; base.v1=1; base.v3=2; base.print(); printf(\"%d\\n\",base.v1); printf(\"%d\\n\",base.v3); return 0;&#125; 继承案例12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;stdio.h&gt;struct Base &#123; int v1;// private: //error! int v3; public: //显示声明public int v2; virtual void print()&#123; printf(\"%s\\n\",\"Base\"); &#125;; &#125;;struct Derived:Base &#123; public: int v2; void print()&#123; printf(\"%s\\n\",\"Derived\"); &#125;; &#125;;int main() &#123; Base *b=new Derived(); b-&gt;print(); return 0;&#125; 同名函数123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;stdio.h&gt;struct Base &#123; int v1;// private: //error! int v3; public: //显示声明public int v2; void print()&#123; printf(\"%s\\n\",\"hello world\"); &#125;; &#125;;typedef struct Base1 &#123; int v1;// private: //error! int v3; public: //显示声明public int v2; void print()&#123; printf(\"%s\\n\",\"hello world\"); &#125;; &#125;B;void Base()&#123; printf(\"%s\\n\",\"I am Base func\");&#125;//void B() &#123;&#125; //error! 符号 \"B\" 已经被定义为一个 \"struct Base1\" 的别名int main() &#123; struct Base base; //ok //Base base1; // error! base.v1=1; base.v3=2; base.print(); printf(\"%d\\n\",base.v1); printf(\"%d\\n\",base.v3); Base(); return 0;&#125; 3.总结C和C++中的Struct区别 C C++ 不能将函数放在结构体声明 能将函数放在结构体声明 在C结构体声明中不能使用C++访问修饰符。 public、protected、private 在C++中可以使用。 在C中定义结构体变量，如果使用了下面定义必须加struct。 可以不加struct 结构体不能继承（没有这一概念）。 可以继承 若结构体的名字与函数名相同，可以正常运行且正常的调用！ 若结构体的名字与函数名相同，使用结构体，只能使用带struct定义！ — 4.struct与class区别总的来说，struct 更适合看成是一个数据结构的实现体，class 更适合看成是一个对象的实现体。 区别:最本质的一个区别就是默认的访问控制 默认的继承访问权限。struct 是 public 的，class 是 private 的。 struct 作为数据结构的实现体，它默认的数据访问控制是 public 的，而 class 作为对象的实现体，它默认的成员变量访问控制是 private 的。","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E7%BC%96%E7%A8%8B/"},{"name":"C++","slug":"C","permalink":"https://xiao_feng_yang993.gitee.io/tags/C/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"断点调试","slug":"断点调试","date":"2020-06-16T15:17:25.000Z","updated":"2022-09-29T11:37:32.408Z","comments":true,"path":"2020/06/16/断点调试/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/06/16/%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/","excerpt":"","text":"1. Visual studio断点调试测试代码：123456789101112131415161718192021int add(int a, int b)&#123; int c = a + b; return c;&#125;int main()&#123; int i = 0; int val,t; int* ans; ans = (int*)malloc(sizeof(int) * 10); for (i = 0; i &lt; 10; i++) &#123; t = i * i; val = add(t,i); ans[i] = val; &#125; return 0;&#125; 上面代码的功能是分别计算i从0到9时，计算 的值并存到ans数组里。 断点类型： 1. 指定变量条件在t=i*i语句处设置条件断点——i&gt;7 运行调试程序，程序在i=8时停了下来 t是上一轮计算的7*7=49，调试程序直接停在了i=8的情况下。 2. 指定忽略次数 将刚才的断点设置为命中8次时调试程序暂停 程序暂停时i=7（因为i=0，1，2，3，4，5，6，7）刚好时第8次命中断点，便暂停了程序 3. 数据断点 当&amp;ans[5]处的值发生修改时触发断点 运行程序，程序断点被触发,指令指针指向ans[i]=val一句的下一句。 此时i=5，ans[5]的值被赋值为30. 4. 查看堆栈信息在add函数内设置断点 查看堆栈，看到有两个栈信息，分别时main（）和add（）。当前位于add（） 局部变量信息，只有add函数里的a，b，c 点击main函数的栈，切换栈帧 再看局部变量，可以看到main函数里的局部变量。 2. Eclipse1. 指定变量条件 在t = i*i处设置条件断点，条件为i&gt;7. 运行程序，程序在断点处暂停 其局部变量i的值为8，第一次满足i&gt;7的条件。 2. 忽略次数 设置断点属性的ignore count为8，意思时忽略8次断点命中，第九次暂停 运行程序，在断点处暂停 此时变量i的值为8，忽略了前8次（i=0，1，2，3，4，5，6，7）的情况。 3. 堆栈信息与局部变量 有add函数和main函数。 此时的局部变量信息 切换栈帧，双击main栈帧 再看局部变量 此时显示的是main里的局部变量 3. Gdb1. 指定变量条件在26行也就是t=i*i处设置条件断点，条件为i&gt;7;继续运行程序 程序暂停在断点处，查看此时的变量i的值，发现i=8，刚满足i&gt;7的断点条件 2. 指定忽略次数 在26行设置断点，查看断点信息，此时有一个位于main.c的26行的断点；设置断点忽略次数为8；运行程序。程序在t=i*i处暂停下来，查看变量i的值为8,意味这忽略了8次断点（分别为i=0,1,2,3,4,5,6,7） 3. 数据断点在&amp;ans[5]数据处设置数据断点 程序暂停在ans[i]=val语句的下一行， 此时ans[5]的值已经被修改 4. 堆栈信息及局部变量当函数执行到add函数里时，采用bt命令查看栈信息，有2个栈分别是main和add 此时查看局部变量信息看到，c = 42. 切换栈帧frame 1.查看main的局部变量。 4. WinDbg1. 指定变量条件 在t=i*i语句处设置断点，当i==8时触发断点 运行程序 可以看到在debug程序的main函数的首地址+0x5e处暂停。 从局部变量信息里看到此时i=8. 2. 设置忽略次数bp debug!main+0x5e 7 表示忽略前6次，在第七次过断点时触发断点 运行程序，停于断点处。 查看局部变量信息 变量i = 6, 意思是前6次全部忽略（i=0，1，2，3，4，5），第七次过断点才触发。 3. 数据断点在ans[1]处设置数据断点，需要先运行程序知道ans[1]的地址。 第一次断点，发现ans指向地址0x0000000000e46fb0处，所以32程序的ans[1]的地址为0x0000000000e46fb0 0x4, 在此设置数据断点 ba r4 0x0000000000e46fb0+0x4 执行ans[i]=val前的监视变量 Next step Ans[1]的值被更新。 4. 堆栈信息及局部变量在add函数内设置断点，程序执行至add函数内断点处 查看堆栈信息 查看局部变量，仅有add函数内的变量 .frame切换栈帧，查看局部变量，可以看到main内的函数，且当前栈帧为main","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"调试","slug":"调试","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E8%B0%83%E8%AF%95/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"有环链表","slug":"有环链表","date":"2020-06-15T18:37:37.000Z","updated":"2022-09-29T11:37:32.408Z","comments":true,"path":"2020/06/16/有环链表/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/06/16/%E6%9C%89%E7%8E%AF%E9%93%BE%E8%A1%A8/","excerpt":"","text":"题目给定一个链表，如果链表中存在环，则返回到链表中环的起始节点，如果没有环，返回null。 样例样例 1:输入：null,no cycle输出：no cycle解释：链表为空，所以没有环存在。 样例 2:输入：-21-&gt;10-&gt;4-&gt;5，tail connects to node index 1输出：10解释：最后一个节点5指向下标为1的节点，也就是10，所以环的入口为10。 挑战不使用额外的空间 解题思路 判断有环首先创建两个指针p1和p2（在Java里就是两个对象引用），让它们同时指向这个链表的头节点。然后开始一个大循环，在循环体中，让指针p1每次向后移动1个节点，让指针p2每次向后移动2个节点，然后比较两个指针指向的节点是否相同。如果相同，则可以判断出链表有环，如果不同，则继续下一次循环 求环长度当两个指针首次相遇，证明链表有环的时候，让两个指针从相遇点继续循环前进，并统计前进的循环次数，直到两个指针第2次相遇。此时，统计出来的前进次数就是环长。因为指针p1每次走1步，指针p2每次走2步，两者的速度差是1步。当两个指针再次相遇时，p2比p1多走了整整1圈。因此，环长 = 每一次速度差 × 前进次数 = 前进次数 确定入环点那么，当两个指针首次相遇时，各自所走的距离是多少呢？指针p1一次只走1步，所走的距离是D+S1指针p2一次走2步，多走了n(n&gt;=1)整圈，所走的距离是D+S1+n(S2 +S1)。由于p2的速度是p1的2倍，所以所走距离也是p1的2倍，因此：2(D+S1 ) = D+S1+n(S1+S2 )等式经过整理得出：D = (n-1)(S1+S2) + S2也就是说，从链表头结点到入环点的距离，等于从首次相遇点绕环n-1圈再回到入环点的距离。这样一来，只要把其中一个指针放回到头节点位置，另一个指针保持在首次相遇点，两个指针都是每次向前走1步。那么，它们最终相遇的节点，就是入环节点。 源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Definition of singly-linked-list: * class ListNode &#123; * public: * int val; * ListNode *next; * ListNode(int val) &#123; * this-&gt;val = val; * this-&gt;next = NULL; * &#125; * &#125; */class Solution &#123;public: /** * @param head: The first node of linked list. * @return: The node where the cycle begins. if there is no cycle, return null */ ListNode * detectCycle(ListNode * head) &#123; // write your code here ListNode * p1,*p2; p1=p2=head; if(p1==NULL)return NULL; // if(p1==p1-&gt;next)return p1; // if(p1-&gt;next==NULL)return NULL; bool sign; sign = false; while(p2!=NULL&amp;&amp;p2-&gt;next!=NULL)&#123; p1=p1-&gt;next; p2=p2-&gt;next-&gt;next; if(p1==p2)&#123; sign=true; break; &#125; &#125; if(sign==false)&#123; return NULL; &#125; p1=head; while(p1!=p2)&#123; p1=p1-&gt;next; p2=p2-&gt;next; &#125; return p1; &#125;&#125;;","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E9%93%BE%E8%A1%A8/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"a+b位运算","slug":"a-b位运算","date":"2020-06-15T03:21:12.000Z","updated":"2022-09-29T11:37:32.407Z","comments":true,"path":"2020/06/15/a-b位运算/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/06/15/a-b%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"a+b位运算核心思想a^b(不进位加法)。(a&amp;b)&lt;&lt;1(用于表示进位的位置)。 具体步骤将上面2结果再次进行按位异或^运算，再求新的异或加法的进位表示，直到没有进位产生也就是(a&amp;b)&lt;&lt;1==0时a^b的结果即为a+b的最终结果 源码实现123456789101112131415161718192021class Solution &#123;public: /** * @param a: An integer * @param b: An integer * @return: The sum of a and b */ int aplusb(int a, int b) &#123; int c= a^b; int d = (a&amp;b)&lt;&lt;1; while(d!=0)&#123; a=c; b=d; c=a^b; d=(a&amp;b)&lt;&lt;1; &#125; return c; &#125;&#125;;","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"算法","slug":"算法","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E7%AE%97%E6%B3%95/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"AVX和AVX2学习笔记","slug":"AVX和AVX2学习笔记","date":"2020-06-14T17:19:25.000Z","updated":"2022-09-29T11:37:32.407Z","comments":true,"path":"2020/06/15/AVX和AVX2学习笔记/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/06/15/AVX%E5%92%8CAVX2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E7%BC%96%E7%A8%8B/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"寻找缺失的整数","slug":"寻找缺失的整数","date":"2020-06-14T14:31:12.000Z","updated":"2022-09-29T11:37:32.407Z","comments":true,"path":"2020/06/14/寻找缺失的整数/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/06/14/%E5%AF%BB%E6%89%BE%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B4%E6%95%B0/","excerpt":"","text":"1.题目在一个无序数组里有99个不重复的正整数，范围是1～100，唯独缺少1个1～100中的整数。如何找出这个缺失的整数？ 解答：先算出1+2+3+…+100的和，然后依次减去数组里的元素，最后得到的差值，就是那个缺失的整数。 复杂度分析假设数组长度是n，那么该解法的时间复杂度是O(n)，空间复杂度是O(1)。 2.题目一个无序数组里有若干个正整数，范围是1～100，其中99个整数都出现了偶数次 ，只有1个整数出现了奇数次 ，如何找到这个出现奇数次的整数？ 解答遍历整个数组，依次做异或运算。由于异或运算在进行位运算时，相同为0，不同为1，因此所有出现偶数次的整数都会相互抵消变成0，只有唯一出现奇数次的整数会被留下。 3.题目假设一个无序数组里有若干个正整数，范围是1～100，其中有98个整数出现了偶数次，只有2个 整数出现了奇数次，如何找到这2个出现奇数次的整数？ 解答采用分治思想，把数组分成两部分，保证每一部分都包含1个出现奇数次的整数，这样就与上一题的情况一样了。 把2个出现了奇数次的整数命名为A和B。遍历整个数组，然后依次做异或运算，进行异或运算的最终结果，等同于A和B进行异或运算的结果。在这个结果中，至少会有一个二进制位是1（如果都是0，说明A和B相等，和题目不相符）。根据这个结论，可以把原数组按照二进制的倒数第2位的不同，分成两部分，一部分的倒数第2位是0，另一部分的倒数第2位是1。由于A和B的倒数第2位不同，所以A被分配到其中一部分，B被分配到另一部分，绝不会出现A和B在同一部分，另一部分既没有A，也没有B的情况 复杂度分析假设数组长度是n，那么该解法的时间复杂度是O(n)。把数组分成两部分，并不需要借助额外的存储空间，完全可以在按二进制位分组的同时来做异或运算，所以空间复杂度仍然是O(1)。 代码实现1234567891011121314151617181920212223242526int[] findlostNum(int [] array)&#123; int result[2]=&#123;0,0&#125;; int xor=0; for(int i=0;i&lt;array.length();i++)&#123; xor^=array[i] &#125; if(xor==0) return Error; int separtor = 1; while(x==(separtor&amp;xor))&#123; separtor&lt;&lt;=1; &#125; for(int i=0;i&lt;array.length();i++)&#123; if(1==(separator&amp;array[i]))&#123; result[1]^=array[i]; &#125; else&#123; result[0]^=array[i]; &#125; &#125; return result;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"算法","slug":"算法","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E7%AE%97%E6%B3%95/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"vscode的terminal打开异常缓慢的问题","slug":"vscode的terminal打开异常缓慢的问题","date":"2020-06-11T15:39:05.000Z","updated":"2022-09-29T11:37:32.407Z","comments":true,"path":"2020/06/11/vscode的terminal打开异常缓慢的问题/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/06/11/vscode%E7%9A%84terminal%E6%89%93%E5%BC%80%E5%BC%82%E5%B8%B8%E7%BC%93%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"1.问题频现在使用了Linux的vscode后就经常发生内置terminal无法打开的问题： 2.解决无门在百度更换多个关键词查找后没有有价值的信息 3.出现转机在无边无际的搜索结果中一次偶然看到了解决方法：只要打开这项设置，就能解决问题关掉设置后，又会出现之前的问题设置信息可知：新的shells是否从vscode继承继承环境变量","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"},{"name":"vscode","slug":"vscode","permalink":"https://xiao_feng_yang993.gitee.io/tags/vscode/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"code-server 远程编辑","slug":"code-server-远程编辑","date":"2020-05-13T10:11:42.000Z","updated":"2020-06-15T07:42:16.313Z","comments":true,"path":"2020/05/13/code-server-远程编辑/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/05/13/code-server-%E8%BF%9C%E7%A8%8B%E7%BC%96%E8%BE%91/","excerpt":"","text":"1. 背景随着项目规模扩大，个人计算机已经无法满足测试需求，需要在服务器上运行项目程序。当需要对源码进行修改的时候，就非常麻烦，先下载再上传或者使用vim直接编辑，许多功能都没有。一次偶然发现了code-server这个软件，将它部署在服务器上，就可以直接在本地编辑远程文件了，而且具有vscode的所有功能。 2. 安装常见的安装方法见链接：知乎 文中提到需要下载code-server二进制包，位于github上，由于买不起代理，一直下载失败。但是在之前为Windows10里的wsl配置code-server时可以直接在wsl里./code自动下载数据包，下载源位于微软的服务器，速度快。根据这一特性，但是找了半天也没找见下载地址，索性将解压后的数据一律打包上传。安装位置位于home/.vscode-server/bin/XXXXXXXcode-server github 为本地vscode安装remote-ssh插件，设置服务器登录ip和用户名，在连接过程中会尝试自动下载数据包，由于服务器未连接到外网，下载失败，但是服务器对应目录已经创建，进到home/.vscode-server/bin/XXXXXXX下（xxxxx表示commit码）将在个人设备上打包的数据解压在此。再次连接就能正常使用了。 3.安装过程中遇到的问题 由于默认生成的.ssh/config位于home下，对于windows来说，这个目录是有权限要求的，所以在选择保存目录时选到普通目录下。 在连接过程中密码反复错误，原因是登录名错误，因为默认登录名是个人电脑用户名，而不是服务器用户名。解决方法：在setting中下面一项填写保存的config地址 版本匹配问题，这个插件还会检测客户端(vscode)和服务端(服务器)的版本是否一致, 所以还需要在 vscode 中禁用插件的自动更新.在 settings.json 添加如下行即可1\"extensions.autoUpdate\": false 或者将本地安装版本选择与服务器一致，定期同步更新 分割线2020.5.13更新采用remote-ssh的连接方式在服务器的.vscode目录下产生多个目录，难以管理。又换成了浏览器连接的方法。 3. 浏览器vscode编辑 下载2进制文件 code-server 启动服务端vscode于后台运行1nohup .&#x2F;code-server -port 8082 &gt; nohup.out 2&gt;&amp;1 &amp; 默认密码随机生成字符串。可以通过设置PASSWORD使用用户自定义密码，也可以设置auth=none免密登录（不建议） 4. 设置进程监控脚本在使用code-server过程中，偶尔会发生code-server进程意外停止的事情（多由插件造成）。每次都要重新ssh上去重启很是麻烦写一个shell脚本，来监控code-server进程是否存在，若不存在则启动进程。 12345678910111213141516171819202122232425262728293031#进程名字可修改PRO_NAME=code-serverwhile true ; do# 用ps获取$PRO_NAME进程数量 NUM=`ps aux | grep $&#123;PRO_NAME&#125; | grep -v grep |wc -l`# echo $NUM# 少于1，重启进程；start_server.sh是自写的启动脚本 if [ \"$&#123;NUM&#125;\" -lt \"1\" ];then echo \"$&#123;PRO_NAME&#125; was killed\" /home/yxf/download/code-server2.1698-vsc1.41.1-linux-x86_64/start_server.sh fi# 每隔10秒钟检测一次 sleep 10# 大于1，杀掉所有进程，重启# elif [ \"$&#123;NUM&#125;\" -gt \"1\" ];then# echo \"more than 1 $&#123;PRO_NAME&#125;,killall $&#123;PRO_NAME&#125;\"# killall -9 $PRO_NAME# $&#123;PRO_NAME&#125; -i $&#123;WLAN&#125;# fi# # kill僵尸进程# NUM_STAT=`ps aux | grep $&#123;PRO_NAME&#125; | grep T | grep -v grep | wc -l`# if [ \"$&#123;NUM_STAT&#125;\" -gt \"0\" ];then# killall -9 $&#123;PRO_NAME&#125;# $&#123;PRO_NAME&#125; -i $&#123;WLAN&#125;# fidoneexit 0 此时，如果code-server进程意外停止，10秒内就会重启 如果需要开机自启，则可以将这个监控脚本放在/etc/init.d目录下，实现开机自启动。","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"GPUDirect RDMA for openmpi","slug":"GPUDirect-RDMA-for-openmpi","date":"2020-04-10T13:41:37.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/04/10/GPUDirect-RDMA-for-openmpi/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/04/10/GPUDirect-RDMA-for-openmpi/","excerpt":"","text":"背景对于MPI跨节点项目，对GPU上的数据一般需要先cudaMemcopy到Host，再通过mpi_send出去，另一设备通过mpi_Recv到Host内存，再cudamemcopy到GPU显存，这一过程明显要费时。 1. compile openmpi with –with-cuda这一编译方法可以让openmpi对显存的数据操作，但是它只是减少了代码的书写量，从GPU到Host的数据传输在背后任然在执行。时间甚至比手写cudaMemcopy还要长。为了解决这一问题，就采用了GPUDirect RDMA 技术。openmpi run with cudaBuilding CUDA-aware Open MPIOpen MPI v1.7.4 and later have added some support to take advantage of GPUDirect RDMA on Mellanox cards. All the details about Mellanox hardware as well as software needed to get things to work can be found at the Mellanox web site. Note that to get GPUDirect RDMA support, you also need to configure your Open MPI library with CUDA 6.0.可以看到要想使用GPUDirect RDMA，任然需要对openmpi 加上cuda参数编译。 2. 查看GPUDirect RDMA 信息 To see if you have GPUDirect RDMA compiled into your library, you can check like this:12shell$ ompi_info --all | grep btl_openib_have_cuda_gdr MCA btl: informational \"btl_openib_have_cuda_gdr\" (current value: \"true\", data source: default, level: 4 tuner/basic, type: bool) To see if your OFED stack has GPUDirect RDMA support, you can check like this:12shell$ ompi_info --all | grep btl_openib_have_driver_gdr MCA btl: informational \"btl_openib_have_driver_gdr\" (current value: \"true\", data source: default, level: 4 tuner/basic, type: bool) To run with GPUDirect RDMA support, you have to enable it as it is off by default:1mpirun --mca btl_openib_want_cuda_gdr 1 ... 官网的主要介绍就是这样，但是在自己设备上测试就没这么容易了，问题出现在btl_openib_have_driver_gdr这一步，结果如下：它显示的值是false，初步判断是缺少驱动所致，问题解决过程如下：3. 安装 nv_peer_mem安装过程参考浪潮公司的专利内容：一种基于GPUDerict RDMA测试方法具体步骤如下图所示： 运行lsmod |grep nv_peer_mem检查是否安装成功 1lsmod | grep nv_peer_mem 安装后再查看btl_openib_have_driver_gdr信息就正常了这时我通过测试节点间的显存数据mpi传输，发现速度有明显提升，其中GPU-to-GPU的速度跟从Host到Host速度相差无几，测得GPU-to-GPU速度超过8GB/s，与节点内的速度处在相同数量级。由于避免了在Host内存的中转，速度提高至少50%。 其中的原理是：直接访问GPU内存，避免访问固定(pinned) CUDA主机内存时不必要的系统内存拷贝和CPU的开销，加速了与网络和存储设备之间的通信可以在同一系统中的一个GPU直接访问另一个GPU使用直接的高速DMA传输，增加了 P2P的内存访问，真正释放了主机CPU资源，消除主机了CPU中不必要的频繁数据传输，完全不参与输入的RDMA操作；包括HCA卡、GI3U卡、GI3U必备的Nvidia Driver^Nvidia CUDA toolkit，及infiniband必备的MLNX_0FED驱动外，以及一个GPU与IB卡通信的nv_peer_mem包。","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"},{"name":"cuda","slug":"cuda","permalink":"https://xiao_feng_yang993.gitee.io/tags/cuda/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"openmpi with cuda","slug":"openmpi-with-cuda","date":"2020-03-30T09:10:12.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/30/openmpi-with-cuda/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/30/openmpi-with-cuda/","excerpt":"","text":"openMPI 1.7之后的版本才支持CUDA 1.对于1.7~2.0的版本， 配置和编译、安装如下：123sudo ./configure --prefix=&lt;用户指定的openMPI的安装目录&gt; --with-cuda=&lt;cuda的include目录&gt; --with-cuda-libdir=&lt;cuda的lib64目录&gt;sudo make all install 2.openmpi-2.0以及以上版本建议安装ucx+gdrcopy来获取新的mpi功能和更好的性能 首先安装gdrcopy，这里建议安装gdrcopy-1.3版本。因为2.0版本会出现如下错误：安装gdrcopy需要四个依赖：check，check-devel，subunit，subunit-devel，注意下载可执行文件，而不是源码；下载源——RPM，遇到的问题见博客 《linux rpm 错误》 编译gdrcopy执行如下命令12make PREFIX=/public/home/asc02/yangxf/local/gdrcopy-1.3 all install./insmod.sh #root 这里不需要指定CUDA=XXX，因为makefile里的路径本身是正确的，指定了反而出现找不见cuda.h的错误。123456789101112131415PREFIX ?= /usr/localDESTLIB ?= $(PREFIX)/lib64CUDA ?= /usr/local/cudaGDRAPI_ARCH := $(shell ./config_arch)CUDA_LIB := -L $(CUDA)/lib64 -L $(CUDA)/lib -L /usr/lib64/nvidia -L /usr/lib/nvidiaCUDA_INC += -I $(CUDA)/includeCPPFLAGS := $(CUDA_INC) -I gdrdrv/ -I $(CUDA)/include -D GDRAPI_ARCH=$(GDRAPI_ARCH)LDFLAGS := $(CUDA_LIB) -L $(CUDA)/lib64COMMONCFLAGS := -O2CFLAGS += $(COMMONCFLAGS)CXXFLAGS += $(COMMONCFLAGS)LIBS := -lcudart -lcuda -lpthread -ldl 参考gdrcopy 编译ucx ucx执行命令1234./autogen.sh./configure --prefix=/public/home/asc02/yangxf/local/ucx --with-cuda=/usr/local/cuda --with-gdrcopy=/public/home/asc02/yangxf/local/gdrcopy-1.3 --with-mlx5-dv --with-avx --with-sse41 --with-sse42make -j8make install 编译openmpi这里用的是openmpi-3.0执行命令123./configure --prefix=/public/home/asc02/yangxf/local/openmpi-3.0.0 --with-cuda=/usr/local/cuda --with-ucx=/public/home/asc02/yangxf/local/ucx --enable-mpi-cxxmake -j8make install 编译安装完成，在生成的lib目录下可以看到多了关于cuda的库把相关路径添加到环境变量就可。 注： 对于多机运行的程序，需要将mpi环境变量添加到.bashrc中，否则在其他机器上确实mpi的环境变量。","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"},{"name":"cuda","slug":"cuda","permalink":"https://xiao_feng_yang993.gitee.io/tags/cuda/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"linux rpm 错误","slug":"linux-rpm-错误","date":"2020-03-29T13:27:59.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/29/linux-rpm-错误/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/29/linux-rpm-%E9%94%99%E8%AF%AF/","excerpt":"","text":"linux 使用rpm安装软件时,遇到”warning: rpmts_HdrFromFdno: Header V3 RSA/SHA256 Signature, key ID fd431d51: NOKEY” 错误建议的做法：warning: rpmts_HdrFromFdno: Header V3 RSA/SHA256 Signature, key ID fd431d51: NOKEY 网上资料说这是由于yum安装了旧版本的GPG keys造成的 1rpm --import /etc/pki/rpm-gpg/RPM* 不建议的方法如下：1、安装时提示：warning: *.rpm: Header V3 RSA/SHA256 Signature, keykey ID c105b9de: NOKEY 解决的方法就是在rpm 语句后面加上 –force –nodeps 即原本为 rpm -ivh *.rpm 现在改成 rpm -ivh *.rpm –force –nodeps就可以了。 nodeps的意思是忽视依赖关系。因为各个软件之间会有多多少少的联系。有了这两个设置选项就忽略了这些依赖关系，强制安装或者卸载 2、尝试卸载： 造成这个问题的主要原因是套件被重複 (强制) 安装了两次以上. 尝试了–nodeps, –force, –justdb都不行。 结果碰巧解决! 通过man rpm，发现–allmatches应该可以解决这个问题. [root@testserver openssl-0.9.8l]# rpm -e –allmatches –nodeps openssl* CentOS系统bash: groupadd: command not found问题如果我们需要在CentOS执行新建用户组命令的时候，需要进入到ROOT权限，如果你用以下命令： 12susu root 进入到ROOT账户，那么会出现上述的错误信息：“bash: groupadd: command not found” 这是因为执行这个两个进入ROOT命令不会把你的PATH环境变量带过去，你需要执行命令： 1su - root 这样子进入ROOT权限，执行groupadd或者useradd命令就不会有问题了。","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"Dart学习笔记（2）：数据类型","slug":"Dart学习笔记（2）：数据类型","date":"2020-03-20T04:55:13.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/20/Dart学习笔记（2）：数据类型/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/20/Dart%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"因为工作的关系，系列文章刚开始写可能就要拖稿了不管怎么样，慢慢来吧！ Dart中所有东西都是对象，包括数字、函数等它们都继承自Object，并且默认值都是null（包括数字）因此数字、字符串都可以调用各种方法 Dart中支持以下数据类型： Numbers Strings Booleans List（也就是数组） Maps 容器后面再讲，这里先说说常用的字符串和数值类型还是先建工程吧！Dart代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void main()&#123; //Dart 语言本质上是动态类型语言，类型是可选的 //可以使用 var 声明变量，也可以使用类型来声明变量 //一个变量也可以被赋予不同类型的对象 //但大多数情况，我们不会去改变一个变量的类型 //字符串赋值的时候，可以使用单引号，也可以使用双引号 var str1 = \"Ok?\"; //如果使用的是双引号，可以内嵌单引号 //当然，如果使用的是单引号，可以内嵌双引号，否则需要“\\”转义 //String str2 = ‘It\\’s ok!’; String str2 = \"It's ok!\"; //使用三个单引号或者双引号可以多行字符串赋值 var str3 = \"\"\"Dart Lang Hello,World!\"\"\"; //在Dart中，相邻的字符串在编译的时候会自动连接 //这里发现一个问题，如果多个字符串相邻，中间的字符串不能为空，否则报错 //但是如果单引号和双引号相邻，即使是空值也不会报错，但相信没有人这么做 //var name = 'Wang''''Jianfei'; 报错 var name = 'Wang'' ''Jianfei'; //assert 是语言内置的断言函数，仅在检查模式下有效 //如果断言失败则程序立刻终止 assert(name == \"Wang Jianfei\"); //Dart中字符串不支持“+”操作符，如str1 + str2 //如果要链接字符串，除了上面诉说，相邻字符串自动连接外 //还可以使用“$”插入变量的值 print(\"Name：$name\"); //声明原始字符串，直接在字符串前加字符“r” //可以避免“\\”的转义作用，在正则表达式里特别有用 print(r\"换行符：\\n\"); //Dart中数值是num，它有两个子类型：int 和 double //int是任意长度的整数，double是双精度浮点数 var hex = 0xDEADBEEF; //翻了半天的文档，才找打一个重要的函数：转换进制，英文太不过关了 //上面提到的字符串插值，还可以插入表达式：$&#123;&#125; print(\"整型转换为16进制：$hex —&gt; 0x$&#123;hex.toRadixString(16).toUpperCase()&#125;\");&#125; 注：新版本SDK已支持“+”操作符连接字符串运行结果如下：String和num有丰富的函数，这里就不一一介绍了，大家可以慢慢尝试 再聊点const和final，用法和其他语言类似在声明变量的时候，除了var，还可以使用const和final同时，在使用const和final的时候，可以省略var或者其他类型 1234567var i = 10;const i = 10;final i = 10;int i = 10;const int i = 10;final int i = 10; const和final定义的都是常量，值不能改变并且在声明的时候就必须初始化但是也有细微差别，简单来说 const定义的是编译时常量，只能用编译时常量来初始化 final定义的常量可以用变量来初始化 12final time = new DateTime.now(); //Okconst time = new DateTime.now(); //Error，new DateTime.now()不是const常量 var、final等在左边定义变量的时候，并不关心右边是不是常量但是如果右边用了const，那么不管左边如何，右边都必须是常量 123456const list = const[1,2,3];//Okconst list = [1,2,3];//Errorfinal list = [1,2,3];//Okfinal list = const[1,2,3];//Okfinal list = const[new DateTime.now(),2,3];//Error,const右边必须是常量","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"https://xiao_feng_yang993.gitee.io/tags/Dart/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"Dart学习笔记（1）：Hello，world！","slug":"Dart学习笔记（1）：Hello，world！","date":"2020-03-20T04:45:43.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/20/Dart学习笔记（1）：Hello，world！/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/20/Dart%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9AHello%EF%BC%8Cworld%EF%BC%81/","excerpt":"","text":"任何一门编程语言的第一节课基本上都会是Hello,world!估计很少有人会打破这个传统 最初官方推荐的编辑器是Dart Editor而现在已弃用，改为推荐WebStorm、Atom编辑器本站并没有提供下载链接 需要的可自行百度，查找最新版本 Dart SDK的安装非常简单， 资源下载 页面提供有墙内下载地址将zip文件解压到任意目录，并将bin目录添加至PATH环境变量即可 在新建工程的时候，WebStorm 提供有多个工程模板这里选择命令行应用编辑bin/main.dart，同C++一样，Dart程序是从main()函数开始执行的在main.dart中添加如下代码： 1234void main()&#123; print(\"Hello, world!\");&#125; 添加完之后点击工具栏的绿色运行按钮，或者dart文件右键菜单中的 Run 菜单便能够在命令行界面看到运行结果了顺带一提，Dart有 两种运行模式： 检查模式（checked）：进行类型检查，如果发现实际类型与声明或期望的类型不匹配就报错 生产模式（production）：不进行类型检查，忽略声明的类型信息，忽略 assert 语句 检查模式运行较慢，生产模式运行快但检查模式可以及早地发现程序在的问题，所以建议在开发过程中使用检查模式而在正式环境中使用生产模式运行 Dart VM 默认在生产模式下运行，而我们用 WebStorm 开发时默认在检查模式下运行通过 Run—&gt;Edit Configurations 选项可以设置使用不同的模式","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"https://xiao_feng_yang993.gitee.io/tags/Dart/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"Functors","slug":"Functors","date":"2020-03-11T16:40:09.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/12/Functors/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/12/Functors/","excerpt":"","text":"1. C++ FunctorsAlright, what is a functor?A C++ functor is a “function-object”. In other words, it is an object that can be called and treated just like a regular function. Let’s see an example. 123456789101112131415class Doubler&#123;public: void operator()(int &amp;val) const &#123; val *= 2; &#125;&#125;;Doubler d1, d2; // two instances of the Doubler classint i = 20, j = 30;d1(i); // both instances can be called asd2(j); // if they were regular functions// now i=40 and j=60 OK, so what do functors give us? LOTS! We can maintain per-instance state. We can pass functors around just like variables. Compiler optimizations (vs. function pointers)123456789101112131415class AddX&#123;public: AddX(int x) : _x(x) &#123;&#125; int operator()(const int &amp;val) const &#123; return val + _x; &#125;private: const int _x;&#125;;AddX add5(5), add10(10); // two instancesstd::cout &lt;&lt; add5(3) &lt;&lt; std::endl; // prints 8std::cout &lt;&lt; add10(3) &lt;&lt; std::endl; // prints 13 We can also pass functor instances into the STL algorithms.1234567891011121314151617181920void doubleIt(int &amp;val)&#123; val *= 2;&#125;class Doubler&#123;public: void operator()(int &amp;val) const &#123; val *= 2; &#125;&#125;;std::vector&lt;int&gt; myset(10);Doubler myDoubler;// the next two lines are functionally equivalentstd::for_each(myset.begin(), myset.end(), doubleIt);std::for_each(myset.begin(), myset.end(), myDoubler); 2. Thrust - FunctorsOK, so Thrust provides some vectors and generic algorithms for me. But what if I want to do more than just sort, count, and sum my data? Well, look at the title of the slide! - You can make your own functors and pass these into Thrust’s generic algorithms. 1234567891011121314151617181920// the next two lines are functionally equivalentstd::for_each(myset.begin(), myset.end(), doubleIt);std::for_each(myset.begin(), myset.end(), myDoubler);// calculate result[] = (a * x[]) + y[]struct saxpy&#123; const float _a; saxpy(int a) : _a(a) &#123;&#125; __host__ __device__ float operator()(const float &amp;x, const float &amp;y) const &#123; return a * x + y; &#125;&#125;;thrust::device_vector&lt;float&gt; x, y, result;// ... fill up x &amp; y vectors ...thrust::transform(x.begin(), x.end(), y.begin(), result.begin(), saxpy(a)); 12345678910struct saxpy&#123; const float _a; saxpy(int a) : _a(a) &#123;&#125; __host__ __device__ float operator()(const float &amp;x, const float &amp;y) const &#123; return a * x + y; &#125;&#125;; Let’s look more at that. The operator() function is prefixed with host device. This is CUDA compiler notation, but to Thrust it means that it can be called with a host_vector OR device_vector. Also notice that in this form of programming you don’t need to worry about threadIdx and blockIdx index calculations in the kernel code. You can just focus on what needs to happen to each element. There are many excellent Thrust examples (including this saxpy one) in the installed distribution and online.","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://xiao_feng_yang993.gitee.io/tags/C/"},{"name":"thrust","slug":"thrust","permalink":"https://xiao_feng_yang993.gitee.io/tags/thrust/"},{"name":"cuda","slug":"cuda","permalink":"https://xiao_feng_yang993.gitee.io/tags/cuda/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"GCC离线升级","slug":"GCC离线升级","date":"2020-03-10T09:48:38.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/10/GCC离线升级/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/10/GCC%E7%A6%BB%E7%BA%BF%E5%8D%87%E7%BA%A7/","excerpt":"","text":"1. 下载gcc安装包 gcc选择自己想要的版本并下载我下载的是7.5.0版本.然后解压。 打开contrib/download_prerequisites查看依赖可以看到这里要求了四个依赖包：gmp，mpc，mpfr，isl。下载的版本可以不是最新版，但是不能太旧，一般从现在往后退几代就可以了，具体要求gcc的configure时会说明。额外注意如果采用tree编译法要求mpc&gt;=1.0.3。 2. 安装准备与配置 下载完成后，将gmp、mpfr、mpc、isl安装放到cd /usr/local/gcc-7.1.0目录下并解压： tar -xf gmp-6.1.0.tar.bz2 tar -xf mpfr-3.1.4.tar.bz2 tar -xf mpc-1.0.3.tar.gz tar -xf isl-0.16.1.tar.bz2 建立软连接： ln -sf gmp-6.1.0 gmp ln -sf mpfr-3.1.4 mpfr ln -sf mpc-1.0.3 mpc ln -sf isl-0.16.1 isl 3. 编译安装： 创建build目录，不要在源码root目录下直接build，否则无法进行树形编译 编译命令 123..&#x2F;configure --prefix&#x3D;xxx -enable-checking&#x3D;release -enable-languages&#x3D;c,c++ -disable-multilibmake -jmake install #安装到指定的prefix目录下 4. 其他编译方式 如果不采用tree编译的方式，那么需要分别编译这几个依赖包，而且顺序固定，依次编译。 gmp安装： tar jxf gmp-4.3.2.tar.bz2 cd gmp-4.3.2 ./configure –prefix=/usr/local/gmp-4.3.2 &amp;&amp; make make install mpfr安装： tar jxf mpfr-2.4.2.tar.bz2 cd mpfr-2.4.2 ./configure –prefix=/usr/local/mpfr-2.4.2 –with-gmp=/usr/local/gmp-4.3.2 &amp;&amp; make make install mpc安装： tar zxvfv mpc-1.0.1.tar.gz cd mpc-1.0.1 ./configure –prefix=/usr/local/mpc-1.0.1 –with-gmp=/usr/local/gmp-4.3.2 –with-mpfr=/usr/local/mpfr-2.4.2 &amp;&amp; make make install 添加环境变量 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/gmp-4.3.2/lib:/usr/local/mpc-1.0.1/lib:/usr/local/mpfr-2.4.2/lib 安装gcc-5.4.0 tar -xzvf gcc-5.4.0.tar.gz cd gcc-5.4.0 mkdir gcc-build //创建编译目录 cd gcc-build ../configure –prefix=/usr/local/gcc-5.4.0 –enable-threads=posix –disable-checking –disable-multilib –enable-languages=c,c++ –with-gmp=/usr/local/gmp-4.3.2 –with-mpfr=/usr/local/mpfr-2.4.2 –with-mpc=/usr/local/mpc-1.0.1 //执行配置 make -j4 //多核编译，过程极其漫长～～～ make install 这种方式我在编译gcc的时候失败了。还是tree编译方法方便","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"},{"name":"gcc","slug":"gcc","permalink":"https://xiao_feng_yang993.gitee.io/tags/gcc/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"Android x86尝鲜记录","slug":"Android-x86尝鲜记录","date":"2020-03-09T09:44:36.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/09/Android-x86尝鲜记录/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/09/Android-x86%E5%B0%9D%E9%B2%9C%E8%AE%B0%E5%BD%95/","excerpt":"","text":"1. 下载系统镜像包Androidx86_64 9.0百度搜索出的镜像站位于香港，下载速度比较慢。想到国内也有类似的镜像源——清华镜像源，就去找了找，起初并没有找见Androidx86。索性安卓香港镜像来按图索骥，先进到osdn目录，结果跟平常页面不一样OSDN。里面的链接点击后会直接跳转到OSDN官网，跑到了国外。跟加速的理念不符。在香港的镜像站目录逐步回退，也是这个样子，毫无头绪。不经意间突然想到，为何不直接把香港站的后续路径直接复制过来看是什么情况？说干就干，结果就找见了位于清华镜像站的文件Android x86；根据不同的版本号选择自己需要下载的版本，下载下来就可以进行安装。我选择了最新版的64位安装包 2. 安装操作系统Android x86的安装与一般的Linux安装没有什么区别，都是那么个流程选择installation，选择安装盘即可。然后重启，重启画面如下： 运行界面：所有应用： 3. 尝试使用(1) 在浏览器下载了QQ，安装运行无大碍(2) 安装腾讯会议，卡在启动界面无法进入(3) 安装和平精英游戏，无法运行(4) 安装淘宝可正常运行(5) 不能拨打电话发短信 4. 总结Androidx86下无法运行多数应用，跟手机在兼容性无法相提并论。但是性能要好，安装应用速度非常快。用了几个小时就卸载了，装回deepin。","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"},{"name":"Android","slug":"Android","permalink":"https://xiao_feng_yang993.gitee.io/tags/Android/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"ubuntu与windows时间同步","slug":"ubuntu与windows双系统时间同步","date":"2020-03-07T11:57:27.000Z","updated":"2020-05-03T14:20:38.528Z","comments":true,"path":"2020/03/07/ubuntu与windows双系统时间同步/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/07/ubuntu%E4%B8%8Ewindows%E5%8F%8C%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/","excerpt":"","text":"@TOC注：本教程不研究系统计时原理，只简单解决问题，不修改系统核心设置，安全快速解决问题。网络上他人的博客已近提出了专业解决方案，大家可前往查看，在此不做重复。https://blog.csdn.net/zero_hzz/article/details/79205037 相信装了windows与ubuntu双系统的用户都会遇见一个问题，那就是两个系统的时间不同步，相差8小时。网上的修改教程复杂难懂，对于阅读困难症患者着实不易。本人在实践中发现一个新的简单解决方案，在此分享给大家，即使你没有任何计算机基础，也能快速解决问题。 windows与ubuntu时间相差8小时，为什么是8小时而不是其他时间？具体原因详见文章开头链接。这个时候想到我们所学地理知识，中国就处在东8区。我们的电脑安装 是也默认了中国区：这个时候在回看我们遇到的时间不同步问题，相信聪明的大家已经想到解决办法了，解决办法就是在时间设置中将我们的电脑设置成0时区，来抵消时间差，这样便解决了windows与ubuntu的时间问题。 哈哈哈，是不是非常简单呢？如果你只是简单使用ubuntu这样设置就已经可以了，要是准备深入学习还是建议用专业的方法来解决这个问题。","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"},{"name":"time synchronization","slug":"time-synchronization","permalink":"https://xiao_feng_yang993.gitee.io/tags/time-synchronization/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"给linux终端设置代理","slug":"linux下为终端设置代理","date":"2020-03-07T09:35:36.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/07/linux下为终端设置代理/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/07/linux%E4%B8%8B%E4%B8%BA%E7%BB%88%E7%AB%AF%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/","excerpt":"","text":"在安装showdsocks的情况下，浏览器就可以正常实现通过代理访问了，但是对于linux用户来说，终端是个常用的工具，如何给终端设置代理让终端也能通过代理进行访问呢？ 1. curl，wget这俩是常用的命令，实现代理的方式是 （1）安装polipo1sudo apt-get install polipo （2）配置 polipo1sudo vim &#x2F;etc&#x2F;polipo&#x2F;config 在它的末尾添加以下命令，或者去掉以下命令前面的注释符号；若此文件不存在，则自己创建 12socksParentProxy &#x3D; &quot;localhost:1080&quot;socksProxyType &#x3D; socks5 （3）重新启动 polipo 服务1sudo systemctl restart polipo.service 查看状态 1sudo systemctl status polipo.service 得到类似如下结果 1234567891011121314polipo.service - LSB: Start or stop the polipo web cache Loaded: loaded (&#x2F;etc&#x2F;init.d&#x2F;polipo; generated; vendor preset: enabled) Active: active (running) since Tue 2019-12-03 03:24:15 CST; 34min ago Docs: man:systemd-sysv-generator(8) Process: 4799 ExecStop&#x3D;&#x2F;etc&#x2F;init.d&#x2F;polipo stop (code&#x3D;exited, status&#x3D;0&#x2F;SUCCESS) Process: 4806 ExecStart&#x3D;&#x2F;etc&#x2F;init.d&#x2F;polipo start (code&#x3D;exited, status&#x3D;0&#x2F;SUCCESS) Tasks: 1 (limit: 4915) CGroup: &#x2F;system.slice&#x2F;polipo.service └─4817 &#x2F;usr&#x2F;bin&#x2F;polipo -c &#x2F;etc&#x2F;polipo&#x2F;config pidFile&#x3D;&#x2F;var&#x2F;run&#x2F;polipo&#x2F;polipo.pid daemonise&#x3D;true12月 03 03:24:15 systemd[1]: Starting LSB: Start or stop the polipo web cache...12月 03 03:24:15 polipo[4817]: Established listening socket on port 8123.12月 03 03:24:15 polipo[4806]: Starting polipo: polipo.12月 03 03:24:15 systemd[1]: Started LSB: Start or stop the polipo web cache. （4）终端设置代理环境，如果想长期生效的那么在 .zshrc 或者 .bashrc 下增加12export http_proxy&#x3D;http:&#x2F;&#x2F;localhost:8123 export https_proxy&#x3D;http:&#x2F;&#x2F;localhost:8123 polipo 的默认端口时 8123 这时wget和curl都可以通过代理实现访问了，但是想要通过apt安装软件却任然不行 2. apt在apt的配置文件目录下创建代理配置文件： 123sudo vim &#x2F;etc&#x2F;apt&#x2F;apt.conf.d&#x2F;10proxy #这个文件正常不存在，会新建一个#编辑内容为：Acquire::http::Proxy &quot;http:&#x2F;&#x2F;localhost:8123&quot;; 退出终端，重新打开。此时便可以通过代理使用apt安装软件了。 3. gitgit是软件从业者常用的一个软件，世界上最大的开源社区github由于服务器在国外，下载速度非常慢，常常需要使用代理服务。 设置代理 123git config --global https.proxy http:&#x2F;&#x2F;localhost:8123git config --global https.proxy https:&#x2F;&#x2F;localhost:8123 取消代理 123git config --global --unset http.proxygit config --global --unset https.proxy 测试效果参考：[https://www.cnblogs.com/andrewwang/p/9293031.html]","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"},{"name":"proxy","slug":"proxy","permalink":"https://xiao_feng_yang993.gitee.io/tags/proxy/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-03-07T09:09:09.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/07/hello-world/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://xiao_feng_yang993.gitee.io/tags/hexo/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]}]}