{"meta":{"title":"yangxiaofeng的博客","subtitle":"","description":"","author":"yangxiaofeng","url":"https://xiao_feng_yang993.gitee.io"},"pages":[{"title":"categories","date":"2020-03-08T11:36:25.013Z","updated":"2020-03-08T05:44:26.852Z","comments":true,"path":"categories/index.html","permalink":"https://xiao_feng_yang993.gitee.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-08T05:48:13.194Z","updated":"2020-03-08T05:48:13.194Z","comments":true,"path":"tags/index.html","permalink":"https://xiao_feng_yang993.gitee.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"a+b位运算","slug":"a-b位运算","date":"2020-06-15T03:21:12.000Z","updated":"2020-06-15T07:41:48.492Z","comments":true,"path":"2020/06/15/a-b位运算/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/06/15/a-b%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"a+b位运算核心思想a^b(不进位加法)。(a&amp;b)&lt;&lt;1(用于表示进位的位置)。 具体步骤将上面2结果再次进行按位异或^运算，再求新的异或加法的进位表示，直到没有进位产生也就是(a&amp;b)&lt;&lt;1==0时a^b的结果即为a+b的最终结果 源码实现123456789101112131415161718192021class Solution &#123;public: /** * @param a: An integer * @param b: An integer * @return: The sum of a and b */ int aplusb(int a, int b) &#123; int c= a^b; int d = (a&amp;b)&lt;&lt;1; while(d!=0)&#123; a=c; b=d; c=a^b; d=(a&amp;b)&lt;&lt;1; &#125; return c; &#125;&#125;;","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"算法","slug":"算法","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E7%AE%97%E6%B3%95/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"AVX和AVX2学习笔记","slug":"AVX和AVX2学习笔记","date":"2020-06-14T17:19:25.000Z","updated":"2020-06-14T17:19:25.921Z","comments":true,"path":"2020/06/15/AVX和AVX2学习笔记/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/06/15/AVX%E5%92%8CAVX2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E7%BC%96%E7%A8%8B/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"寻找缺失的整数","slug":"寻找缺失的整数","date":"2020-06-14T14:31:12.000Z","updated":"2020-06-15T07:42:04.375Z","comments":true,"path":"2020/06/14/寻找缺失的整数/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/06/14/%E5%AF%BB%E6%89%BE%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B4%E6%95%B0/","excerpt":"","text":"1.题目在一个无序数组里有99个不重复的正整数，范围是1～100，唯独缺少1个1～100中的整数。如何找出这个缺失的整数？ 解答：先算出1+2+3+…+100的和，然后依次减去数组里的元素，最后得到的差值，就是那个缺失的整数。 复杂度分析假设数组长度是n，那么该解法的时间复杂度是O(n)，空间复杂度是O(1)。 2.题目一个无序数组里有若干个正整数，范围是1～100，其中99个整数都出现了偶数次 ，只有1个整数出现了奇数次 ，如何找到这个出现奇数次的整数？ 解答遍历整个数组，依次做异或运算。由于异或运算在进行位运算时，相同为0，不同为1，因此所有出现偶数次的整数都会相互抵消变成0，只有唯一出现奇数次的整数会被留下。 3.题目假设一个无序数组里有若干个正整数，范围是1～100，其中有98个整数出现了偶数次，只有2个 整数出现了奇数次，如何找到这2个出现奇数次的整数？ 解答采用分治思想，把数组分成两部分，保证每一部分都包含1个出现奇数次的整数，这样就与上一题的情况一样了。 把2个出现了奇数次的整数命名为A和B。遍历整个数组，然后依次做异或运算，进行异或运算的最终结果，等同于A和B进行异或运算的结果。在这个结果中，至少会有一个二进制位是1（如果都是0，说明A和B相等，和题目不相符）。根据这个结论，可以把原数组按照二进制的倒数第2位的不同，分成两部分，一部分的倒数第2位是0，另一部分的倒数第2位是1。由于A和B的倒数第2位不同，所以A被分配到其中一部分，B被分配到另一部分，绝不会出现A和B在同一部分，另一部分既没有A，也没有B的情况 复杂度分析假设数组长度是n，那么该解法的时间复杂度是O(n)。把数组分成两部分，并不需要借助额外的存储空间，完全可以在按二进制位分组的同时来做异或运算，所以空间复杂度仍然是O(1)。 代码实现1234567891011121314151617181920212223242526int[] findlostNum(int [] array)&#123; int result[2]=&#123;0,0&#125;; int xor=0; for(int i=0;i&lt;array.length();i++)&#123; xor^=array[i] &#125; if(xor==0) return Error; int separtor = 1; while(x==(separtor&amp;xor))&#123; separtor&lt;&lt;=1; &#125; for(int i=0;i&lt;array.length();i++)&#123; if(1==(separator&amp;array[i]))&#123; result[1]^=array[i]; &#125; else&#123; result[0]^=array[i]; &#125; &#125; return result;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"位运算","slug":"位运算","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"算法","slug":"算法","permalink":"https://xiao_feng_yang993.gitee.io/tags/%E7%AE%97%E6%B3%95/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"vscode的terminal打开异常缓慢的问题","slug":"vscode的terminal打开异常缓慢的问题","date":"2020-06-11T15:39:05.000Z","updated":"2020-06-11T15:40:24.158Z","comments":true,"path":"2020/06/11/vscode的terminal打开异常缓慢的问题/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/06/11/vscode%E7%9A%84terminal%E6%89%93%E5%BC%80%E5%BC%82%E5%B8%B8%E7%BC%93%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"1.问题频现在使用了Linux的vscode后就经常发生内置terminal无法打开的问题： 2.解决无门在百度更换多个关键词查找后没有有价值的信息 3.出现转机在无边无际的搜索结果中一次偶然看到了解决方法：只要打开这项设置，就能解决问题关掉设置后，又会出现之前的问题设置信息可知：新的shells是否从vscode继承继承环境变量","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"},{"name":"vscode","slug":"vscode","permalink":"https://xiao_feng_yang993.gitee.io/tags/vscode/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"code-server 远程编辑","slug":"code-server-远程编辑","date":"2020-05-13T10:11:42.000Z","updated":"2020-06-15T07:42:16.313Z","comments":true,"path":"2020/05/13/code-server-远程编辑/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/05/13/code-server-%E8%BF%9C%E7%A8%8B%E7%BC%96%E8%BE%91/","excerpt":"","text":"1. 背景随着项目规模扩大，个人计算机已经无法满足测试需求，需要在服务器上运行项目程序。当需要对源码进行修改的时候，就非常麻烦，先下载再上传或者使用vim直接编辑，许多功能都没有。一次偶然发现了code-server这个软件，将它部署在服务器上，就可以直接在本地编辑远程文件了，而且具有vscode的所有功能。 2. 安装常见的安装方法见链接：知乎 文中提到需要下载code-server二进制包，位于github上，由于买不起代理，一直下载失败。但是在之前为Windows10里的wsl配置code-server时可以直接在wsl里./code自动下载数据包，下载源位于微软的服务器，速度快。根据这一特性，但是找了半天也没找见下载地址，索性将解压后的数据一律打包上传。安装位置位于home/.vscode-server/bin/XXXXXXXcode-server github 为本地vscode安装remote-ssh插件，设置服务器登录ip和用户名，在连接过程中会尝试自动下载数据包，由于服务器未连接到外网，下载失败，但是服务器对应目录已经创建，进到home/.vscode-server/bin/XXXXXXX下（xxxxx表示commit码）将在个人设备上打包的数据解压在此。再次连接就能正常使用了。 3.安装过程中遇到的问题 由于默认生成的.ssh/config位于home下，对于windows来说，这个目录是有权限要求的，所以在选择保存目录时选到普通目录下。 在连接过程中密码反复错误，原因是登录名错误，因为默认登录名是个人电脑用户名，而不是服务器用户名。解决方法：在setting中下面一项填写保存的config地址 版本匹配问题，这个插件还会检测客户端(vscode)和服务端(服务器)的版本是否一致, 所以还需要在 vscode 中禁用插件的自动更新.在 settings.json 添加如下行即可1\"extensions.autoUpdate\": false 或者将本地安装版本选择与服务器一致，定期同步更新 分割线2020.5.13更新采用remote-ssh的连接方式在服务器的.vscode目录下产生多个目录，难以管理。又换成了浏览器连接的方法。 3. 浏览器vscode编辑 下载2进制文件 code-server 启动服务端vscode于后台运行1nohup .&#x2F;code-server -port 8082 &gt; nohup.out 2&gt;&amp;1 &amp; 默认密码随机生成字符串。可以通过设置PASSWORD使用用户自定义密码，也可以设置auth=none免密登录（不建议） 4. 设置进程监控脚本在使用code-server过程中，偶尔会发生code-server进程意外停止的事情（多由插件造成）。每次都要重新ssh上去重启很是麻烦写一个shell脚本，来监控code-server进程是否存在，若不存在则启动进程。 12345678910111213141516171819202122232425262728293031#进程名字可修改PRO_NAME=code-serverwhile true ; do# 用ps获取$PRO_NAME进程数量 NUM=`ps aux | grep $&#123;PRO_NAME&#125; | grep -v grep |wc -l`# echo $NUM# 少于1，重启进程；start_server.sh是自写的启动脚本 if [ \"$&#123;NUM&#125;\" -lt \"1\" ];then echo \"$&#123;PRO_NAME&#125; was killed\" /home/yxf/download/code-server2.1698-vsc1.41.1-linux-x86_64/start_server.sh fi# 每隔10秒钟检测一次 sleep 10# 大于1，杀掉所有进程，重启# elif [ \"$&#123;NUM&#125;\" -gt \"1\" ];then# echo \"more than 1 $&#123;PRO_NAME&#125;,killall $&#123;PRO_NAME&#125;\"# killall -9 $PRO_NAME# $&#123;PRO_NAME&#125; -i $&#123;WLAN&#125;# fi# # kill僵尸进程# NUM_STAT=`ps aux | grep $&#123;PRO_NAME&#125; | grep T | grep -v grep | wc -l`# if [ \"$&#123;NUM_STAT&#125;\" -gt \"0\" ];then# killall -9 $&#123;PRO_NAME&#125;# $&#123;PRO_NAME&#125; -i $&#123;WLAN&#125;# fidoneexit 0 此时，如果code-server进程意外停止，10秒内就会重启 如果需要开机自启，则可以将这个监控脚本放在/etc/init.d目录下，实现开机自启动。","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"GPUDirect RDMA for openmpi","slug":"GPUDirect-RDMA-for-openmpi","date":"2020-04-10T13:41:37.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/04/10/GPUDirect-RDMA-for-openmpi/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/04/10/GPUDirect-RDMA-for-openmpi/","excerpt":"","text":"背景对于MPI跨节点项目，对GPU上的数据一般需要先cudaMemcopy到Host，再通过mpi_send出去，另一设备通过mpi_Recv到Host内存，再cudamemcopy到GPU显存，这一过程明显要费时。 1. compile openmpi with –with-cuda这一编译方法可以让openmpi对显存的数据操作，但是它只是减少了代码的书写量，从GPU到Host的数据传输在背后任然在执行。时间甚至比手写cudaMemcopy还要长。为了解决这一问题，就采用了GPUDirect RDMA 技术。openmpi run with cudaBuilding CUDA-aware Open MPIOpen MPI v1.7.4 and later have added some support to take advantage of GPUDirect RDMA on Mellanox cards. All the details about Mellanox hardware as well as software needed to get things to work can be found at the Mellanox web site. Note that to get GPUDirect RDMA support, you also need to configure your Open MPI library with CUDA 6.0.可以看到要想使用GPUDirect RDMA，任然需要对openmpi 加上cuda参数编译。 2. 查看GPUDirect RDMA 信息 To see if you have GPUDirect RDMA compiled into your library, you can check like this:12shell$ ompi_info --all | grep btl_openib_have_cuda_gdr MCA btl: informational \"btl_openib_have_cuda_gdr\" (current value: \"true\", data source: default, level: 4 tuner/basic, type: bool) To see if your OFED stack has GPUDirect RDMA support, you can check like this:12shell$ ompi_info --all | grep btl_openib_have_driver_gdr MCA btl: informational \"btl_openib_have_driver_gdr\" (current value: \"true\", data source: default, level: 4 tuner/basic, type: bool) To run with GPUDirect RDMA support, you have to enable it as it is off by default:1mpirun --mca btl_openib_want_cuda_gdr 1 ... 官网的主要介绍就是这样，但是在自己设备上测试就没这么容易了，问题出现在btl_openib_have_driver_gdr这一步，结果如下：它显示的值是false，初步判断是缺少驱动所致，问题解决过程如下：3. 安装 nv_peer_mem安装过程参考浪潮公司的专利内容：一种基于GPUDerict RDMA测试方法具体步骤如下图所示： 运行lsmod |grep nv_peer_mem检查是否安装成功 1lsmod | grep nv_peer_mem 安装后再查看btl_openib_have_driver_gdr信息就正常了这时我通过测试节点间的显存数据mpi传输，发现速度有明显提升，其中GPU-to-GPU的速度跟从Host到Host速度相差无几，测得GPU-to-GPU速度超过8GB/s，与节点内的速度处在相同数量级。由于避免了在Host内存的中转，速度提高至少50%。 其中的原理是：直接访问GPU内存，避免访问固定(pinned) CUDA主机内存时不必要的系统内存拷贝和CPU的开销，加速了与网络和存储设备之间的通信可以在同一系统中的一个GPU直接访问另一个GPU使用直接的高速DMA传输，增加了 P2P的内存访问，真正释放了主机CPU资源，消除主机了CPU中不必要的频繁数据传输，完全不参与输入的RDMA操作；包括HCA卡、GI3U卡、GI3U必备的Nvidia Driver^Nvidia CUDA toolkit，及infiniband必备的MLNX_0FED驱动外，以及一个GPU与IB卡通信的nv_peer_mem包。","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"},{"name":"cuda","slug":"cuda","permalink":"https://xiao_feng_yang993.gitee.io/tags/cuda/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"openmpi with cuda","slug":"openmpi-with-cuda","date":"2020-03-30T09:10:12.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/30/openmpi-with-cuda/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/30/openmpi-with-cuda/","excerpt":"","text":"openMPI 1.7之后的版本才支持CUDA 1.对于1.7~2.0的版本， 配置和编译、安装如下：123sudo ./configure --prefix=&lt;用户指定的openMPI的安装目录&gt; --with-cuda=&lt;cuda的include目录&gt; --with-cuda-libdir=&lt;cuda的lib64目录&gt;sudo make all install 2.openmpi-2.0以及以上版本建议安装ucx+gdrcopy来获取新的mpi功能和更好的性能 首先安装gdrcopy，这里建议安装gdrcopy-1.3版本。因为2.0版本会出现如下错误：安装gdrcopy需要四个依赖：check，check-devel，subunit，subunit-devel，注意下载可执行文件，而不是源码；下载源——RPM，遇到的问题见博客 《linux rpm 错误》 编译gdrcopy执行如下命令12make PREFIX=/public/home/asc02/yangxf/local/gdrcopy-1.3 all install./insmod.sh #root 这里不需要指定CUDA=XXX，因为makefile里的路径本身是正确的，指定了反而出现找不见cuda.h的错误。123456789101112131415PREFIX ?= /usr/localDESTLIB ?= $(PREFIX)/lib64CUDA ?= /usr/local/cudaGDRAPI_ARCH := $(shell ./config_arch)CUDA_LIB := -L $(CUDA)/lib64 -L $(CUDA)/lib -L /usr/lib64/nvidia -L /usr/lib/nvidiaCUDA_INC += -I $(CUDA)/includeCPPFLAGS := $(CUDA_INC) -I gdrdrv/ -I $(CUDA)/include -D GDRAPI_ARCH=$(GDRAPI_ARCH)LDFLAGS := $(CUDA_LIB) -L $(CUDA)/lib64COMMONCFLAGS := -O2CFLAGS += $(COMMONCFLAGS)CXXFLAGS += $(COMMONCFLAGS)LIBS := -lcudart -lcuda -lpthread -ldl 参考gdrcopy 编译ucx ucx执行命令1234./autogen.sh./configure --prefix=/public/home/asc02/yangxf/local/ucx --with-cuda=/usr/local/cuda --with-gdrcopy=/public/home/asc02/yangxf/local/gdrcopy-1.3 --with-mlx5-dv --with-avx --with-sse41 --with-sse42make -j8make install 编译openmpi这里用的是openmpi-3.0执行命令123./configure --prefix=/public/home/asc02/yangxf/local/openmpi-3.0.0 --with-cuda=/usr/local/cuda --with-ucx=/public/home/asc02/yangxf/local/ucx --enable-mpi-cxxmake -j8make install 编译安装完成，在生成的lib目录下可以看到多了关于cuda的库把相关路径添加到环境变量就可。 注： 对于多机运行的程序，需要将mpi环境变量添加到.bashrc中，否则在其他机器上确实mpi的环境变量。","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"},{"name":"cuda","slug":"cuda","permalink":"https://xiao_feng_yang993.gitee.io/tags/cuda/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"linux rpm 错误","slug":"linux-rpm-错误","date":"2020-03-29T13:27:59.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/29/linux-rpm-错误/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/29/linux-rpm-%E9%94%99%E8%AF%AF/","excerpt":"","text":"linux 使用rpm安装软件时,遇到”warning: rpmts_HdrFromFdno: Header V3 RSA/SHA256 Signature, key ID fd431d51: NOKEY” 错误建议的做法：warning: rpmts_HdrFromFdno: Header V3 RSA/SHA256 Signature, key ID fd431d51: NOKEY 网上资料说这是由于yum安装了旧版本的GPG keys造成的 1rpm --import /etc/pki/rpm-gpg/RPM* 不建议的方法如下：1、安装时提示：warning: *.rpm: Header V3 RSA/SHA256 Signature, keykey ID c105b9de: NOKEY 解决的方法就是在rpm 语句后面加上 –force –nodeps 即原本为 rpm -ivh *.rpm 现在改成 rpm -ivh *.rpm –force –nodeps就可以了。 nodeps的意思是忽视依赖关系。因为各个软件之间会有多多少少的联系。有了这两个设置选项就忽略了这些依赖关系，强制安装或者卸载 2、尝试卸载： 造成这个问题的主要原因是套件被重複 (强制) 安装了两次以上. 尝试了–nodeps, –force, –justdb都不行。 结果碰巧解决! 通过man rpm，发现–allmatches应该可以解决这个问题. [root@testserver openssl-0.9.8l]# rpm -e –allmatches –nodeps openssl* CentOS系统bash: groupadd: command not found问题如果我们需要在CentOS执行新建用户组命令的时候，需要进入到ROOT权限，如果你用以下命令： 12susu root 进入到ROOT账户，那么会出现上述的错误信息：“bash: groupadd: command not found” 这是因为执行这个两个进入ROOT命令不会把你的PATH环境变量带过去，你需要执行命令： 1su - root 这样子进入ROOT权限，执行groupadd或者useradd命令就不会有问题了。","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"德国海关扣押美国3M公司口罩和防护服","slug":"德国海关扣押美国3M公司口罩和防护服","date":"2020-03-21T08:40:35.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/21/德国海关扣押美国3M公司口罩和防护服/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/21/%E5%BE%B7%E5%9B%BD%E6%B5%B7%E5%85%B3%E6%89%A3%E6%8A%BC%E7%BE%8E%E5%9B%BD3M%E5%85%AC%E5%8F%B8%E5%8F%A3%E7%BD%A9%E5%92%8C%E9%98%B2%E6%8A%A4%E6%9C%8D/","excerpt":"","text":"据《莱茵邮报》当地时间19日报道，德国海关近日没收了美国3M集团在于兴市（Jüchen）欧洲配送中心的一批防护用品，其中包括医用、实验室使用、化学生产时使用的高等级口罩和防护服，以及民用口罩，并怀疑这批货物是用来非法出口的。 德国联邦海关总署和3M集团都证实了本次查缴行动。德国克雷费尔德海关办公室的一位发言人说：“海关人员在3M集团工厂现场检查出口货物是否符合法律规定。其他所有事项均须遵守税收保密规定。3M集团的女发言人表示: “今天，门兴格拉德巴赫的海关在我们位于于兴市（Jüchen）的欧洲配送中心检查了一批登记出口到瑞士的货物。”该发言人说，据海关部门的说法，此次检查与德国目前的医疗防护设备出口限制措施有关。 安全部门消息人士向《莱茵邮报》证实，海关在检查期间没收并封存了几批防护用品。这些产品本应出口到瑞士和美国。消息人士表示，”查到的是打算非法出口的几卡车货物”。 由于新冠肺炎疫情危机，目前仅在特殊情况下才允许从欧盟出口医疗设备。根据联邦政府的说法，只有在德国的重大需求得到满足的情况下，防护设备才能出口。即使其他国家缺乏防护设备也会危及人类生命，这一点仍然适用。","categories":[{"name":"生活","slug":"生活","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"news","slug":"news","permalink":"https://xiao_feng_yang993.gitee.io/tags/news/"}],"keywords":[{"name":"生活","slug":"生活","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%94%9F%E6%B4%BB/"}]},{"title":"Dart学习笔记（2）：数据类型","slug":"Dart学习笔记（2）：数据类型","date":"2020-03-20T04:55:13.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/20/Dart学习笔记（2）：数据类型/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/20/Dart%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"因为工作的关系，系列文章刚开始写可能就要拖稿了不管怎么样，慢慢来吧！ Dart中所有东西都是对象，包括数字、函数等它们都继承自Object，并且默认值都是null（包括数字）因此数字、字符串都可以调用各种方法 Dart中支持以下数据类型： Numbers Strings Booleans List（也就是数组） Maps 容器后面再讲，这里先说说常用的字符串和数值类型还是先建工程吧！Dart代码如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647void main()&#123; //Dart 语言本质上是动态类型语言，类型是可选的 //可以使用 var 声明变量，也可以使用类型来声明变量 //一个变量也可以被赋予不同类型的对象 //但大多数情况，我们不会去改变一个变量的类型 //字符串赋值的时候，可以使用单引号，也可以使用双引号 var str1 = \"Ok?\"; //如果使用的是双引号，可以内嵌单引号 //当然，如果使用的是单引号，可以内嵌双引号，否则需要“\\”转义 //String str2 = ‘It\\’s ok!’; String str2 = \"It's ok!\"; //使用三个单引号或者双引号可以多行字符串赋值 var str3 = \"\"\"Dart Lang Hello,World!\"\"\"; //在Dart中，相邻的字符串在编译的时候会自动连接 //这里发现一个问题，如果多个字符串相邻，中间的字符串不能为空，否则报错 //但是如果单引号和双引号相邻，即使是空值也不会报错，但相信没有人这么做 //var name = 'Wang''''Jianfei'; 报错 var name = 'Wang'' ''Jianfei'; //assert 是语言内置的断言函数，仅在检查模式下有效 //如果断言失败则程序立刻终止 assert(name == \"Wang Jianfei\"); //Dart中字符串不支持“+”操作符，如str1 + str2 //如果要链接字符串，除了上面诉说，相邻字符串自动连接外 //还可以使用“$”插入变量的值 print(\"Name：$name\"); //声明原始字符串，直接在字符串前加字符“r” //可以避免“\\”的转义作用，在正则表达式里特别有用 print(r\"换行符：\\n\"); //Dart中数值是num，它有两个子类型：int 和 double //int是任意长度的整数，double是双精度浮点数 var hex = 0xDEADBEEF; //翻了半天的文档，才找打一个重要的函数：转换进制，英文太不过关了 //上面提到的字符串插值，还可以插入表达式：$&#123;&#125; print(\"整型转换为16进制：$hex —&gt; 0x$&#123;hex.toRadixString(16).toUpperCase()&#125;\");&#125; 注：新版本SDK已支持“+”操作符连接字符串运行结果如下：String和num有丰富的函数，这里就不一一介绍了，大家可以慢慢尝试 再聊点const和final，用法和其他语言类似在声明变量的时候，除了var，还可以使用const和final同时，在使用const和final的时候，可以省略var或者其他类型 1234567var i = 10;const i = 10;final i = 10;int i = 10;const int i = 10;final int i = 10; const和final定义的都是常量，值不能改变并且在声明的时候就必须初始化但是也有细微差别，简单来说 const定义的是编译时常量，只能用编译时常量来初始化 final定义的常量可以用变量来初始化 12final time = new DateTime.now(); //Okconst time = new DateTime.now(); //Error，new DateTime.now()不是const常量 var、final等在左边定义变量的时候，并不关心右边是不是常量但是如果右边用了const，那么不管左边如何，右边都必须是常量 123456const list = const[1,2,3];//Okconst list = [1,2,3];//Errorfinal list = [1,2,3];//Okfinal list = const[1,2,3];//Okfinal list = const[new DateTime.now(),2,3];//Error,const右边必须是常量","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"https://xiao_feng_yang993.gitee.io/tags/Dart/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"Dart学习笔记（1）：Hello，world！","slug":"Dart学习笔记（1）：Hello，world！","date":"2020-03-20T04:45:43.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/20/Dart学习笔记（1）：Hello，world！/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/20/Dart%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%EF%BC%9AHello%EF%BC%8Cworld%EF%BC%81/","excerpt":"","text":"任何一门编程语言的第一节课基本上都会是Hello,world!估计很少有人会打破这个传统 最初官方推荐的编辑器是Dart Editor而现在已弃用，改为推荐WebStorm、Atom编辑器本站并没有提供下载链接 需要的可自行百度，查找最新版本 Dart SDK的安装非常简单， 资源下载 页面提供有墙内下载地址将zip文件解压到任意目录，并将bin目录添加至PATH环境变量即可 在新建工程的时候，WebStorm 提供有多个工程模板这里选择命令行应用编辑bin/main.dart，同C++一样，Dart程序是从main()函数开始执行的在main.dart中添加如下代码： 1234void main()&#123; print(\"Hello, world!\");&#125; 添加完之后点击工具栏的绿色运行按钮，或者dart文件右键菜单中的 Run 菜单便能够在命令行界面看到运行结果了顺带一提，Dart有 两种运行模式： 检查模式（checked）：进行类型检查，如果发现实际类型与声明或期望的类型不匹配就报错 生产模式（production）：不进行类型检查，忽略声明的类型信息，忽略 assert 语句 检查模式运行较慢，生产模式运行快但检查模式可以及早地发现程序在的问题，所以建议在开发过程中使用检查模式而在正式环境中使用生产模式运行 Dart VM 默认在生产模式下运行，而我们用 WebStorm 开发时默认在检查模式下运行通过 Run—&gt;Edit Configurations 选项可以设置使用不同的模式","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Dart","slug":"Dart","permalink":"https://xiao_feng_yang993.gitee.io/tags/Dart/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"Functors","slug":"Functors","date":"2020-03-11T16:40:09.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/12/Functors/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/12/Functors/","excerpt":"","text":"1. C++ FunctorsAlright, what is a functor?A C++ functor is a “function-object”. In other words, it is an object that can be called and treated just like a regular function. Let’s see an example. 123456789101112131415class Doubler&#123;public: void operator()(int &amp;val) const &#123; val *= 2; &#125;&#125;;Doubler d1, d2; // two instances of the Doubler classint i = 20, j = 30;d1(i); // both instances can be called asd2(j); // if they were regular functions// now i=40 and j=60 OK, so what do functors give us? LOTS! We can maintain per-instance state. We can pass functors around just like variables. Compiler optimizations (vs. function pointers)123456789101112131415class AddX&#123;public: AddX(int x) : _x(x) &#123;&#125; int operator()(const int &amp;val) const &#123; return val + _x; &#125;private: const int _x;&#125;;AddX add5(5), add10(10); // two instancesstd::cout &lt;&lt; add5(3) &lt;&lt; std::endl; // prints 8std::cout &lt;&lt; add10(3) &lt;&lt; std::endl; // prints 13 We can also pass functor instances into the STL algorithms.1234567891011121314151617181920void doubleIt(int &amp;val)&#123; val *= 2;&#125;class Doubler&#123;public: void operator()(int &amp;val) const &#123; val *= 2; &#125;&#125;;std::vector&lt;int&gt; myset(10);Doubler myDoubler;// the next two lines are functionally equivalentstd::for_each(myset.begin(), myset.end(), doubleIt);std::for_each(myset.begin(), myset.end(), myDoubler); 2. Thrust - FunctorsOK, so Thrust provides some vectors and generic algorithms for me. But what if I want to do more than just sort, count, and sum my data? Well, look at the title of the slide! - You can make your own functors and pass these into Thrust’s generic algorithms. 1234567891011121314151617181920// the next two lines are functionally equivalentstd::for_each(myset.begin(), myset.end(), doubleIt);std::for_each(myset.begin(), myset.end(), myDoubler);// calculate result[] = (a * x[]) + y[]struct saxpy&#123; const float _a; saxpy(int a) : _a(a) &#123;&#125; __host__ __device__ float operator()(const float &amp;x, const float &amp;y) const &#123; return a * x + y; &#125;&#125;;thrust::device_vector&lt;float&gt; x, y, result;// ... fill up x &amp; y vectors ...thrust::transform(x.begin(), x.end(), y.begin(), result.begin(), saxpy(a)); 12345678910struct saxpy&#123; const float _a; saxpy(int a) : _a(a) &#123;&#125; __host__ __device__ float operator()(const float &amp;x, const float &amp;y) const &#123; return a * x + y; &#125;&#125;; Let’s look more at that. The operator() function is prefixed with host device. This is CUDA compiler notation, but to Thrust it means that it can be called with a host_vector OR device_vector. Also notice that in this form of programming you don’t need to worry about threadIdx and blockIdx index calculations in the kernel code. You can just focus on what needs to happen to each element. There are many excellent Thrust examples (including this saxpy one) in the installed distribution and online.","categories":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++","slug":"C","permalink":"https://xiao_feng_yang993.gitee.io/tags/C/"},{"name":"thrust","slug":"thrust","permalink":"https://xiao_feng_yang993.gitee.io/tags/thrust/"},{"name":"cuda","slug":"cuda","permalink":"https://xiao_feng_yang993.gitee.io/tags/cuda/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E7%BC%96%E7%A8%8B/"}]},{"title":"GCC离线升级","slug":"GCC离线升级","date":"2020-03-10T09:48:38.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/10/GCC离线升级/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/10/GCC%E7%A6%BB%E7%BA%BF%E5%8D%87%E7%BA%A7/","excerpt":"","text":"1. 下载gcc安装包 gcc选择自己想要的版本并下载我下载的是7.5.0版本.然后解压。 打开contrib/download_prerequisites查看依赖可以看到这里要求了四个依赖包：gmp，mpc，mpfr，isl。下载的版本可以不是最新版，但是不能太旧，一般从现在往后退几代就可以了，具体要求gcc的configure时会说明。额外注意如果采用tree编译法要求mpc&gt;=1.0.3。 2. 安装准备与配置 下载完成后，将gmp、mpfr、mpc、isl安装放到cd /usr/local/gcc-7.1.0目录下并解压： tar -xf gmp-6.1.0.tar.bz2 tar -xf mpfr-3.1.4.tar.bz2 tar -xf mpc-1.0.3.tar.gz tar -xf isl-0.16.1.tar.bz2 建立软连接： ln -sf gmp-6.1.0 gmp ln -sf mpfr-3.1.4 mpfr ln -sf mpc-1.0.3 mpc ln -sf isl-0.16.1 isl 3. 编译安装： 创建build目录，不要在源码root目录下直接build，否则无法进行树形编译 编译命令 123..&#x2F;configure --prefix&#x3D;xxx -enable-checking&#x3D;release -enable-languages&#x3D;c,c++ -disable-multilibmake -jmake install #安装到指定的prefix目录下 4. 其他编译方式 如果不采用tree编译的方式，那么需要分别编译这几个依赖包，而且顺序固定，依次编译。 gmp安装： tar jxf gmp-4.3.2.tar.bz2 cd gmp-4.3.2 ./configure –prefix=/usr/local/gmp-4.3.2 &amp;&amp; make make install mpfr安装： tar jxf mpfr-2.4.2.tar.bz2 cd mpfr-2.4.2 ./configure –prefix=/usr/local/mpfr-2.4.2 –with-gmp=/usr/local/gmp-4.3.2 &amp;&amp; make make install mpc安装： tar zxvfv mpc-1.0.1.tar.gz cd mpc-1.0.1 ./configure –prefix=/usr/local/mpc-1.0.1 –with-gmp=/usr/local/gmp-4.3.2 –with-mpfr=/usr/local/mpfr-2.4.2 &amp;&amp; make make install 添加环境变量 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/gmp-4.3.2/lib:/usr/local/mpc-1.0.1/lib:/usr/local/mpfr-2.4.2/lib 安装gcc-5.4.0 tar -xzvf gcc-5.4.0.tar.gz cd gcc-5.4.0 mkdir gcc-build //创建编译目录 cd gcc-build ../configure –prefix=/usr/local/gcc-5.4.0 –enable-threads=posix –disable-checking –disable-multilib –enable-languages=c,c++ –with-gmp=/usr/local/gmp-4.3.2 –with-mpfr=/usr/local/mpfr-2.4.2 –with-mpc=/usr/local/mpc-1.0.1 //执行配置 make -j4 //多核编译，过程极其漫长～～～ make install 这种方式我在编译gcc的时候失败了。还是tree编译方法方便","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"},{"name":"gcc","slug":"gcc","permalink":"https://xiao_feng_yang993.gitee.io/tags/gcc/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"Android x86尝鲜记录","slug":"Android-x86尝鲜记录","date":"2020-03-09T09:44:36.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/09/Android-x86尝鲜记录/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/09/Android-x86%E5%B0%9D%E9%B2%9C%E8%AE%B0%E5%BD%95/","excerpt":"","text":"1. 下载系统镜像包Androidx86_64 9.0百度搜索出的镜像站位于香港，下载速度比较慢。想到国内也有类似的镜像源——清华镜像源，就去找了找，起初并没有找见Androidx86。索性安卓香港镜像来按图索骥，先进到osdn目录，结果跟平常页面不一样OSDN。里面的链接点击后会直接跳转到OSDN官网，跑到了国外。跟加速的理念不符。在香港的镜像站目录逐步回退，也是这个样子，毫无头绪。不经意间突然想到，为何不直接把香港站的后续路径直接复制过来看是什么情况？说干就干，结果就找见了位于清华镜像站的文件Android x86；根据不同的版本号选择自己需要下载的版本，下载下来就可以进行安装。我选择了最新版的64位安装包 2. 安装操作系统Android x86的安装与一般的Linux安装没有什么区别，都是那么个流程选择installation，选择安装盘即可。然后重启，重启画面如下： 运行界面：所有应用： 3. 尝试使用(1) 在浏览器下载了QQ，安装运行无大碍(2) 安装腾讯会议，卡在启动界面无法进入(3) 安装和平精英游戏，无法运行(4) 安装淘宝可正常运行(5) 不能拨打电话发短信 4. 总结Androidx86下无法运行多数应用，跟手机在兼容性无法相提并论。但是性能要好，安装应用速度非常快。用了几个小时就卸载了，装回deepin。","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"},{"name":"Android","slug":"Android","permalink":"https://xiao_feng_yang993.gitee.io/tags/Android/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"ubuntu与windows时间同步","slug":"ubuntu与windows双系统时间同步","date":"2020-03-07T11:57:27.000Z","updated":"2020-05-03T14:20:38.528Z","comments":true,"path":"2020/03/07/ubuntu与windows双系统时间同步/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/07/ubuntu%E4%B8%8Ewindows%E5%8F%8C%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5/","excerpt":"","text":"@TOC注：本教程不研究系统计时原理，只简单解决问题，不修改系统核心设置，安全快速解决问题。网络上他人的博客已近提出了专业解决方案，大家可前往查看，在此不做重复。https://blog.csdn.net/zero_hzz/article/details/79205037 相信装了windows与ubuntu双系统的用户都会遇见一个问题，那就是两个系统的时间不同步，相差8小时。网上的修改教程复杂难懂，对于阅读困难症患者着实不易。本人在实践中发现一个新的简单解决方案，在此分享给大家，即使你没有任何计算机基础，也能快速解决问题。 windows与ubuntu时间相差8小时，为什么是8小时而不是其他时间？具体原因详见文章开头链接。这个时候想到我们所学地理知识，中国就处在东8区。我们的电脑安装 是也默认了中国区：这个时候在回看我们遇到的时间不同步问题，相信聪明的大家已经想到解决办法了，解决办法就是在时间设置中将我们的电脑设置成0时区，来抵消时间差，这样便解决了windows与ubuntu的时间问题。 哈哈哈，是不是非常简单呢？如果你只是简单使用ubuntu这样设置就已经可以了，要是准备深入学习还是建议用专业的方法来解决这个问题。","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"},{"name":"time synchronization","slug":"time-synchronization","permalink":"https://xiao_feng_yang993.gitee.io/tags/time-synchronization/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"给linux终端设置代理","slug":"linux下为终端设置代理","date":"2020-03-07T09:35:36.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/07/linux下为终端设置代理/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/07/linux%E4%B8%8B%E4%B8%BA%E7%BB%88%E7%AB%AF%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/","excerpt":"","text":"在安装showdsocks的情况下，浏览器就可以正常实现通过代理访问了，但是对于linux用户来说，终端是个常用的工具，如何给终端设置代理让终端也能通过代理进行访问呢？ 1. curl，wget这俩是常用的命令，实现代理的方式是 （1）安装polipo1sudo apt-get install polipo （2）配置 polipo1sudo vim &#x2F;etc&#x2F;polipo&#x2F;config 在它的末尾添加以下命令，或者去掉以下命令前面的注释符号；若此文件不存在，则自己创建 12socksParentProxy &#x3D; &quot;localhost:1080&quot;socksProxyType &#x3D; socks5 （3）重新启动 polipo 服务1sudo systemctl restart polipo.service 查看状态 1sudo systemctl status polipo.service 得到类似如下结果 1234567891011121314polipo.service - LSB: Start or stop the polipo web cache Loaded: loaded (&#x2F;etc&#x2F;init.d&#x2F;polipo; generated; vendor preset: enabled) Active: active (running) since Tue 2019-12-03 03:24:15 CST; 34min ago Docs: man:systemd-sysv-generator(8) Process: 4799 ExecStop&#x3D;&#x2F;etc&#x2F;init.d&#x2F;polipo stop (code&#x3D;exited, status&#x3D;0&#x2F;SUCCESS) Process: 4806 ExecStart&#x3D;&#x2F;etc&#x2F;init.d&#x2F;polipo start (code&#x3D;exited, status&#x3D;0&#x2F;SUCCESS) Tasks: 1 (limit: 4915) CGroup: &#x2F;system.slice&#x2F;polipo.service └─4817 &#x2F;usr&#x2F;bin&#x2F;polipo -c &#x2F;etc&#x2F;polipo&#x2F;config pidFile&#x3D;&#x2F;var&#x2F;run&#x2F;polipo&#x2F;polipo.pid daemonise&#x3D;true12月 03 03:24:15 systemd[1]: Starting LSB: Start or stop the polipo web cache...12月 03 03:24:15 polipo[4817]: Established listening socket on port 8123.12月 03 03:24:15 polipo[4806]: Starting polipo: polipo.12月 03 03:24:15 systemd[1]: Started LSB: Start or stop the polipo web cache. （4）终端设置代理环境，如果想长期生效的那么在 .zshrc 或者 .bashrc 下增加12export http_proxy&#x3D;http:&#x2F;&#x2F;localhost:8123 export https_proxy&#x3D;http:&#x2F;&#x2F;localhost:8123 polipo 的默认端口时 8123 这时wget和curl都可以通过代理实现访问了，但是想要通过apt安装软件却任然不行 2. apt在apt的配置文件目录下创建代理配置文件： 123sudo vim &#x2F;etc&#x2F;apt&#x2F;apt.conf.d&#x2F;10proxy #这个文件正常不存在，会新建一个#编辑内容为：Acquire::http::Proxy &quot;http:&#x2F;&#x2F;localhost:8123&quot;; 退出终端，重新打开。此时便可以通过代理使用apt安装软件了。 3. gitgit是软件从业者常用的一个软件，世界上最大的开源社区github由于服务器在国外，下载速度非常慢，常常需要使用代理服务。 设置代理 123git config --global https.proxy http:&#x2F;&#x2F;localhost:8123git config --global https.proxy https:&#x2F;&#x2F;localhost:8123 取消代理 123git config --global --unset http.proxygit config --global --unset https.proxy 测试效果参考：[https://www.cnblogs.com/andrewwang/p/9293031.html]","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://xiao_feng_yang993.gitee.io/tags/Linux/"},{"name":"proxy","slug":"proxy","permalink":"https://xiao_feng_yang993.gitee.io/tags/proxy/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-03-07T09:09:09.000Z","updated":"2020-05-03T14:05:50.831Z","comments":true,"path":"2020/03/07/hello-world/","link":"","permalink":"https://xiao_feng_yang993.gitee.io/2020/03/07/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://xiao_feng_yang993.gitee.io/tags/hexo/"}],"keywords":[{"name":"技术","slug":"技术","permalink":"https://xiao_feng_yang993.gitee.io/categories/%E6%8A%80%E6%9C%AF/"}]}]}