<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>MiniOS-Arm64 bootloader设计实现 | yangxiaofeng的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
    <meta name="keywords" content="yangxiaofeng,yangxiaofeng's Blog" />
  
  <meta name="description" content="一．概述实现 loader 实现了汇编准备和跳转到 C 程序 EL 等级切换，sp 栈指针，bss 段清理，异常向量和跳转到 C 程序 实现了串口显示 实现了屏幕显示 实现了 sd 读写 实现了 fat32 文件系统及其读取 实现了 mmu 初始化，建立了 2 份页表 加载了 kernel.img 镜像文件，并跳转到 kernel 执  二．具体实现loader 汇编部分树莓派 3 默认从 0x8">
<meta property="og:type" content="article">
<meta property="og:title" content="MiniOS-Arm64 bootloader设计实现">
<meta property="og:url" content="https://xiao_feng_yang993.gitee.io/2023/06/10/MiniOS-Arm64-bootloader%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="yangxiaofeng的博客">
<meta property="og:description" content="一．概述实现 loader 实现了汇编准备和跳转到 C 程序 EL 等级切换，sp 栈指针，bss 段清理，异常向量和跳转到 C 程序 实现了串口显示 实现了屏幕显示 实现了 sd 读写 实现了 fat32 文件系统及其读取 实现了 mmu 初始化，建立了 2 份页表 加载了 kernel.img 镜像文件，并跳转到 kernel 执  二．具体实现loader 汇编部分树莓派 3 默认从 0x8">
<meta property="og:image" content="https://xiao_feng_yang993.gitee.io/images/2023/06/10/b790dde5-fcf3-4692-82df-d901b5a832d1.png">
<meta property="og:image" content="https://xiao_feng_yang993.gitee.io/images/2023/06/10/3cd0094d-0d51-47c2-980c-639354f253bf.png">
<meta property="og:image" content="https://xiao_feng_yang993.gitee.io/images/2023/06/10/c4466dc0-e220-441d-acd3-bd864a8aebd0.png">
<meta property="og:image" content="https://xiao_feng_yang993.gitee.io/images/2023/06/10/913db56c-4244-4261-b05b-5aba30c0e242.png">
<meta property="og:image" content="https://xiao_feng_yang993.gitee.io/images/2023/06/10/14f0f4bb-a5f5-4f86-a7f6-dbae4bbe1408.png">
<meta property="og:image" content="https://xiao_feng_yang993.gitee.io/images/2023/06/10/00c89e6f-fdd3-4c74-9459-620a0860ae61.png">
<meta property="og:image" content="https://xiao_feng_yang993.gitee.io/images/2023/06/10/bc0d1603-1ab1-4a76-9695-395a2bac2903.png">
<meta property="og:image" content="https://xiao_feng_yang993.gitee.io/images/2023/06/10/e7bf6600-53d9-4cae-be30-66c229bd736c.png">
<meta property="og:image" content="https://xiao_feng_yang993.gitee.io/images/2023/06/10/44dda5a6-4623-4a38-aa02-6bfed0d62dc1.png">
<meta property="og:image" content="https://xiao_feng_yang993.gitee.io/images/2023/06/10/625743bd-f1e4-4334-8c90-8f0b2ba4034c.png">
<meta property="og:image" content="https://xiao_feng_yang993.gitee.io/images/2023/06/10/53ecc3d2-a5c4-49f4-a3aa-c0c494805943.png">
<meta property="og:image" content="https://xiao_feng_yang993.gitee.io/images/2023/06/10/7a1b0eeb-2796-476d-827f-0c74aadd65fc.png">
<meta property="og:image" content="https://xiao_feng_yang993.gitee.io/images/2023/06/10/31ac6c4c-db24-483b-a985-b232b741d791.png">
<meta property="og:image" content="https://xiao_feng_yang993.gitee.io/images/2023/06/10/eacb7626-af99-4ab4-b6fb-754373fd10fc.png">
<meta property="og:image" content="https://xiao_feng_yang993.gitee.io/images/2023/06/10/5c6d56f9-1bb0-4275-8aae-c3ff0eca2ffb.png">
<meta property="og:image" content="https://xiao_feng_yang993.gitee.io/images/2023/06/10/f1d5795c-020d-4060-bad5-773631ab0fe9.png">
<meta property="og:image" content="https://xiao_feng_yang993.gitee.io/images/2023/06/10/c1ceb1fa-e071-42c5-b1e9-a9b8470da7bb.png">
<meta property="article:published_time" content="2023-06-10T05:59:36.000Z">
<meta property="article:modified_time" content="2023-06-10T05:59:36.396Z">
<meta property="article:author" content="yangxiaofeng">
<meta property="article:tag" content="Linux">
<meta property="article:tag" content="树莓派">
<meta property="article:tag" content="汇编">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://xiao_feng_yang993.gitee.io/images/2023/06/10/b790dde5-fcf3-4692-82df-d901b5a832d1.png">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>

  

  
  

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
      <header id="header">
    <div id="banner"></div>
    <div id="header-outer">
        <div id="header-menu" class="header-menu-pos animated">
            <div class="header-menu-container">
                <a href="/" class="left">
                    <span class="site-title">yangxiaofeng&#39;s Blog</span>
                </a>
                <nav id="header-menu-nav" class="right">
                    
                    <a  href="/">
                        <i class="fa fa-home"></i>
                        <span>Home</span>
                    </a>
                    
                    <a  href="/archives">
                        <i class="fa fa-archive"></i>
                        <span>Archives</span>
                    </a>
                    
                    <a  href="/about">
                        <i class="fa fa-user"></i>
                        <span>About</span>
                    </a>
                    
                </nav>
                <a class="mobile-header-menu-button">
                    <i class="fa fa-bars"></i>
                </a>
            </div>
        </div>
        <div id="header-row">
            <div id="logo">
                <a href="/">
                    <img src="/images/logo.jpg" alt="logo">
                </a>
            </div>
            <div class="header-info">
                <div id="header-title">
                    
                    <h2>
                        yangxiaofeng&#39;s Blog
                    </h2>
                    
                </div>
                <div id="header-description">
                    
                    <h3>
                        技术博客
                    </h3>
                    
                </div>
            </div>
            <nav class="header-nav">
                <div class="social">
                    
                        <a title="yangxiaofeng" target="_blank" href="/">
                            <i class="fa fa-home fa-2x"></i></a>
                    
                        <a title="Github" target="_blank" href="//github.com/yang-xiaofeng1101">
                            <i class="fa fa-github fa-2x"></i></a>
                    
                        <a title="Twitter" target="_blank" href="//twitter.com/FKZx1UZnXdTYBP7">
                            <i class="fa fa-twitter fa-2x"></i></a>
                    
                        <a title="QQ" target="_blank" href="//wpa.qq.com/msgrd?v=3&uin=1649675002&site=qq&menu=yes">
                            <i class="fa fa-qq fa-2x"></i></a>
                    
                </div>
            </nav>
        </div>
    </div>
</header>
      <div class="outer">
        <section id="main" class="body-wrap"><article id="post-MiniOS-Arm64-bootloader设计实现" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 class="post-title" itemprop="name">
      MiniOS-Arm64 bootloader设计实现
    </h1>
    <div class="post-title-bar">
      <ul>
          
              <li>
                  <i class="fa fa-book"></i>
                  
                      <a href="/categories/编程/">编程</a>
                  
              </li>
          
        <li>
          <i class="fa fa-calendar"></i>  2023-06-10
        </li>
        <li>
          <i class="fa fa-eye"></i>
          <span id="busuanzi_value_page_pv"></span>
        </li>
      </ul>
    </div>
  

          
      </header>
    
    <div class="article-entry post-content" itemprop="articleBody">
      
            
            <h1 id="一．概述"><a href="#一．概述" class="headerlink" title="一．概述"></a>一．概述</h1><h3 id="实现-loader"><a href="#实现-loader" class="headerlink" title="实现 loader"></a>实现 loader</h3><ol>
<li>实现了汇编准备和跳转到 C 程序<br> EL 等级切换，sp 栈指针，bss 段清理，异常向量和跳转到 C 程序</li>
<li>实现了串口显示</li>
<li>实现了屏幕显示</li>
<li>实现了 sd 读写</li>
<li>实现了 fat32 文件系统及其读取</li>
<li>实现了 mmu 初始化，建立了 2 份页表</li>
<li>加载了 kernel.img 镜像文件，并跳转到 kernel 执</li>
</ol>
<h1 id="二．具体实现"><a href="#二．具体实现" class="headerlink" title="二．具体实现"></a>二．具体实现</h1><h2 id="loader-汇编部分"><a href="#loader-汇编部分" class="headerlink" title="loader 汇编部分"></a>loader 汇编部分</h2><p>树莓派 3 默认从 0x80000 处执行，loader 程序将被加载到内存的物理地址 0x80000 处</p>
<h3 id="链接器脚本-link-ld"><a href="#链接器脚本-link-ld" class="headerlink" title="链接器脚本 link.ld"></a>链接器脚本 link.ld</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">    .= <span class="number">0x80000</span>;</span><br><span class="line">    .<span class="built_in">text</span> : &#123;KEEP(*(.<span class="built_in">text</span>.boot)) * (.<span class="built_in">text</span>.<span class="built_in">text</span>.*.gnu.linkonce.t *)&#125;</span><br><span class="line">                .rodata : &#123;*(.rodata.rodata.*.gnu.linkonce.r *)&#125;</span><br><span class="line">                .= ALIGN(<span class="number">4096</span>);</span><br><span class="line">    PROVIDE(_data =.);</span><br><span class="line">    .data : &#123;*(.data.data.*.gnu.linkonce.d *)&#125;</span><br><span class="line">                .bss(NOLOAD) :</span><br><span class="line">    &#123;</span><br><span class="line">        .= ALIGN(<span class="number">16</span>);</span><br><span class="line">        __bss_start =.;</span><br><span class="line">        *(.bss.bss.*) * (COMMON)</span><br><span class="line">                            __bss_end =.;</span><br><span class="line">    &#125;</span><br><span class="line">    .= ALIGN(<span class="number">0x00001000</span>); <span class="comment">/*output format buffer*/</span></span><br><span class="line">    _op_buf =.;</span><br><span class="line">    .data.opbuf: &#123; .+= (<span class="number">1</span> &lt;&lt; <span class="number">12</span>); &#125;</span><br><span class="line">    .= ALIGN(<span class="number">0x00001000</span>);</span><br><span class="line">    _fat_buf =.;</span><br><span class="line">    .data.fatbuf: &#123; .+= (<span class="number">4</span> * (<span class="number">1</span> &lt;&lt; <span class="number">12</span>)); &#125;</span><br><span class="line">    .= ALIGN(<span class="number">0x00001000</span>);</span><br><span class="line">    _end =.;</span><br><span class="line">    / DISCARD /: &#123; *(.comment) * (.gnu *)*(.note *)*(.eh_frame *) &#125;</span><br><span class="line">&#125;</span><br><span class="line">__bss_size = (__bss_end - __bss_start) &gt;&gt; <span class="number">3</span>;</span><br><span class="line">_kernel_addr = <span class="number">0xFFFFFF8000200000</span>;</span><br></pre></td></tr></table></figure>

<p>链接器脚本中，首先指定了 elf 程序的起始虚拟地址为 0x80000，接下来是 text 代码段，再往后分别是 rodata，data，bss 段。<br>此外还设置了_op_buf 的 4K 空间用于存储格式化输出显示的 buffer，_fat_buf 的 16k 空间用于存储 fat32 文件系统的数据结构。<br>最 后 是 bss_size 指 明 bss 段 大 小 ，_kernel_addr表明内核加载地址为虚拟地址的0xFFFFFF8000200000。</p>
<h3 id="Start-S"><a href="#Start-S" class="headerlink" title="Start.S"></a>Start.S</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.section <span class="string">".text.boot"</span></span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line"><span class="comment">// read cpu id, stop slave cores</span></span><br><span class="line">mrs x1, mpidr_el1</span><br><span class="line"><span class="keyword">and</span> x1, x1, #<span class="number">3</span></span><br><span class="line">cbz x1, <span class="number">2f</span></span><br><span class="line"><span class="comment">// cpu id &gt; 0, stop</span></span><br><span class="line"><span class="number">1</span>: wfe</span><br><span class="line">b <span class="number">1b</span></span><br><span class="line"><span class="number">2</span>: <span class="comment">// cpu id == 0</span></span><br></pre></td></tr></table></figure>
<p>_start 表示程序入口地址，section “.text.boot”与 link.ld 里的.text.boot 相对应，表示将.text.boot 段放在.text 下.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.<span class="built_in">text</span> : &#123; KEEP(*(.<span class="built_in">text</span>.boot)) *(.<span class="built_in">text</span> .<span class="built_in">text</span>.* .gnu.linkonce.t*) &#125;</span><br></pre></td></tr></table></figure>
<p>程序读取了 cpu 的 id，因为一开始是多核在运行，需要关闭非 0 号核心，对不是 0 的核心跳转到 1 处，运行 wfe 暂停核心进入低功耗模式，并执行死循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>: <span class="comment">// cpu id == 0</span></span><br><span class="line"><span class="comment">// set stack before our code</span></span><br><span class="line">ldr x1, =_start</span><br><span class="line"><span class="comment">// set up EL1</span></span><br><span class="line">mrs x0, CurrentEL</span><br><span class="line"><span class="keyword">and</span> x0, x0, #<span class="number">12</span> <span class="comment">// clear reserved bits</span></span><br><span class="line"><span class="comment">// running at EL3?</span></span><br><span class="line">cmp x0, #<span class="number">12</span></span><br><span class="line">bne <span class="number">5f</span></span><br><span class="line"><span class="comment">// should never be executed, just for completeness</span></span><br><span class="line">mov x2, #<span class="number">0x5b1</span></span><br><span class="line">msr scr_el3, x2</span><br><span class="line">mov x2, #<span class="number">0x3c9</span></span><br><span class="line">msr spsr_el3, x2</span><br><span class="line">adr x2, <span class="number">5f</span></span><br><span class="line">msr elr_el3, x2</span><br><span class="line">eret</span><br></pre></td></tr></table></figure>
<p>将_start 的地址写到 x1 寄存器中，读取 el 等级，判断是否 el3，如果不是 el3 则向后跳转到5处。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// running at EL2?</span></span><br><span class="line"><span class="number">5</span>: cmp x0, #<span class="number">4</span></span><br><span class="line">beq <span class="number">5f</span></span><br><span class="line">msr sp_el1, x1</span><br><span class="line"><span class="comment">// enable CNTP for EL1</span></span><br><span class="line">mrs x0, cnthctl_el2</span><br><span class="line">orr x0, x0, #<span class="number">3</span></span><br><span class="line">msr cnthctl_el2, x0</span><br><span class="line">msr cntvoff_el2, xzr</span><br><span class="line"><span class="comment">// disable coprocessor traps</span></span><br><span class="line">mov x0, #<span class="number">0x33FF</span></span><br><span class="line">msr cptr_el2, x0</span><br><span class="line">msr hstr_el2, xzr</span><br><span class="line">mov x0, #(<span class="number">3</span> &lt;&lt; <span class="number">20</span>)</span><br><span class="line">msr cpacr_el1, x0</span><br><span class="line"><span class="comment">// enable AArch64 in EL1</span></span><br><span class="line">mov x0, #(<span class="number">1</span> &lt;&lt; <span class="number">31</span>) <span class="comment">// AArch64</span></span><br><span class="line">orr x0, x0, #(<span class="number">1</span> &lt;&lt; <span class="number">1</span>) <span class="comment">// SWIO hardwired on Pi3</span></span><br><span class="line">msr hcr_el2, x0</span><br><span class="line">mrs x0, hcr_el2</span><br><span class="line"><span class="comment">// Setup SCTLR access</span></span><br><span class="line">mov x2, #<span class="number">0x0800</span></span><br><span class="line">movk x2, #<span class="number">0x30d0</span>, lsl #<span class="number">16</span></span><br><span class="line">msr sctlr_el1, x2</span><br><span class="line"><span class="comment">// set up exception handlers</span></span><br><span class="line">ldr x2, =_vectors</span><br><span class="line">msr vbar_el1, x2</span><br><span class="line"><span class="comment">// change execution level to EL1</span></span><br><span class="line">mov x2, #<span class="number">0x3c4</span></span><br><span class="line">msr spsr_el2, x2</span><br><span class="line">adr x2, <span class="number">5f</span></span><br><span class="line">msr elr_el2, x2</span><br><span class="line">eret</span><br></pre></td></tr></table></figure>
<p>判断 el 等级是否 el1，如果是，则设置 sp_el1 寄存器，允许 el2 等级下对 el1 的配置寄存器进行控制。关闭核心陷入，打开 el1 的 64 位模式，设置 mmu 控制权限，设置异常向量寄存vbar_el1，设置 el 异常状态，设置 elr_el2 返回地址，表示 5f 的位置，执行 eret 后将进入el1 异常等级，并从5f 处开始执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span>: mov sp, x1</span><br><span class="line"><span class="comment">// clear bss</span></span><br><span class="line">ldr x1, =__bss_start</span><br><span class="line">ldr w2, =__bss_size</span><br><span class="line"><span class="number">3</span>: cbz w2, <span class="number">4f</span></span><br><span class="line">str xzr, [x1], #<span class="number">8</span></span><br><span class="line">sub w2, w2, #<span class="number">1</span></span><br><span class="line">cbnz w2, <span class="number">3b</span></span><br><span class="line"><span class="comment">// jump to C code, should not return</span></span><br><span class="line"><span class="number">4</span>: bl main</span><br><span class="line"><span class="comment">// for failsafe, halt this core too</span></span><br><span class="line">ldr x2, =_kernel_addr</span><br><span class="line">br x2</span><br><span class="line">b <span class="number">1b</span></span><br></pre></td></tr></table></figure>
<p>将代码起点_start 的地址设置为栈指针寄存器的值，将 bss 段内存初始化为 0，带返回地址跳转到 C 程序的 main 函数，跳转到_kernel_addr 位置处执行，最后一个死循环，用于执行异常返回到此后的指令安全。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a dummy exception handler in this tutorial</span></span><br><span class="line">exc_handler:</span><br><span class="line">eret</span><br><span class="line"><span class="comment">// important, code has to be properly aligned</span></span><br><span class="line">.align <span class="number">11</span></span><br><span class="line">_vectors:</span><br><span class="line"><span class="comment">// synchronous</span></span><br><span class="line">.align <span class="number">7</span></span><br><span class="line">mov x0, #<span class="number">0</span></span><br><span class="line">mrs x1, esr_el1</span><br><span class="line">mrs x2, elr_el1</span><br><span class="line">mrs x3, spsr_el1</span><br><span class="line">mrs x4, far_el1</span><br><span class="line">b exc_handler</span><br></pre></td></tr></table></figure>
<h2 id="这里是一些简单的异常处理，设置了异常向量表，异常处理函数-exc-handler。"><a href="#这里是一些简单的异常处理，设置了异常向量表，异常处理函数-exc-handler。" class="headerlink" title="这里是一些简单的异常处理，设置了异常向量表，异常处理函数 exc_handler。"></a>这里是一些简单的异常处理，设置了异常向量表，异常处理函数 exc_handler。</h2><h2 id="C-程序"><a href="#C-程序" class="headerlink" title="C 程序"></a>C 程序</h2><h3 id="gpio-h"><a href="#gpio-h" class="headerlink" title="gpio.h"></a>gpio.h</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MMIO_BASE 0x3F000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPFSEL0 ((volatile unsigned int*)(MMIO_BASE+0x00200000))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPFSEL1 ((volatile unsigned int*)(MMIO_BASE+0x00200004))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPFSEL2 ((volatile unsigned int*)(MMIO_BASE+0x00200008))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPFSEL3 ((volatile unsigned int*)(MMIO_BASE+0x0020000C))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPFSEL4 ((volatile unsigned int*)(MMIO_BASE+0x00200010))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPFSEL5 ((volatile unsigned int*)(MMIO_BASE+0x00200014))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPSET0 ((volatile unsigned int*)(MMIO_BASE+0x0020001C))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPSET1 ((volatile unsigned int*)(MMIO_BASE+0x00200020))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPCLR0 ((volatile unsigned int*)(MMIO_BASE+0x00200028))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPLEV0 ((volatile unsigned int*)(MMIO_BASE+0x00200034))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPLEV1 ((volatile unsigned int*)(MMIO_BASE+0x00200038))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPEDS0 ((volatile unsigned int*)(MMIO_BASE+0x00200040))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPEDS1 ((volatile unsigned int*)(MMIO_BASE+0x00200044))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPHEN0 ((volatile unsigned int*)(MMIO_BASE+0x00200064))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPHEN1 ((volatile unsigned int*)(MMIO_BASE+0x00200068))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPPUD ((volatile unsigned int*)(MMIO_BASE+0x00200094))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPPUDCLK0 ((volatile unsigned int*)(MMIO_BASE+0x00200098))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GPPUDCLK1 ((volatile unsigned int*)(MMIO_BASE+0x0020009C))</span></span><br></pre></td></tr></table></figure>
<p>GPIO(General -purpose input/output):通用型输入输出。GPIO 可以作为一组的输入输出，通过拉高/拉低可以将每个引脚可以设置为不同的逻辑电平，可以用作模拟信号 IO、计数器/定时器、串口，用户可以通过 GPIO 口和硬件进行数据交互(如 UART)、控制硬件工作(如 LED、蜂鸣器等)、读取硬件的工作状态信号（如中断信号）等。此外，在一些IC（Integrated circuit ）中，GPIO 可能是复用的，所以需要配置引脚的行为。<br>这里定义了每个 gpio 接口映射到内存的位置，<strong>MMIO_BASE 内存映射 IO 的起始地址是0x3F000000</strong>.</p>
<h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// set up serial console and linear frame buffer</span></span><br><span class="line">    uart_init();</span><br><span class="line">    lfb_init();</span><br><span class="line">    <span class="keyword">if</span> (sd_init() != SD_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        uart_puts(<span class="string">"Error in sd_init\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> cluster;</span><br><span class="line">    <span class="keyword">if</span> (!fat_getpartition())</span><br><span class="line">    &#123;</span><br><span class="line">        uart_puts(<span class="string">"FAT partition not found???\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// find out file in root directory entries</span></span><br><span class="line">    cluster = fat_getcluster(<span class="string">"KER ELF"</span>);</span><br><span class="line">    <span class="keyword">if</span> (cluster)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// read into memory</span></span><br><span class="line">        data = fat_readfile(cluster);</span><br><span class="line">        <span class="comment">// uart_dump(fat_readfile(cluster));</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        uart_puts(<span class="string">"there is no File\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// set up paging</span></span><br><span class="line">    mmu_init();</span><br><span class="line">    kern_exec(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main.c 阐述了 loader 程序主要的流程，uart 串口初始化，framebuffer 初始化也就是屏幕显示，sd 驱动初始化，获取 fat32 表信息，获取 kernel 文件的簇号，读取 kernel 文件到内存中data 起始地址处，初始化 MMU 建立页表，解析加载 elf 格式的 kernel 程序到_kernel_addr地址处，返回汇编 start.S 中继续执行跳转指令。</p>
<h3 id="mailbox"><a href="#mailbox" class="headerlink" title="mailbox"></a>mailbox</h3><h4 id="mbox-h"><a href="#mbox-h" class="headerlink" title="mbox.h"></a>mbox.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* a properly aligned buffer */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> mbox[<span class="number">36</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBOX_REQUEST 0</span></span><br><span class="line"><span class="comment">/* channels */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBOX_CH_POWER 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBOX_CH_FB 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBOX_CH_VUART 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBOX_CH_VCHIQ 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBOX_CH_LEDS 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBOX_CH_BTNS 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBOX_CH_TOUCH 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBOX_CH_COUNT 7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBOX_CH_PROP 8</span></span><br><span class="line"><span class="comment">/* tags */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBOX_TAG_SETPOWER 0x28001</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBOX_TAG_SETCLKRATE 0x38002</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBOX_TAG_LAST 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbox_call</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> ch)</span></span>;</span><br></pre></td></tr></table></figure>
<p>声明了 mbox[36]数组，设置了 mailbox 相关的一宏定义——请求，channels 和 tags；声明了 mbox_call 函数。</p>
<h4 id="mbox-c"><a href="#mbox-c" class="headerlink" title="mbox.c"></a>mbox.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* mailbox message buffer */</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> __attribute__((aligned(<span class="number">16</span>))) mbox[<span class="number">36</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VIDEOCORE_MBOX (MMIO_BASE+0x0000B880)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBOX_READ ((volatile unsigned int*)(VIDEOCORE_MBOX+0x0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBOX_POLL ((volatile unsigned int*)(VIDEOCORE_MBOX+0x10))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBOX_SENDER ((volatile unsigned int*)(VIDEOCORE_MBOX+0x14))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBOX_STATUS ((volatile unsigned int*)(VIDEOCORE_MBOX+0x18))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBOX_CONFIG ((volatile unsigned int*)(VIDEOCORE_MBOX+0x1C))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBOX_WRITE ((volatile unsigned int*)(VIDEOCORE_MBOX+0x20))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBOX_RESPONSE 0x80000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBOX_FULL 0x80000000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MBOX_EMPTY 0x40000000</span></span><br></pre></td></tr></table></figure>
<p>定义了 mailbox 的 framebuffer channel 的相关宏的 mmap 到内存的地址；<br>定义了 mbox[36]数组，且数组按 16 字节对齐，因为 GPU 对消息地址对齐有这一要求。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Make a mailbox call. Returns 0 on failure, non-zero on success</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mbox_call</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> r = (((<span class="keyword">unsigned</span> <span class="keyword">int</span>)((<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;mbox) &amp; ~<span class="number">0xF</span>) | (ch &amp; <span class="number">0xF</span>));</span><br><span class="line">    <span class="comment">/* wait until we can write to the mailbox */</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"nop"</span>)</span></span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (*MBOX_STATUS &amp; MBOX_FULL);</span><br><span class="line">    <span class="comment">/* write the address of our message to the mailbox with channel identifier */</span></span><br><span class="line">    *MBOX_WRITE = r;</span><br><span class="line">    <span class="comment">/* now wait for the response */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* is there a response? */</span></span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"nop"</span>)</span></span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (*MBOX_STATUS &amp; MBOX_EMPTY);</span><br><span class="line">        <span class="comment">/* is it a response to our message? */</span></span><br><span class="line">        <span class="keyword">if</span> (r == *MBOX_READ)</span><br><span class="line">            <span class="comment">/* is it a valid successful response? */</span></span><br><span class="line">            <span class="keyword">return</span> mbox[<span class="number">1</span>] == MBOX_RESPONSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数实现了通过 mbox 与 GPU 通信的功能；<br>首先在 r 中存储（mbox 的起始地址）&amp;（channel）</p>
<p>树莓派 Mailbox 访问一般流程：<br>要从邮箱中读取：<br>1、读取状态寄存器，直到没有设置 empty 标志<br>2、从读寄存器读取数据<br>3、如果低 4 位与所需的通道编号不匹配，则从 1 开始重复<br>4、高 28 位是返回的数据<br>写入邮箱：<br>1、读取状态寄存器，直到未设置 full 标志<br>2、将数据（移入高 28 位）与通道（低 4 位）一起写入写寄存器<br><img src="/images/2023/06/10/b790dde5-fcf3-4692-82df-d901b5a832d1.png" alt="image.png"><br>需要准备 28 bits 的 buffer address 也就是第一条指令处理 mbox 地址<br>4 bits 的 channel，也就是(ch&amp;0xF)，这里一般用的是 channel 8 也即是宏 MBOX_CH_PROP，其含义是 Request from ARM for response by VC<br>当<em>MBOX_STATUS 的值不为 MBOX_FULL 也就是 0x80000000 时，表示 mailbox 已经准备好接收请求数据了；<br>*MBOX_WRITE = r; 向 MBOX_WRITE 处写入准备的 32bits 变量 r 的值。<br>while 循环中读取</em>MBOX_STATUS 状态，直到不为 MBOX_EMPTY，说明非空就是有 GPU 返回的数据了，读取返回的 response，如果正确说明 mbox_call 执行成功，返回的数据在数组mbox 里，这里的*MBOX_READ 只是返回的状态。</p>
<h3 id="Uart-串口"><a href="#Uart-串口" class="headerlink" title="Uart 串口"></a>Uart 串口</h3><h4 id="Uart-h"><a href="#Uart-h" class="headerlink" title="Uart.h"></a>Uart.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_send</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">uart_getc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_puts</span><span class="params">(<span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_hex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> d)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_dump</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_printf</span><span class="params">(<span class="keyword">char</span> *fmt, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<p>定义了串口相关函数的声明，分别是串口初始化，串口发送，串口获取，串口字符串发送，串口 16 进制发送，串口解析二进制，串口格式化显示 printf。</p>
<h4 id="Uart-c"><a href="#Uart-c" class="headerlink" title="Uart.c"></a>Uart.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* PL011 UART registers */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART0_DR ((volatile unsigned int*)(MMIO_BASE+0x00201000))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART0_FR ((volatile unsigned int*)(MMIO_BASE+0x00201018))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART0_IBRD ((volatile unsigned int*)(MMIO_BASE+0x00201024))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART0_FBRD ((volatile unsigned int*)(MMIO_BASE+0x00201028))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART0_LCRH ((volatile unsigned int*)(MMIO_BASE+0x0020102C))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART0_CR ((volatile unsigned int*)(MMIO_BASE+0x00201030))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART0_IMSC ((volatile unsigned int*)(MMIO_BASE+0x00201038))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UART0_ICR ((volatile unsigned int*)(MMIO_BASE+0x00201044))</span></span><br><span class="line"><span class="comment">// get address from linker</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> _op_buf;</span><br></pre></td></tr></table></figure>
<p>这里定义了 uart0 串口的地址，在 MMIO_BASE 基础上添加一个偏移量。<br>这些寄存器的具体含义见 BCM2837-ARM-Peripherals 的第 177 页，寄存器地址表和简介如下图所示<br><img src="/images/2023/06/10/3cd0094d-0d51-47c2-980c-639354f253bf.png" alt="image.png"><br><img src="/images/2023/06/10/c4466dc0-e220-441d-acd3-bd864a8aebd0.png" alt="image.png"></p>
<p>关于表中是 0x7E 为起始地址，但是代码中用 0x3F 作为起点，原因如下<br><img src="/images/2023/06/10/913db56c-4244-4261-b05b-5aba30c0e242.png" alt="image.png"><br>此处在总线地址 0x7Ennnnnn 公布的外设在物理地址 0x3Fnnnnnn 可用。</p>
<p>_op_buf 是从 link.ld 中获取的符号，其地址作为 printf 格式化输出用的 buffer</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set baud rate and characteristics (115200 8N1) and map to GPIO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> r;</span><br><span class="line">    <span class="comment">/* initialize UART */</span></span><br><span class="line">    *UART0_CR = <span class="number">0</span>; <span class="comment">// turn off UART0</span></span><br><span class="line">    <span class="comment">/* set up clock for consistent divisor values */</span></span><br><span class="line">    mbox[<span class="number">0</span>] = <span class="number">9</span> * <span class="number">4</span>;</span><br><span class="line">    mbox[<span class="number">1</span>] = MBOX_REQUEST;</span><br><span class="line">    mbox[<span class="number">2</span>] = MBOX_TAG_SETCLKRATE; <span class="comment">// set clock rate</span></span><br><span class="line">    mbox[<span class="number">3</span>] = <span class="number">12</span>;</span><br><span class="line">    mbox[<span class="number">4</span>] = <span class="number">8</span>;</span><br><span class="line">    mbox[<span class="number">5</span>] = <span class="number">2</span>;       <span class="comment">// UART clock</span></span><br><span class="line">    mbox[<span class="number">6</span>] = <span class="number">4000000</span>; <span class="comment">// 4Mhz</span></span><br><span class="line">    mbox[<span class="number">7</span>] = <span class="number">0</span>;       <span class="comment">// clear turbo</span></span><br><span class="line">    mbox[<span class="number">8</span>] = MBOX_TAG_LAST;</span><br><span class="line">    mbox_call(MBOX_CH_PROP);</span><br><span class="line">    <span class="comment">/* map UART0 to GPIO pins */</span></span><br><span class="line">    r = *GPFSEL1;</span><br><span class="line">    r &amp;= ~((<span class="number">7</span> &lt;&lt; <span class="number">12</span>) | (<span class="number">7</span> &lt;&lt; <span class="number">15</span>)); <span class="comment">// gpio14, gpio15</span></span><br><span class="line">    r |= (<span class="number">4</span> &lt;&lt; <span class="number">12</span>) | (<span class="number">4</span> &lt;&lt; <span class="number">15</span>);    <span class="comment">// alt0</span></span><br><span class="line">    *GPFSEL1 = r;</span><br><span class="line">    *GPPUD = <span class="number">0</span>; <span class="comment">// enable pins 14 and 15</span></span><br><span class="line">    wait_cycles(<span class="number">150</span>);</span><br><span class="line">    *GPPUDCLK0 = (<span class="number">1</span> &lt;&lt; <span class="number">14</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">15</span>);</span><br><span class="line">    wait_cycles(<span class="number">150</span>);</span><br><span class="line">    *GPPUDCLK0 = <span class="number">0</span>;     <span class="comment">// flush GPIO setup</span></span><br><span class="line">    *UART0_ICR = <span class="number">0x7FF</span>; <span class="comment">// clear interrupts</span></span><br><span class="line">    *UART0_IBRD = <span class="number">2</span>;    <span class="comment">// 115200 baud</span></span><br><span class="line">    *UART0_FBRD = <span class="number">0xB</span>;</span><br><span class="line">    *UART0_LCRH = <span class="number">0b11</span> &lt;&lt; <span class="number">5</span>; <span class="comment">// 8n1</span></span><br><span class="line">    *UART0_CR = <span class="number">0x301</span>;       <span class="comment">// enable Tx, Rx, FIFO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数初始化了 uart0 串口，将 uart0 串口 map 到 gpio 引脚 14 和 15 才能实现输入输出<br><img src="/images/2023/06/10/14f0f4bb-a5f5-4f86-a7f6-dbae4bbe1408.png" alt="image.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Send a character</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_send</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* wait until we can send */</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"nop"</span>)</span></span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (*UART0_FR &amp; <span class="number">0x20</span>);</span><br><span class="line">    <span class="comment">/* write the character to the buffer */</span></span><br><span class="line">    *UART0_DR = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Receive a character</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">uart_getc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> r;</span><br><span class="line">    <span class="comment">/* wait until something is in the buffer */</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"nop"</span>)</span></span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (*UART0_FR &amp; <span class="number">0x10</span>);</span><br><span class="line">    <span class="comment">/* read it and return */</span></span><br><span class="line">    r = (<span class="keyword">char</span>)(*UART0_DR);</span><br><span class="line">    <span class="comment">/* convert carrige return to newline */</span></span><br><span class="line">    <span class="keyword">return</span> r == <span class="string">'\r'</span> ? <span class="string">'\n'</span> : r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UART0_DR 是数据寄存器，UART0_FR 是 flag 寄存器，DR 负责读写数据，FR 负责体现 uart状态。<br>写串口的实现就是先判断 flag 是否可用，如果可用则写 DR 位置。<br>读串口也一样，判断 flag 是否可用，可用则读 DR 位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Display a string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_puts</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (*s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* convert newline to carrige return + newline */</span></span><br><span class="line">        <span class="keyword">if</span> (*s == <span class="string">'\n'</span>)</span><br><span class="line">            uart_send(<span class="string">'\r'</span>);</span><br><span class="line">        uart_send(*s++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Display a binary value in hexadecimal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_hex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">for</span> (c = <span class="number">28</span>; c &gt;= <span class="number">0</span>; c -= <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// get highest tetrad</span></span><br><span class="line">        n = (d &gt;&gt; c) &amp; <span class="number">0xF</span>;</span><br><span class="line">        <span class="comment">// 0-9 =&gt; '0'-'9', 10-15 =&gt; 'A'-'F'</span></span><br><span class="line">        n += n &gt; <span class="number">9</span> ? <span class="number">0x37</span> : <span class="number">0x30</span>;</span><br><span class="line">        uart_send(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Puts 和 hex 只是对源数据进行了简单加工，实现了字符串写入和人可读的 16 进制写入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Dump memory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_dump</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> a, b, d;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">for</span> (a = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ptr; a &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)ptr + <span class="number">0xece0</span>; a += <span class="number">16</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        uart_hex(a);</span><br><span class="line">        uart_puts(<span class="string">": "</span>);</span><br><span class="line">        <span class="keyword">for</span> (b = <span class="number">0</span>; b &lt; <span class="number">16</span>; b++)</span><br><span class="line">        &#123;</span><br><span class="line">            c = *((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)(a + b));</span><br><span class="line">            d = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)c;</span><br><span class="line">            d &gt;&gt;= <span class="number">4</span>;</span><br><span class="line">            d &amp;= <span class="number">0xF</span>;</span><br><span class="line">            d += d &gt; <span class="number">9</span> ? <span class="number">0x37</span> : <span class="number">0x30</span>;</span><br><span class="line">            uart_send(d);</span><br><span class="line">            d = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)c;</span><br><span class="line">            d &amp;= <span class="number">0xF</span>;</span><br><span class="line">            d += d &gt; <span class="number">9</span> ? <span class="number">0x37</span> : <span class="number">0x30</span>;</span><br><span class="line">            uart_send(d);</span><br><span class="line">            uart_send(<span class="string">' '</span>);</span><br><span class="line">            <span class="keyword">if</span> (b % <span class="number">4</span> == <span class="number">3</span>)</span><br><span class="line">                uart_send(<span class="string">' '</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (b = <span class="number">0</span>; b &lt; <span class="number">16</span>; b++)</span><br><span class="line">        &#123;</span><br><span class="line">            c = *((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)(a + b));</span><br><span class="line">            lfb_printf(<span class="string">"%c"</span>, c &lt; <span class="number">32</span> || c &gt;= <span class="number">127</span> ? <span class="string">'.'</span> : c);</span><br><span class="line">            uart_send(c &lt; <span class="number">32</span> || c &gt;= <span class="number">127</span> ? <span class="string">'.'</span> : c);</span><br><span class="line">        &#125;</span><br><span class="line">        uart_send(<span class="string">'\r'</span>);</span><br><span class="line">        uart_send(<span class="string">'\n'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dump 用于格式化显示内存数据，类似于 xxd 命令功能，效果如下：<br><img src="/images/2023/06/10/00c89e6f-fdd3-4c74-9459-620a0860ae61.png" alt="image.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Display a string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">uart_printf</span><span class="params">(<span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __builtin_va_list args;</span><br><span class="line">    __builtin_va_start(args, fmt);</span><br><span class="line">    <span class="comment">// we don't have memory allocation yet, so we</span></span><br><span class="line">    <span class="comment">// simply place our string after our code</span></span><br><span class="line">    <span class="keyword">char</span> *s = (<span class="keyword">char</span> *)&amp;_op_buf;</span><br><span class="line">    <span class="comment">// use sprintf to format our string</span></span><br><span class="line">    <span class="built_in">vsprintf</span>(s, fmt, args);</span><br><span class="line">    <span class="comment">// print out as usual</span></span><br><span class="line">    <span class="keyword">while</span> (*s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* convert newline to carrige return + newline */</span></span><br><span class="line">        <span class="keyword">if</span> (*s == <span class="string">'\n'</span>)</span><br><span class="line">            uart_send(<span class="string">'\r'</span>);</span><br><span class="line">        uart_send(*s++);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>uart_printf 调用 vsprintf 将数据按照 format 格式进行解析重组为一个字符串，将字符串传送到 uart_puts 进行打印。</p>
<h4 id="sprintf-c"><a href="#sprintf-c" class="headerlink" title="sprintf.c"></a>sprintf.c</h4><p>vsprintf 的实现如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * minimal sprintf implementation</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">(<span class="keyword">char</span> *dst, <span class="keyword">char</span> *fmt, __builtin_va_list args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">int</span> arg;</span><br><span class="line">    <span class="keyword">int</span> len, sign, i;</span><br><span class="line">    <span class="keyword">char</span> *p, *orig = dst, tmpstr[<span class="number">19</span>];</span><br><span class="line">    <span class="comment">// failsafes</span></span><br><span class="line">    <span class="keyword">if</span> (dst == (<span class="keyword">void</span> *)<span class="number">0</span> || fmt == (<span class="keyword">void</span> *)<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// main loop</span></span><br><span class="line">    arg = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (*fmt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// argument access</span></span><br><span class="line">        <span class="keyword">if</span> (*fmt == <span class="string">'%'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fmt++;</span><br><span class="line">            <span class="comment">// literal %</span></span><br><span class="line">            <span class="keyword">if</span> (*fmt == <span class="string">'%'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">goto</span> <span class="built_in">put</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// size modifier</span></span><br><span class="line">            <span class="keyword">while</span> (*fmt &gt;= <span class="string">'0'</span> &amp;&amp; *fmt &lt;= <span class="string">'9'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                len *= <span class="number">10</span>;</span><br><span class="line">                len += *fmt - <span class="string">'0'</span>;</span><br><span class="line">                fmt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// skip long modifier</span></span><br><span class="line">            <span class="keyword">if</span> (*fmt == <span class="string">'l'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                fmt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// character</span></span><br><span class="line">            <span class="keyword">if</span> (*fmt == <span class="string">'c'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                arg = __builtin_va_arg(args, <span class="keyword">int</span>);</span><br><span class="line">                *dst++ = (<span class="keyword">char</span>)arg;</span><br><span class="line">                fmt++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// decimal number</span></span><br><span class="line">                <span class="keyword">if</span> (*fmt == <span class="string">'d'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    arg = __builtin_va_arg(args, <span class="keyword">int</span>);</span><br><span class="line">                    <span class="comment">// check input</span></span><br><span class="line">                    sign = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="keyword">int</span>)arg &lt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        arg *= <span class="number">-1</span>;</span><br><span class="line">                        sign++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (arg &gt; <span class="number">99999999999999999L</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        arg = <span class="number">99999999999999999L</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// convert to string</span></span><br><span class="line">                    i = <span class="number">18</span>;</span><br><span class="line">                    tmpstr[i] = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">do</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        tmpstr[--i] = <span class="string">'0'</span> + (arg % <span class="number">10</span>);</span><br><span class="line">                        arg /= <span class="number">10</span>;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (arg != <span class="number">0</span> &amp;&amp; i &gt; <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (sign)</span><br><span class="line">                    &#123;</span><br><span class="line">                        tmpstr[--i] = <span class="string">'-'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// padding, only space</span></span><br><span class="line">                    <span class="keyword">if</span> (len &gt; <span class="number">0</span> &amp;&amp; len &lt; <span class="number">18</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">while</span> (i &gt; <span class="number">18</span> - len)</span><br><span class="line">                        &#123;</span><br><span class="line">                            tmpstr[--i] = <span class="string">' '</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = &amp;tmpstr[i];</span><br><span class="line">                    <span class="keyword">goto</span> copystring;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// hex number</span></span><br><span class="line">                    <span class="keyword">if</span> (*fmt == <span class="string">'x'</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        arg = __builtin_va_arg(args, <span class="keyword">long</span> <span class="keyword">int</span>);</span><br><span class="line">                        <span class="comment">// convert to string</span></span><br><span class="line">                        i = <span class="number">16</span>;</span><br><span class="line">                        tmpstr[i] = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">do</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">char</span> n = arg &amp; <span class="number">0xf</span>;</span><br><span class="line">                            <span class="comment">// 0-9 =&gt; '0'-'9', 10-15 =&gt; 'A'-'F'</span></span><br><span class="line">                            tmpstr[--i] = n + (n &gt; <span class="number">9</span> ? <span class="number">0x37</span> : <span class="number">0x30</span>);</span><br><span class="line">                            arg &gt;&gt;= <span class="number">4</span>;</span><br><span class="line">                        &#125; <span class="keyword">while</span> (arg != <span class="number">0</span> &amp;&amp; i &gt; <span class="number">0</span>);</span><br><span class="line">                        <span class="comment">// padding, only leading zeros</span></span><br><span class="line">                        <span class="keyword">if</span> (len &gt; <span class="number">0</span> &amp;&amp; len &lt;= <span class="number">16</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">while</span> (i &gt; <span class="number">16</span> - len)</span><br><span class="line">                            &#123;</span><br><span class="line">                                tmpstr[--i] = <span class="string">'0'</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        p = &amp;tmpstr[i];</span><br><span class="line">                        <span class="keyword">goto</span> copystring;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">// string</span></span><br><span class="line">                        <span class="keyword">if</span> (*fmt == <span class="string">'s'</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            p = __builtin_va_arg(args, <span class="keyword">char</span> *);</span><br><span class="line">                        copystring:</span><br><span class="line">                            <span class="keyword">if</span> (p == (<span class="keyword">void</span> *)<span class="number">0</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                p = <span class="string">"(null)"</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">while</span> (*p)</span><br><span class="line">                            &#123;</span><br><span class="line">                                *dst++ = *p++;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">put</span>:</span><br><span class="line">            *dst++ = *fmt;</span><br><span class="line">        &#125;</span><br><span class="line">        fmt++;</span><br><span class="line">    &#125;</span><br><span class="line">    *dst = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// number of bytes written</span></span><br><span class="line">    <span class="keyword">return</span> dst - orig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其内容就是根据 fmt 字符串的格式信息对原始参数字符串进行匹配解析和重组。</p>
<h3 id="framebuffer"><a href="#framebuffer" class="headerlink" title="framebuffer"></a>framebuffer</h3><h4 id="lbf-h"><a href="#lbf-h" class="headerlink" title="lbf.h"></a>lbf.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lfb_init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lfb_print</span><span class="params">(<span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lfb_proprint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lfb_printf</span><span class="params">(<span class="keyword">char</span> *fmt, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lfb_clear</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>定义了 framebuffer 初始化，printf 格式化打印，清屏幕，ASCII 编码字符打印(lfb_print)，非ASCII 编码字符打印(lfb_proprint)</p>
<h4 id="lfb-c"><a href="#lfb-c" class="headerlink" title="lfb.c"></a>lfb.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* PC Screen Font as used by Linux Console */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> magic;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> version;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> headersize;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> numglyph;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bytesperglyph;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> glyphs;</span><br><span class="line">&#125; __attribute__((packed)) <span class="keyword">psf_t</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> _binary_font_psf_start;</span><br><span class="line"><span class="comment">/* Scalable Screen Font (https://gitlab.com/bztsrc/scalable-font2) */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> magic[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> type;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> features;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="built_in">width</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="built_in">height</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> baseline;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> underline;</span><br><span class="line">    <span class="keyword">unsigned</span> short fragments_offs;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> characters_offs;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ligature_offs;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> kerning_offs;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> cmap_offs;</span><br><span class="line">&#125; __attribute__((packed)) <span class="keyword">sfn_t</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> _binary_font_sfn_start;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">width</span>, <span class="built_in">height</span>, pitch;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *lfb;</span><br></pre></td></tr></table></figure>
<p>定义了 ASCII 码字符和非 ASCII 字符的数据结构，定义了字体的宽度，高度，pitch。lfb 指针将被指向 frame buffer point。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set screen resolution to 800*600</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lfb_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mbox[<span class="number">0</span>] = <span class="number">35</span> * <span class="number">4</span>;</span><br><span class="line">    mbox[<span class="number">1</span>] = MBOX_REQUEST;</span><br><span class="line">    mbox[<span class="number">2</span>] = <span class="number">0x48003</span>; <span class="comment">// set phy wh</span></span><br><span class="line">    mbox[<span class="number">3</span>] = <span class="number">8</span>;</span><br><span class="line">    mbox[<span class="number">4</span>] = <span class="number">8</span>;</span><br><span class="line">    mbox[<span class="number">5</span>] = <span class="number">800</span>;     <span class="comment">// FrameBufferInfo.width</span></span><br><span class="line">    mbox[<span class="number">6</span>] = <span class="number">600</span>;     <span class="comment">// FrameBufferInfo.height</span></span><br><span class="line">    mbox[<span class="number">7</span>] = <span class="number">0x48004</span>; <span class="comment">// set virt wh</span></span><br><span class="line">    mbox[<span class="number">8</span>] = <span class="number">8</span>;</span><br><span class="line">    mbox[<span class="number">9</span>] = <span class="number">8</span>;</span><br><span class="line">    mbox[<span class="number">10</span>] = <span class="number">800</span>;     <span class="comment">// FrameBufferInfo.virtual_width</span></span><br><span class="line">    mbox[<span class="number">11</span>] = <span class="number">600</span>;     <span class="comment">// FrameBufferInfo.virtual_height</span></span><br><span class="line">    mbox[<span class="number">12</span>] = <span class="number">0x48009</span>; <span class="comment">// set virt offset</span></span><br><span class="line">    mbox[<span class="number">13</span>] = <span class="number">8</span>;</span><br><span class="line">    mbox[<span class="number">14</span>] = <span class="number">8</span>;</span><br><span class="line">    mbox[<span class="number">15</span>] = <span class="number">0</span>;       <span class="comment">// FrameBufferInfo.x_offset</span></span><br><span class="line">    mbox[<span class="number">16</span>] = <span class="number">0</span>;       <span class="comment">// FrameBufferInfo.y.offset</span></span><br><span class="line">    mbox[<span class="number">17</span>] = <span class="number">0x48005</span>; <span class="comment">// set depth</span></span><br><span class="line">    mbox[<span class="number">18</span>] = <span class="number">4</span>;</span><br><span class="line">    mbox[<span class="number">19</span>] = <span class="number">4</span>;</span><br><span class="line">    mbox[<span class="number">20</span>] = <span class="number">32</span>;      <span class="comment">// FrameBufferInfo.depth</span></span><br><span class="line">    mbox[<span class="number">21</span>] = <span class="number">0x48006</span>; <span class="comment">// set pixel order</span></span><br><span class="line">    mbox[<span class="number">22</span>] = <span class="number">4</span>;</span><br><span class="line">    mbox[<span class="number">23</span>] = <span class="number">4</span>;</span><br><span class="line">    mbox[<span class="number">24</span>] = <span class="number">1</span>;       <span class="comment">// RGB, not BGR preferably</span></span><br><span class="line">    mbox[<span class="number">25</span>] = <span class="number">0x40001</span>; <span class="comment">// get framebuffer, gets alignment on request</span></span><br><span class="line">    mbox[<span class="number">26</span>] = <span class="number">8</span>;</span><br><span class="line">    mbox[<span class="number">27</span>] = <span class="number">8</span>;</span><br><span class="line">    mbox[<span class="number">28</span>] = <span class="number">4096</span>;    <span class="comment">// FrameBufferInfo.pointer</span></span><br><span class="line">    mbox[<span class="number">29</span>] = <span class="number">0</span>;       <span class="comment">// FrameBufferInfo.size</span></span><br><span class="line">    mbox[<span class="number">30</span>] = <span class="number">0x40008</span>; <span class="comment">// get pitch</span></span><br><span class="line">    mbox[<span class="number">31</span>] = <span class="number">4</span>;</span><br><span class="line">    mbox[<span class="number">32</span>] = <span class="number">4</span>;</span><br><span class="line">    mbox[<span class="number">33</span>] = <span class="number">0</span>; <span class="comment">// FrameBufferInfo.pitch</span></span><br><span class="line">    mbox[<span class="number">34</span>] = MBOX_TAG_LAST;</span><br><span class="line">    <span class="keyword">if</span> (mbox_call(MBOX_CH_PROP) &amp;&amp; mbox[<span class="number">20</span>] == <span class="number">32</span> &amp;&amp; mbox[<span class="number">28</span>] != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        mbox[<span class="number">28</span>] &amp;= <span class="number">0x3FFFFFFF</span>;</span><br><span class="line">        <span class="built_in">width</span> = mbox[<span class="number">5</span>];</span><br><span class="line">        <span class="built_in">height</span> = mbox[<span class="number">6</span>];</span><br><span class="line">        pitch = mbox[<span class="number">33</span>];</span><br><span class="line">        lfb = (<span class="keyword">void</span> *)((<span class="keyword">unsigned</span> <span class="keyword">long</span>)mbox[<span class="number">28</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        uart_puts(<span class="string">"Unable to set screen resolution to 1024x768x32\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数的功能是初始化 frame buffer，mbox[36]是 CPU 与 GPU 通信的消息传输媒介，设置对应的 mbox 元素数值，调用 mbox_call 发送到 GPU，GPU 返回结果也是在 mbox 数组的对应元素中，其中 mbox[5]表示实际屏幕宽度，mbox[6]表示实际屏幕高度，mbox[33]是FrameBufferInfo.pitch。<br><img src="/images/2023/06/10/bc0d1603-1ab1-4a76-9695-395a2bac2903.png" alt="image.png"><br>lfb 是返回的 framebuffer 的 point，也就是写数据的起始地址，可用简单理解为屏幕左上角<br>第一个像素点的对应的内存地址。<br>framebuffer 初始化的原理见网页 <a href="https://github.com/raspberrypi/firmware/wiki/Mailbox-property-interface#frame-buffer" target="_blank" rel="noopener">https://github.com/raspberrypi/firmware/wiki/Mailbox-property-interface#frame-buffer</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Display a string using fixed size PSF</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lfb_print</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// get our font</span></span><br><span class="line">    <span class="keyword">psf_t</span> *font = (<span class="keyword">psf_t</span> *)&amp;_binary_font_psf_start;</span><br><span class="line">    <span class="comment">// 到屏幕最右侧自动换下一行，到屏幕最底部重新回到第一行显示</span></span><br><span class="line">    <span class="keyword">if</span> (y &gt; <span class="number">589</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">789</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y += font-&gt;<span class="built_in">height</span>;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// draw next character if it's not zero</span></span><br><span class="line">    <span class="keyword">while</span> (*s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// get the offset of the glyph. Need to adjust this to support unicode table</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *glyph = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)&amp;_binary_font_psf_start +</span><br><span class="line">                               font-&gt;headersize + (*((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)s) &lt; font-&gt;numglyph ? *s : <span class="number">0</span>) * font-&gt;bytesperglyph;</span><br><span class="line">        <span class="comment">// calculate the offset on screen</span></span><br><span class="line">        <span class="keyword">int</span> offs = (y * pitch) + (x * <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// variables</span></span><br><span class="line">        <span class="keyword">int</span> i, j, <span class="built_in">line</span>, mask, bytesperline = (font-&gt;<span class="built_in">width</span> + <span class="number">7</span>) / <span class="number">8</span>;</span><br><span class="line">        <span class="comment">// handle carrige return</span></span><br><span class="line">        <span class="keyword">if</span> (*s == <span class="string">'\r'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// new line</span></span><br><span class="line">            <span class="keyword">if</span> (*s == <span class="string">'\n'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                x = <span class="number">0</span>;</span><br><span class="line">                y += font-&gt;<span class="built_in">height</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// display a character</span></span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; font-&gt;<span class="built_in">height</span>; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// display one row</span></span><br><span class="line">                    <span class="built_in">line</span> = offs;</span><br><span class="line">                    mask = <span class="number">1</span> &lt;&lt; (font-&gt;<span class="built_in">width</span> - <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; font-&gt;<span class="built_in">width</span>; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// if bit set, we use white color, otherwise black</span></span><br><span class="line">                        *((<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(lfb + <span class="built_in">line</span>)) = ((<span class="keyword">int</span>)*glyph) &amp; mask ? <span class="number">0xFFFFFF</span> : <span class="number">0</span>;</span><br><span class="line">                        mask &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">                        <span class="built_in">line</span> += <span class="number">4</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// adjust to next line</span></span><br><span class="line">                    glyph += bytesperline;</span><br><span class="line">                    offs += pitch;</span><br><span class="line">                &#125;</span><br><span class="line">                x += (font-&gt;<span class="built_in">width</span> + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="comment">// next character</span></span><br><span class="line">        s++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印 ASCII 编码的字符，屏幕打印的本质是根据字体信息点亮像素点，在字体结构体中根据像素点数据点亮像素点，自动换行和翻页。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * clear the frame</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lfb_clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">600</span> * <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">800</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            *((<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(lfb + i * <span class="number">768</span> + j)) = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>清屏函数，遍历 600*800 的屏幕像素点，设置值为 0 即可，背景黑色的情况下。RGB32 图像每个像素用 32 比特位表示，占 4 个字节，R，G，B 分量分别用 8 个 bit 表示，存储顺序为 B，G，R，最后 8 个字节保留。<br><img src="/images/2023/06/10/e7bf6600-53d9-4cae-be30-66c229bd736c.png" alt="image.png"><br>R = color &amp; 0x0000FF00;<br>G = color &amp; 0x00FF0000;<br>B = color &amp; 0xFF000000;<br>A = color &amp; 0x000000FF;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * format output by frame</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lfb_printf</span><span class="params">(<span class="keyword">char</span> *fmt, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __builtin_va_list args;</span><br><span class="line">    __builtin_va_start(args, fmt);</span><br><span class="line">    <span class="comment">// we don't have memory allocation yet, so we</span></span><br><span class="line">    <span class="comment">// simply place our string after our code</span></span><br><span class="line">    <span class="keyword">char</span> *s = (<span class="keyword">char</span> *)&amp;_op_buf;</span><br><span class="line">    <span class="comment">// use sprintf to format our string</span></span><br><span class="line">    <span class="built_in">vsprintf</span>(s, fmt, args);</span><br><span class="line">    <span class="comment">// print out as usual</span></span><br><span class="line">    lfb_print(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>printf 格式化输出，首先根据 fmt 的格式解析重组参数，将重组的字符串传入 lfb_print.</p>
<h3 id="SD-卡驱动"><a href="#SD-卡驱动" class="headerlink" title="SD 卡驱动"></a>SD 卡驱动</h3><h4 id="sd-h"><a href="#sd-h" class="headerlink" title="sd.h"></a>sd.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SD_OK 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SD_TIMEOUT -1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SD_ERROR -2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sd_init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sd_readblock</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> lba, <span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="built_in">buffer</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> num)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sd_writeblock</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="built_in">buffer</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> lba, <span class="keyword">unsigned</span> <span class="keyword">int</span> num)</span></span>;</span><br></pre></td></tr></table></figure>
<p>声明了三个 sd 接口函数，分别是初始化，从 lba 位置处读取 num 个块数据到 buffer 缓冲<br>区，在 lba 处写入 buffer 里 num 个块的数据。</p>
<h4 id="sd-c"><a href="#sd-c" class="headerlink" title="sd.c"></a>sd.c</h4><p>内容较复杂，单独作为文章。见另一篇 <em>关于emmc访问sd卡的实现与分析</em></p>
<h3 id="F32-文件系统"><a href="#F32-文件系统" class="headerlink" title="F32 文件系统"></a>F32 文件系统</h3><p>为了减小bootloader的体积，bootloader的文件系统部分不需要太复杂，只需能够从sd卡的第一个分区（fat32文件系统）读取指定的elf文件即可，所以没有多级目录等功能。</p>
<h4 id="fat-h"><a href="#fat-h" class="headerlink" title="fat.h"></a>fat.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fat_getpartition</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">fat_getcluster</span><span class="params">(<span class="keyword">char</span> *fn)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fat_readfile</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cluster)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fat_listdirectory</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>定义了四个函数，fat_getpartition 获取 FAT 表；fat_getcluster 获取文件的第一个簇号；fat_readfile 将文件数据读取到内存中，返回首地址；fat_listdirectory 列出根目录下的内容。</p>
<h4 id="fat-c"><a href="#fat-c" class="headerlink" title="fat.c"></a>fat.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">memcmp</span><span class="params">(<span class="keyword">void</span> *s1, <span class="keyword">void</span> *s2, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *a=s1,*b=s2;</span><br><span class="line"><span class="keyword">while</span>(n--&gt;<span class="number">0</span>)&#123; <span class="keyword">if</span>(*a!=*b) &#123; <span class="keyword">return</span> *a-*b; &#125; a++; b++; &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了一个内存比较函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get the starting LBA address of the first partition</span></span><br><span class="line"><span class="comment"> * so that we know where our FAT file system starts, and</span></span><br><span class="line"><span class="comment"> * read that volume's BIOS Parameter Block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fat_getpartition</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *mbr = &amp;_fat_buf;</span><br><span class="line">    <span class="keyword">bpb_t</span> *bpb = (<span class="keyword">bpb_t</span> *)&amp;_fat_buf;</span><br><span class="line">    <span class="comment">// read the partitioning table</span></span><br><span class="line">    <span class="keyword">if</span> (sd_readblock(<span class="number">0</span>, &amp;_fat_buf, <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// check magic</span></span><br><span class="line">        <span class="keyword">if</span> (mbr[<span class="number">510</span>] != <span class="number">0x55</span> || mbr[<span class="number">511</span>] != <span class="number">0xAA</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            uart_puts(<span class="string">"ERROR: Bad magic in MBR\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// check partition type</span></span><br><span class="line">        <span class="keyword">if</span> (mbr[<span class="number">0x1C2</span>] != <span class="number">0xE</span> <span class="comment">/*FAT16 LBA*/</span> &amp;&amp; mbr[<span class="number">0x1C2</span>] != <span class="number">0xC</span> <span class="comment">/*FAT32 LBA*/</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            uart_puts(<span class="string">"ERROR: Wrong partition type\n"</span>);</span><br><span class="line">            <span class="comment">// return 0;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// should be this, but compiler generates bad code...</span></span><br><span class="line">        <span class="comment">// partitionlba=*((unsigned int*)((unsigned long)&amp;_fat_buf+0x1C6));</span></span><br><span class="line">        partitionlba = mbr[<span class="number">0x1C6</span>] + (mbr[<span class="number">0x1C7</span>] &lt;&lt; <span class="number">8</span>) + (mbr[<span class="number">0x1C8</span>] &lt;&lt; <span class="number">16</span>) +</span><br><span class="line">                       (mbr[<span class="number">0x1C9</span>] &lt;&lt; <span class="number">24</span>);</span><br><span class="line">        <span class="comment">// read the boot record</span></span><br><span class="line">        <span class="keyword">if</span> (!sd_readblock(partitionlba, &amp;_fat_buf, <span class="number">1</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            uart_puts(<span class="string">"ERROR: Unable to read boot record\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// check file system type. We don't use cluster numbers for that, but</span></span><br><span class="line">        <span class="function">magic bytes <span class="title">if</span> <span class="params">(!(bpb-&gt;fst[<span class="number">0</span>] == <span class="string">'F'</span> &amp;&amp; bpb-&gt;fst[<span class="number">1</span>] == <span class="string">'A'</span> &amp;&amp; bpb-&gt;fst[<span class="number">2</span>] == <span class="string">'T'</span>) &amp;&amp;</span></span></span><br><span class="line"><span class="function"><span class="params">                        !(bpb-&gt;fst2[<span class="number">0</span>] == <span class="string">'F'</span> &amp;&amp; bpb-&gt;fst2[<span class="number">1</span>] == <span class="string">'A'</span> &amp;&amp; bpb-&gt;fst2[<span class="number">2</span>] == <span class="string">'T'</span>))</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            uart_puts(<span class="string">"ERROR: Unknown file system type\n"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取 sd 的第一个扇区 mbr 分区表，找见 fat32 文件系统所在分区的起始扇区。读取 fat32 文件系统的起始扇区到_fat_buf 位置处，该位置在 link.ld 中已定义。检查文件系统是否是 fat32 类型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Find a file in root directory entries</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">fat_getcluster</span><span class="params">(<span class="keyword">char</span> *fn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bpb_t</span> *bpb = (<span class="keyword">bpb_t</span> *)&amp;_fat_buf;</span><br><span class="line">    <span class="keyword">fatdir_t</span> *dir = (<span class="keyword">fatdir_t</span> *)(&amp;_fat_buf + <span class="number">512</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> root_sec, s;</span><br><span class="line">    <span class="comment">// find the root directory's LBA</span></span><br><span class="line">    root_sec = ((bpb-&gt;spf16 ? bpb-&gt;spf16 : bpb-&gt;spf32) * bpb-&gt;nf) + bpb-&gt;rsc;</span><br><span class="line">    s = (bpb-&gt;nr0 + (bpb-&gt;nr1 &lt;&lt; <span class="number">8</span>)) * <span class="keyword">sizeof</span>(<span class="keyword">fatdir_t</span>);</span><br><span class="line">    <span class="keyword">if</span> (bpb-&gt;spf16 == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// adjust for FAT32</span></span><br><span class="line">        root_sec += (bpb-&gt;rc - <span class="number">2</span>) * bpb-&gt;spc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// add partition LBA</span></span><br><span class="line">    root_sec += partitionlba;</span><br><span class="line">    <span class="comment">// load the root directory</span></span><br><span class="line">    <span class="keyword">if</span> (sd_readblock(root_sec, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)dir, s / <span class="number">512</span> + <span class="number">1</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// iterate on each entry and check if it's the one we're looking for</span></span><br><span class="line">        <span class="keyword">for</span> (; dir-&gt;name[<span class="number">0</span>] != <span class="number">0</span>; dir++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// is it a valid entry?</span></span><br><span class="line">            <span class="keyword">if</span> (dir-&gt;name[<span class="number">0</span>] == <span class="number">0xE5</span> || dir-&gt;attr[<span class="number">0</span>] == <span class="number">0xF</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// filename match?</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">memcmp</span>(dir-&gt;name, fn, <span class="number">11</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// if so, return starting cluster</span></span><br><span class="line">                <span class="keyword">return</span> ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)dir-&gt;ch) &lt;&lt; <span class="number">16</span> | dir-&gt;cl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        uart_puts(<span class="string">"ERROR: file not found\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        uart_puts(<span class="string">"ERROR: Unable to load root directory\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查找根据文件名查找 root 根目录下的文件，如果找见该文件，则返回文件的第一个簇号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">***Read a file into memory</span><br><span class="line">        * /</span><br><span class="line">    <span class="function"><span class="keyword">char</span> *<span class="title">fat_readfile</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> cluster)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// BIOS Parameter Block</span></span><br><span class="line">    <span class="keyword">bpb_t</span> *bpb = (<span class="keyword">bpb_t</span> *)&amp;_fat_buf;</span><br><span class="line">    <span class="comment">// File allocation tables. We choose between FAT16 and FAT32 dynamically</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> *fat32 = (<span class="keyword">unsigned</span> <span class="keyword">int</span> *)(&amp;_fat_buf + bpb-&gt;rsc * <span class="number">512</span>);</span><br><span class="line">    <span class="keyword">unsigned</span> short *fat16 = (<span class="keyword">unsigned</span> short *)fat32;</span><br><span class="line">    <span class="comment">// Data pointers</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> data_sec, s;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *data, *ptr;</span><br><span class="line">    <span class="comment">// find the LBA of the first data sector</span></span><br><span class="line">    data_sec = ((bpb-&gt;spf16 ? bpb-&gt;spf16 : bpb-&gt;spf32) * bpb-&gt;nf) + bpb-&gt;rsc;</span><br><span class="line">    s = (bpb-&gt;nr0 + (bpb-&gt;nr1 &lt;&lt; <span class="number">8</span>)) * <span class="keyword">sizeof</span>(<span class="keyword">fatdir_t</span>);</span><br><span class="line">    <span class="keyword">if</span> (bpb-&gt;spf16 &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// adjust for FAT16</span></span><br><span class="line">        data_sec += (s + <span class="number">511</span>) &gt;&gt; <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// add partition LBA</span></span><br><span class="line">    data_sec += partitionlba;</span><br><span class="line">    <span class="comment">// load FAT table</span></span><br><span class="line">    s = sd_readblock(partitionlba + <span class="number">1</span>, (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)&amp;_fat_buf + <span class="number">512</span>, (bpb-&gt;spf16 ? bpb-&gt;spf16 : bpb-&gt;spf32) + bpb-&gt;rsc);</span><br><span class="line">    <span class="comment">// end of FAT in memory</span></span><br><span class="line">    <span class="comment">// data=ptr=&amp;_fat_buf+512+s;</span></span><br><span class="line">    data = ptr = (<span class="keyword">char</span> *)KERNEL_IMAGE;</span><br><span class="line">    <span class="comment">// iterate on cluster chain</span></span><br><span class="line">    <span class="keyword">while</span> (cluster &gt; <span class="number">1</span> &amp;&amp; cluster &lt; <span class="number">0xFFF8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// load all sectors in a cluster</span></span><br><span class="line">        sd_readblock((cluster - <span class="number">2</span>) * bpb-&gt;spc + data_sec, ptr, bpb-&gt;spc);</span><br><span class="line">        <span class="comment">// move pointer, sector per cluster * bytes per sector</span></span><br><span class="line">        ptr += bpb-&gt;spc * (bpb-&gt;bps0 + (bpb-&gt;bps1 &lt;&lt; <span class="number">8</span>));</span><br><span class="line">        <span class="comment">// get the next cluster in chain</span></span><br><span class="line">        cluster = bpb-&gt;spf16 &gt; <span class="number">0</span> ? fat16[cluster] : fat32[cluster];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">char</span> *)data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>传入参数第一个簇号，计算文件数据第一个扇区的相对 fat32 文件系统分区的 LBA 偏移，将相对偏移添加文件系统起始扇区号变为绝对 LBA 地址，加载 fat 表，根据文件数据的簇号联系读取文件内容到宏定义 KERNEL_IMAGE 位置处，返回文件在内存的起始地址。</p>
<h3 id="MMU"><a href="#MMU" class="headerlink" title="MMU"></a>MMU</h3><h4 id="mmu-h"><a href="#mmu-h" class="headerlink" title="mmu.h"></a>mmu.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmu_init</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setExecPages</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> start_addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> end_addr, <span class="keyword">int</span> attr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>定义了 2 个接口，mmu 初始化，设置页表属性</p>
<h4 id="mmu-c"><a href="#mmu-c" class="headerlink" title="mmu.c"></a>mmu.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_4k 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_1k 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGETABLE_LOW_EL1 (0x200000 - 512*NUM_1k) <span class="comment">// </span></span></span><br><span class="line"><span class="number">0x00000000</span>~<span class="number">0x40000000</span> 映射物理地址 <span class="number">0</span>~<span class="number">1</span>G 到线性地址低端</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGETABLE_HIGH_EL1 (0x200000 - 256*NUM_1k) <span class="comment">// </span></span></span><br><span class="line"><span class="number">0xffffff8000000000</span>~<span class="number">0xffffff8040000000</span> 映射物理地址 <span class="number">0</span>~<span class="number">32</span>M 到线性地址高端</span><br></pre></td></tr></table></figure>
<p>页表初始化时 ttbr0 页表和 ttbr1 页表所在的内存物理地址位置，其中 ttbr0 页表在 1.5MB处，ttbr1 页表在 1.75MB 处，分别是宏定义 PAGETABLE_LOW_EL1 和 PAGETABLE_HIGH_EL1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGESIZE 4096</span></span><br><span class="line"><span class="comment">// granularity</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_PAGE 0b11 <span class="comment">// 4k granule</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_BLOCK 0b01 <span class="comment">// 2M granule</span></span></span><br><span class="line"><span class="comment">// accessibility</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_KERNEL (0&lt;&lt;6) <span class="comment">// privileged, supervisor EL1 access only</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_USER (1&lt;&lt;6) <span class="comment">// unprivileged, EL0 access allowed</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_RW (0&lt;&lt;7) <span class="comment">// read-write</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_RO (1&lt;&lt;7) <span class="comment">// read-only</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_AF (1&lt;&lt;10) <span class="comment">// accessed flag</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_NX (1UL&lt;&lt;54) <span class="comment">// no execute</span></span></span><br><span class="line"><span class="comment">// shareability</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_OSH (2&lt;&lt;8) <span class="comment">// outter shareable</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_ISH (3&lt;&lt;8) <span class="comment">// inner shareable</span></span></span><br><span class="line"><span class="comment">// defined in MAIR register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_MEM (0&lt;&lt;2) <span class="comment">// normal memory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_DEV (1&lt;&lt;2) <span class="comment">// device MMIO</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PT_NC (2&lt;&lt;2) <span class="comment">// non-cachable</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TTBR_CNP 1</span></span><br></pre></td></tr></table></figure>
<p>一些属性相关的宏定义</p>
<h4 id="mmu-init"><a href="#mmu-init" class="headerlink" title="mmu_init"></a>mmu_init</h4><p>内容较长，分段解释</p>
<h5 id="ttbr0-页表"><a href="#ttbr0-页表" class="headerlink" title="ttbr0 页表"></a>ttbr0 页表</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set up page translation tables and enable virtual memory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mmu_init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> data_page = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;_data / PAGESIZE;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r, b, *pagingttbr0 = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)PAGETABLE_LOW_EL1;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *pagingttbr1 = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)PAGETABLE_HIGH_EL1;</span><br></pre></td></tr></table></figure>
<p>用了 2 个 long 类型指针 pagingttbr0 和 pagingttbr1 分别指向 PAGETABLE_LOW_EL1 和PAGETABLE_HIGH_EL1 位置内存。data_page 是 loader 的 data 段与 0x80000 的偏移页表数量。data_page 之前是 text 段，之后是 data 段。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* create MMU translation tables at PAGETABLE_LOW_EL1 */</span></span><br><span class="line"><span class="comment">// TTBR0, identity L1</span></span><br><span class="line">pagingttbr0[<span class="number">0</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)PAGETABLE_LOW_EL1 + PAGESIZE) | <span class="comment">// physical address</span></span><br><span class="line">                 PT_PAGE |                                                        <span class="comment">// it has the "Present" flag, which must be set, and we have area in it mapped by pages</span></span><br><span class="line">                 PT_AF |                                                          <span class="comment">// accessed flag. Without this we're going to have a Data Abort exception</span></span><br><span class="line">                 PT_USER |                                                        <span class="comment">// non-privileged</span></span><br><span class="line">                 PT_ISH |                                                         <span class="comment">// inner shareable</span></span><br><span class="line">                 PT_MEM;                                                          <span class="comment">// normal memory</span></span><br></pre></td></tr></table></figure>
<p>建立 ttbr0 的 level 1 页表第一个表项，指向下一个连续的物理页首地址，因为物理内存仅有1G，level 1 页表只占用 1 个表项</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// identity L2, first 2M block</span></span><br><span class="line">pagingttbr0[<span class="number">1</span> * <span class="number">512</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)PAGETABLE_LOW_EL1 + <span class="number">2</span> * PAGESIZE) | <span class="comment">//</span></span><br><span class="line">                       physical address</span><br><span class="line">                           PT_PAGE | <span class="comment">// we have area in it mapped by pages</span></span><br><span class="line">                       PT_AF |       <span class="comment">// accessed flag</span></span><br><span class="line">                       PT_USER |     <span class="comment">// non-privileged</span></span><br><span class="line">                       PT_ISH |      <span class="comment">// inner shareable</span></span><br><span class="line">                       PT_MEM;       <span class="comment">// normal memory</span></span><br></pre></td></tr></table></figure>
<p>ttbr0 的 level 2 页表，第一个表项指向下一物理页的首地址，以备后续建立 4k map</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// identity L2 2M blocks</span></span><br><span class="line">b = MMIO_BASE &gt;&gt; <span class="number">21</span>;</span><br><span class="line"><span class="comment">// skip 0th, as we're about to map it by L3</span></span><br><span class="line"><span class="keyword">for</span> (r = <span class="number">1</span>; r &lt; <span class="number">512</span>; r++)</span><br><span class="line">    pagingttbr0[<span class="number">1</span> * <span class="number">512</span> + r] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)((r &lt;&lt; <span class="number">21</span>)) |                  <span class="comment">// physical address</span></span><br><span class="line">                               PT_BLOCK |                                    <span class="comment">// map 2M block</span></span><br><span class="line">                               PT_AF |                                       <span class="comment">// accessed flag</span></span><br><span class="line">                               PT_NX |                                       <span class="comment">// no execute</span></span><br><span class="line">                               PT_USER |                                     <span class="comment">// non-privileged</span></span><br><span class="line">                               (r &gt;= b ? PT_OSH | PT_DEV : PT_ISH | PT_MEM); <span class="comment">// different attributes for device</span></span><br><span class="line">memory</span><br></pre></td></tr></table></figure>
<p>ttbr0 的 level 2 页表第 1-511 页用于建立 2M 的 map，可用覆盖 2M~1G 这片物理内存地址空间，区分了常规内存和设备内存，其区别在于——设备内存属性为 outter shareable 和device MMIO，常规内存属性为 inner shareable 和 normal memory。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// identity L3</span></span><br><span class="line"><span class="keyword">for</span>(r=<span class="number">0</span>;r&lt;<span class="number">512</span>;r++)</span><br><span class="line">pagingttbr0[<span class="number">2</span>*<span class="number">512</span>+r]=(<span class="keyword">unsigned</span> <span class="keyword">long</span>)(r*PAGESIZE) | <span class="comment">// physical address</span></span><br><span class="line">PT_PAGE | <span class="comment">// map 4k</span></span><br><span class="line">PT_AF | <span class="comment">// accessed flag</span></span><br><span class="line">PT_USER | <span class="comment">// non-privileged</span></span><br><span class="line">PT_ISH | <span class="comment">// inner shareable</span></span><br><span class="line">((r&lt;<span class="number">0x80</span>||r&gt;=data_page)? PT_RW|PT_NX : PT_RO); <span class="comment">// different for code and data</span></span><br></pre></td></tr></table></figure>
<p>物理地址 0<del>2M 的空间采用了 4k map，位于 level 3 页表上，也就是 loader 所在的地址区间，需要区分程序的代码段和数据段，代码段位于 0x80000</del>data_page*4k 采用只读属性，其余空间采用读写不可执行属性。</p>
<p>ttbr0 的页表结构如下图所示<br><img src="/images/2023/06/10/44dda5a6-4623-4a38-aa02-6bfed0d62dc1.png" alt="image.png"></p>
<h4 id="ttbr1-页表"><a href="#ttbr1-页表" class="headerlink" title="ttbr1 页表"></a>ttbr1 页表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TTBR1, kernel L1</span></span><br><span class="line">pagingttbr1[<span class="number">511</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)PAGETABLE_HIGH_EL1 + PAGESIZE) | <span class="comment">// physical address</span></span><br><span class="line">                   PT_PAGE |                                                         <span class="comment">// we have area in it mapped by pages</span></span><br><span class="line">                   PT_AF |                                                           <span class="comment">// accessed flag</span></span><br><span class="line">                   PT_KERNEL |                                                       <span class="comment">// privileged</span></span><br><span class="line">                   PT_ISH |                                                          <span class="comment">// inner shareable</span></span><br><span class="line">                   PT_MEM;                                                           <span class="comment">// normal memory</span></span><br></pre></td></tr></table></figure>
<p>ttbr1 的 level 1 页表最后一项指向下一物理页，这一表项以后用于设备内存在 ttbr1 的映射。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pagingttbr1[<span class="number">0</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)PAGETABLE_HIGH_EL1 + <span class="number">3</span> * PAGESIZE) | <span class="comment">// physical address</span></span><br><span class="line">                 PT_PAGE |                                                             <span class="comment">// we have area in it mapped by pages</span></span><br><span class="line">                 PT_AF |                                                               <span class="comment">// accessed flag</span></span><br><span class="line">                 PT_KERNEL |                                                           <span class="comment">// privileged</span></span><br><span class="line">                 PT_ISH |                                                              <span class="comment">// inner shareable</span></span><br><span class="line">                 PT_MEM;                                                               <span class="comment">// normal memory</span></span><br></pre></td></tr></table></figure>
<p>ttbr1 的 level 1 页表第一项指向往后第 3 张页表的起始地址，因为只给内核建立 64MB 空间，所以 level 1 页表只需要一个表项，该表项有特权属性 PT_KERNEL.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel L2</span></span><br><span class="line">pagingttbr1[<span class="number">1</span> * <span class="number">512</span> + <span class="number">511</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)PAGETABLE_HIGH_EL1 + <span class="number">2</span> * PAGESIZE) | <span class="comment">//</span></span><br><span class="line">                             physical address</span><br><span class="line">                                 PT_PAGE | <span class="comment">// we have area in it mapped by pages</span></span><br><span class="line">                             PT_AF |       <span class="comment">// accessed flag</span></span><br><span class="line">                             PT_KERNEL |   <span class="comment">// privileged</span></span><br><span class="line">                             PT_ISH |      <span class="comment">// inner shareable</span></span><br><span class="line">                             PT_MEM;       <span class="comment">// normal memory</span></span><br></pre></td></tr></table></figure>
<p>ttbr1 起第二项页表的最后一个表项指向下一个页起始地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (r = <span class="number">0</span>; r &lt; <span class="number">32</span>; r++)</span><br><span class="line">    pagingttbr1[<span class="number">3</span> * <span class="number">512</span> + r] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)PAGETABLE_HIGH_EL1 + <span class="number">4</span> * PAGESIZE + r * PAGESIZE) | <span class="comment">// physical address</span></span><br><span class="line">                               PT_PAGE |                                                                            <span class="comment">// we have area in it mapped by pages</span></span><br><span class="line">                               PT_AF |                                                                              <span class="comment">// accessed flag</span></span><br><span class="line">                               PT_KERNEL |                                                                          <span class="comment">// privileged</span></span><br><span class="line">                               PT_ISH |                                                                             <span class="comment">// inner shareable</span></span><br><span class="line">                               PT_MEM;                                                                              <span class="comment">// normal memory</span></span><br></pre></td></tr></table></figure>
<p>在 level 2 页表中建立 32 个表项，来建立 64MB 的 4k map，每项指向后面连续一张物理页。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) <span class="comment">// 32 * 2M = 64M</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (r = <span class="number">0</span>; r &lt; <span class="number">512</span>; r++)</span><br><span class="line">    &#123;</span><br><span class="line">        pagingttbr1[(<span class="number">4</span> + i) * <span class="number">512</span> + r] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(<span class="number">512</span> * i * PAGESIZE + r * PAGESIZE) | <span class="comment">// physical address</span></span><br><span class="line">                                         PT_PAGE |                                            <span class="comment">// map 4k</span></span><br><span class="line">                                         PT_AF |                                              <span class="comment">// accessed flag</span></span><br><span class="line">                                         PT_KERNEL |                                          <span class="comment">// non-privileged</span></span><br><span class="line">                                         PT_ISH |                                             <span class="comment">// inner shareable</span></span><br><span class="line">                                         PT_RW | PT_NX;                                       <span class="comment">// different for code and data</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ttbr1 的 level 3 页表，共 32 张物理页，每张物理页映射了 2MB 物理内存，每一个表项表示4KB 内存，覆盖了 0~64MB 的物理地址空间，这里内存属性全部暂时默认为了可读写不可执行，因为后续还要加载 kernel elf 文件，需要读写_kernel_addr 位置的内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kernel L3</span></span><br><span class="line">pagingttbr1[<span class="number">2</span> * <span class="number">512</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(MMIO_BASE + <span class="number">0x00201000</span>) | <span class="comment">// physical address</span></span><br><span class="line">                       PT_PAGE |                                 <span class="comment">// map 4k</span></span><br><span class="line">                       PT_AF |                                   <span class="comment">// accessed flag</span></span><br><span class="line">                       PT_NX |                                   <span class="comment">// no execute</span></span><br><span class="line">                       PT_KERNEL |                               <span class="comment">// privileged</span></span><br><span class="line">                       PT_OSH |                                  <span class="comment">// outter shareable</span></span><br><span class="line">                       PT_DEV;                                   <span class="comment">// device memory</span></span><br></pre></td></tr></table></figure>
<p>在 ttbr1 起第三张页表的第一项建立 UART 串口读写的映射，也就是之前 uart 章节里的uart_DR 寄存器，实现用 0xffffff8000201000 地址来读写串口实现显示和输出。<br><img src="/images/2023/06/10/625743bd-f1e4-4334-8c90-8f0b2ba4034c.png" alt="image.png"><br><img src="/images/2023/06/10/53ecc3d2-a5c4-49f4-a3aa-c0c494805943.png" alt="image.png"></p>
<h5 id="enable-MMU-设置"><a href="#enable-MMU-设置" class="headerlink" title="enable MMU 设置"></a>enable MMU 设置</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check for 4k granule and at least 36 bits physical address bus */</span></span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"mrs %0, id_aa64mmfr0_el1"</span></span></span></span><br><span class="line"><span class="function"><span class="params">             : <span class="string">"=r"</span>(r))</span></span>;</span><br><span class="line">b = r &amp; <span class="number">0xF</span>;</span><br><span class="line"><span class="keyword">if</span> (r &amp; (<span class="number">0xF</span> &lt;&lt; <span class="number">28</span>) <span class="comment">/*4k*/</span> || b &lt; <span class="number">1</span> <span class="comment">/*36 bits*/</span>)</span><br><span class="line">&#123;</span><br><span class="line">    uart_puts(<span class="string">"ERROR: 4k granule or 36 bit address space not supported\n"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查 AArch64 内存模型特性寄存器 0，AArch64 Memory Model Feature Register 0 的值，判断 cpu 是否支持 4K 和至少 bus 有 36bit 的宽度，因为三级页表+4K 占 3*9+11=36bit。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// first, set Memory Attributes array, indexed by PT_MEM, PT_DEV, PT_NC in our</span></span><br><span class="line">example</span><br><span class="line">    r = (<span class="number">0xFF</span> &lt;&lt; <span class="number">0</span>) | <span class="comment">// AttrIdx=0: normal, IWBWA, OWBWA, NTR</span></span><br><span class="line">        (<span class="number">0x04</span> &lt;&lt; <span class="number">8</span>) | <span class="comment">// AttrIdx=1: device, nGnRE (must be OSH too)</span></span><br><span class="line">        (<span class="number">0x44</span> &lt;&lt; <span class="number">16</span>); <span class="comment">// AttrIdx=2: non cacheable</span></span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"msr mair_el1, %0"</span></span></span></span><br><span class="line"><span class="function"><span class="params">             :</span></span></span><br><span class="line"><span class="function"><span class="params">             : <span class="string">"r"</span>(r))</span></span>;</span><br></pre></td></tr></table></figure>
<p>设置页表 mair_el1 属性<br>ARM.v8 架构引入了 mair_el1 寄存器。该寄存器由 8 个部分组成，每个部分为 8 位长。每个这样的部分都配置了一组通用属性。然后，描述符仅指定 mair 部分的索引，而不是直接指定所有属性。这允许仅使用描述符中的 3 位来引用 mair 部分。 mair 部分中每个位的含义在 AArch64-Reference-Manual 的第 3557 页 D13.2.95 节进行了描述。在这里，我们只使用了几个可用的属性选项。这是为 mair 寄存器准备值的代码。<br><img src="/images/2023/06/10/7a1b0eeb-2796-476d-827f-0c74aadd65fc.png" alt="image.png"><br>在这里，我们只使用了 mair 寄存器中 8 个可用插槽中的 3 个。第二个对应于设备内存，第三个对应于普通的不可缓存内存。DEVICE_nGnRnE 和 NORMAL_NOCACHE 是我们将在块描述符中使用的索引，0x04 和 0x44 是我们存储在 mair_el1 寄存器的前 2 个插槽中的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next, specify mapping characteristics in translate control register</span></span><br><span class="line">r = (<span class="number">0b00</span>LL &lt;&lt; <span class="number">37</span>) | <span class="comment">// TBI=0, no tagging</span></span><br><span class="line">    (b &lt;&lt; <span class="number">32</span>) |      <span class="comment">// IPS=autodetected</span></span><br><span class="line">    (<span class="number">0b10</span>LL &lt;&lt; <span class="number">30</span>) | <span class="comment">// TG1=4k</span></span><br><span class="line">    (<span class="number">0b11</span>LL &lt;&lt; <span class="number">28</span>) | <span class="comment">// SH1=3 inner</span></span><br><span class="line">    (<span class="number">0b01</span>LL &lt;&lt; <span class="number">26</span>) | <span class="comment">// ORGN1=1 write back</span></span><br><span class="line">    (<span class="number">0b01</span>LL &lt;&lt; <span class="number">24</span>) | <span class="comment">// IRGN1=1 write back</span></span><br><span class="line">    (<span class="number">0b0</span>LL &lt;&lt; <span class="number">23</span>) |  <span class="comment">// EPD1 enable higher half</span></span><br><span class="line">    (<span class="number">25L</span>L &lt;&lt; <span class="number">16</span>) |   <span class="comment">// T1SZ=25, 3 levels (512G)</span></span><br><span class="line">    (<span class="number">0b00</span>LL &lt;&lt; <span class="number">14</span>) | <span class="comment">// TG0=4k</span></span><br><span class="line">    (<span class="number">0b11</span>LL &lt;&lt; <span class="number">12</span>) | <span class="comment">// SH0=3 inner</span></span><br><span class="line">    (<span class="number">0b01</span>LL &lt;&lt; <span class="number">10</span>) | <span class="comment">// ORGN0=1 write back</span></span><br><span class="line">    (<span class="number">0b01</span>LL &lt;&lt; <span class="number">8</span>) |  <span class="comment">// IRGN0=1 write back</span></span><br><span class="line">    (<span class="number">0b0</span>LL &lt;&lt; <span class="number">7</span>) |   <span class="comment">// EPD0 enable lower half</span></span><br><span class="line">    (<span class="number">25L</span>L &lt;&lt; <span class="number">0</span>);     <span class="comment">// T0SZ=25, 3 levels (512G)</span></span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"msr tcr_el1, %0; isb"</span></span></span></span><br><span class="line"><span class="function"><span class="params">             :</span></span></span><br><span class="line"><span class="function"><span class="params">             : <span class="string">"r"</span>(r))</span></span>;</span><br></pre></td></tr></table></figure>
<p>TCR_EL1 寄存器主要用来控制这 TTBR0 和 TTBR1 两套地址翻译系统，重点是要设置 T0SZ 和T1SZ 为 25，因为我们的页表翻译系统是 3 级页表+4K map，64bit 的地址高 25 位不计入地址翻译。</p>
<p>T1SZ, bits [21:16]和 T0SZ, bits [5:0]定义了虚拟地址的宽度。</p>
<p>TBI1，bit[38]和 TBI0，bit[37]用来控制是否忽略地址的高 8 位（TBI 就是 Top Byte ignored 的<br>意思），如果允许忽略地址的高 8 位，那么 MMU 的硬件在进行地址比对，匹配的时候忽略<br>高八位。</p>
<p>TG1，bits [31:30]和 TG0，bits [15:14]是用来控制 page size 的，可以是 4K，16K 或者 64K。</p>
<p>SH1, bits [29:28]和 SH0, bits [13:12]是用来控制页表所在 memory 的 Shareability attribute。ORGN1, bits [27:26]和 ORGN0, bits [11:10]用来控制页表所在 memory 的 outercachebility attribute 的。</p>
<p>IRGN1, bits [25:24]和IRGN0, bits [9:8]用来控制页表所在memory的inner cachebility attribute的。</p>
<p>最后将 r 的值写入到 tcr_el1 寄存器中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tell the MMU where our translation tables are. TTBR_CNP bit not documented, but required</span></span><br><span class="line"><span class="comment">// lower half, user space</span></span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"msr ttbr0_el1, %0"</span> : : <span class="string">"r"</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)PAGETABLE_LOW_EL1 + TTBR_CNP))</span></span>;</span><br><span class="line"><span class="comment">// upper half, kernel space</span></span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(<span class="string">"msr ttbr1_el1, %0"</span> : : <span class="string">"r"</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)PAGETABLE_HIGH_EL1 + TTBR_CNP))</span></span>;</span><br></pre></td></tr></table></figure>
<p>这两句汇编指令是设置 ttbr0 和 ttbr1 页表寄存器的页表入口地址，分别是宏定义PAGETABLE_LOW_EL1 和 PAGETABLE_HIGH_EL1，TTBR_CNP 是 ASID - 局部页表的地址空间标识。</p>
<h5 id="地址空间标识-ASID"><a href="#地址空间标识-ASID" class="headerlink" title="地址空间标识 ASID"></a>地址空间标识 ASID</h5><p>许多现代的操作系统让所有的应用运行在同样的地址区域，这就是我们提到的用户地址空间。实际上，不同的应用需要不同的地址映射。比如，VA 0x8000 实际转换的物理地址取决于当前正在运行的应用，即每个应用程序自己维护一个页表。</p>
<p>理想状态下，我们希望不同的应用的页表项共存于 TLBs 中，防止上下文切换时 TLB 中没有当前应用（准确地讲应该是指进程）的页表项。但是处理器怎么知道不同应用的 VA 0x8000 对应的物理地址呢？在 ARMv8-A 架构中，用的是 Address Space Identifier (ASIDs)。</p>
<p>对于 EL0/EL1 虚拟地址空间，通过页表项属性字段的 nG 位标记页表为 Global(G)或者 Non-Global(nG)。比如，内核地址映射为全局页表，应用程序地址映射为非全局页表。不管当前执行的是哪个应用程序，全局页表都是生效的；非全局页表只有在特定应用执行时才生效。</p>
<p>非全局页表项在 TLBs 中使用 ASID 标记。在进行 TLB 查找时，将当前选择的 ASID 与TLB 页表项中的 ASID 进行比较。如果不匹配，则表示当前 TLB 页表项无效。下图显示了全局页表和局部页表，以及 ASID 标记：<br><img src="/images/2023/06/10/31ac6c4c-db24-483b-a985-b232b741d791.png" alt="image.png"></p>
<p>上图展示了不同应用的 TLB 页表项可以在缓存中共存，由 ASID 决定哪一个页表项生效。</p>
<p>ASID 保存在两个 TTBRn_EL1 寄存器之中，通常用户空间使用 TTBR0_EL1 寄存器。因此，TTBRn_EL1 寄存器值的更新会同时更新 ASID 和当前生效的页表项。</p>
<p>TTBR0_ELx 和 TTBR1_ELx<br> BADDR - 起始页表项的物理地址<br> ASID - 局部页表的地址空间标识</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// finally, toggle some bits in system control register to enable</span></span><br><span class="line"><span class="function">page translation <span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"dsb ish; isb; mrs %0, sctlr_el1"</span></span></span></span><br><span class="line"><span class="function"><span class="params">                              : <span class="string">"=r"</span>(r))</span></span>;</span><br><span class="line">r |= <span class="number">0xC00800</span>;     <span class="comment">// set mandatory reserved bits</span></span><br><span class="line">r &amp;= ~((<span class="number">1</span> &lt;&lt; <span class="number">25</span>) | <span class="comment">// clear EE, little endian translation tables</span></span><br><span class="line">       (<span class="number">1</span> &lt;&lt; <span class="number">24</span>) | <span class="comment">// clear E0E</span></span><br><span class="line">       (<span class="number">1</span> &lt;&lt; <span class="number">19</span>) | <span class="comment">// clear WXN</span></span><br><span class="line">       (<span class="number">1</span> &lt;&lt; <span class="number">12</span>) | <span class="comment">// clear I, no instruction cache</span></span><br><span class="line">       (<span class="number">1</span> &lt;&lt; <span class="number">4</span>) |  <span class="comment">// clear SA0</span></span><br><span class="line">       (<span class="number">1</span> &lt;&lt; <span class="number">3</span>) |  <span class="comment">// clear SA</span></span><br><span class="line">       (<span class="number">1</span> &lt;&lt; <span class="number">2</span>) |  <span class="comment">// clear C, no cache at all</span></span><br><span class="line">       (<span class="number">1</span> &lt;&lt; <span class="number">1</span>));  <span class="comment">// clear A, no aligment check</span></span><br><span class="line">r |= (<span class="number">1</span> &lt;&lt; <span class="number">0</span>);     <span class="comment">// set M, enable MMU</span></span><br><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span><span class="params">(<span class="string">"msr sctlr_el1, %0; isb"</span></span></span></span><br><span class="line"><span class="function"><span class="params">             :</span></span></span><br><span class="line"><span class="function"><span class="params">             : <span class="string">"r"</span>(r))</span></span>;</span><br></pre></td></tr></table></figure>
<p>mmu_init 的最后通过设置 sctlr_el1 启动 EL0 和 EL1 的 MMU<br>SCTLR_EL1 是一个对整个系统（包括 memory system）进行控制的寄存器。<br><img src="/images/2023/06/10/eacb7626-af99-4ab4-b6fb-754373fd10fc.png" alt="image.png"><br>C bit[2]是用来 enable 或者 disable EL0 &amp; EL1 的 data cache。具体包括通过 stage 1<br>translation table 访问的 memory 以及对 stage 1 translation table 自身 memory 的访问。<br>I bit[12]是用来 enable 或者 disable EL0 &amp; EL1 的 instruction cache。<br>M bit[0]是用来 enable 或者 disable EL0 &amp; EL1 的 MMU。</p>
<p>其它 bit 位含义介绍见下表</p>
<p><img src="/images/2023/06/10/5c6d56f9-1bb0-4275-8aae-c3ff0eca2ffb.png" alt="image.png"><br><img src="/images/2023/06/10/f1d5795c-020d-4060-bad5-773631ab0fe9.png" alt="image.png"></p>
<h4 id="setExecPages"><a href="#setExecPages" class="headerlink" title="setExecPages"></a>setExecPages</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setExecPages</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> start_addr, <span class="keyword">unsigned</span> <span class="keyword">long</span> end_addr, <span class="keyword">int</span> attr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> r, *paging = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)PAGETABLE_HIGH_EL1;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> *pagingttbr0 = (<span class="keyword">unsigned</span> <span class="keyword">long</span> *)PAGETABLE_LOW_EL1;</span><br><span class="line">    <span class="keyword">if</span> (attr == <span class="number">0</span>) <span class="comment">// 只读不可执行</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) <span class="comment">// 32 * 2M = 64M</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (r = <span class="number">0</span>; r &lt; <span class="number">512</span>; r++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i * <span class="number">512</span> + r) &gt;= start_addr &gt;&gt; <span class="number">12</span> &amp;&amp; (i * <span class="number">512</span> + r) &lt; end_addr &gt;&gt; <span class="number">12</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    paging[(<span class="number">4</span> + i) * <span class="number">512</span> + r] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(<span class="number">512</span> * i * <span class="number">4096</span> + r * <span class="number">4096</span>) | <span class="comment">// physical address</span></span><br><span class="line">                                                PT_PAGE |                                    <span class="comment">// map 4k</span></span><br><span class="line">                                                PT_AF |                                      <span class="comment">// accessed flag</span></span><br><span class="line">                                                PT_KERNEL |                                  <span class="comment">// privileged</span></span><br><span class="line">                                                PT_ISH |                                     <span class="comment">// inner shareable</span></span><br><span class="line">                                                PT_RO | PT_NX;                               <span class="comment">// different for code and data</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这段代码显示了函数的形参，起始地址，终止地址，属性；设置了 rodata 段的页表属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (attr == <span class="number">1</span>) <span class="comment">// 只读可执行</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) <span class="comment">// 32 * 2M = 64M</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (r = <span class="number">0</span>; r &lt; <span class="number">512</span>; r++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i * <span class="number">512</span> + r) &gt;= start_addr &gt;&gt; <span class="number">12</span> &amp;&amp; (i * <span class="number">512</span> + r) &lt; end_addr &gt;&gt; <span class="number">12</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                paging[(<span class="number">4</span> + i) * <span class="number">512</span> + r] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(<span class="number">512</span> * i * <span class="number">4096</span> + r * <span class="number">4096</span>) | <span class="comment">//</span></span><br><span class="line">                                            physical address</span><br><span class="line">                                                PT_PAGE | <span class="comment">// map 4k</span></span><br><span class="line">                                            PT_AF |       <span class="comment">// accessed flag</span></span><br><span class="line">                                            PT_KERNEL |   <span class="comment">// privileged</span></span><br><span class="line">                                            PT_ISH |      <span class="comment">// inner shareable</span></span><br><span class="line">                                            PT_RO;        <span class="comment">// different for code and data</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (attr == <span class="number">2</span>) <span class="comment">// 读写，不可执行</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) <span class="comment">// 32 * 2M = 64M</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (r = <span class="number">0</span>; r &lt; <span class="number">512</span>; r++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((i * <span class="number">512</span> + r) &gt;= start_addr &gt;&gt; <span class="number">12</span> &amp;&amp; (i * <span class="number">512</span> + r) &lt; end_addr &gt;&gt; <span class="number">12</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                paging[(<span class="number">4</span> + i) * <span class="number">512</span> + r] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(<span class="number">512</span> * i * <span class="number">4096</span> + r * <span class="number">4096</span>) | <span class="comment">//</span></span><br><span class="line">                                            physical address</span><br><span class="line">                                                PT_PAGE | <span class="comment">// map 4k</span></span><br><span class="line">                                            PT_AF |       <span class="comment">// accessed flag</span></span><br><span class="line">                                            PT_KERNEL |   <span class="comment">// privileged</span></span><br><span class="line">                                            PT_ISH |      <span class="comment">// inner shareable</span></span><br><span class="line">                                            PT_RW |</span><br><span class="line">                                            PT_NX; <span class="comment">// different for code and data</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个 else if 处理了代码段和 data 段的页表属性设置，主要是读写和执行属性</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (attr == <span class="number">-1</span>) <span class="comment">// USER 可执行读写 kernel 代码</span></span><br><span class="line">&#123;</span><br><span class="line">    pagingttbr0[<span class="number">1</span> * <span class="number">512</span> + <span class="number">1</span>] = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)((<span class="number">1</span> &lt;&lt; <span class="number">21</span>)) | <span class="comment">// physical address</span></span><br><span class="line">                               PT_BLOCK |                   <span class="comment">// map 2M block</span></span><br><span class="line">                               PT_AF |                      <span class="comment">// accessed flag</span></span><br><span class="line">                               PT_USER |                    <span class="comment">// non-privileged</span></span><br><span class="line">                               PT_ISH;                      <span class="comment">// different attributes for device memory</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 else if 分支让 USER 态可以执行 kernel 的 text 代码段，因为创建的第一个用户态程序的指令是在 kernel 中的，以后 kernel 实现了加载 elf 文件后就不再使用这段代码了。</p>
<h3 id="elf-解析与加载"><a href="#elf-解析与加载" class="headerlink" title="elf 解析与加载"></a>elf 解析与加载</h3><h4 id="elf-h"><a href="#elf-h" class="headerlink" title="elf.h"></a>elf.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The ELF file header. This appears at the start of every ELF file. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> e_ident[EI_NIDENT]; <span class="comment">/* Magic number and other info */</span></span><br><span class="line">    Elf64_Half e_type;                <span class="comment">/* Object file type */</span></span><br><span class="line">    Elf64_Half e_machine;             <span class="comment">/* Architecture */</span></span><br><span class="line">    Elf64_Word e_version;             <span class="comment">/* Object file version */</span></span><br><span class="line">    Elf64_Addr e_entry;               <span class="comment">/* Entry point virtual address */</span></span><br><span class="line">    Elf64_Off e_phoff;                <span class="comment">/* Program header table file offset */</span></span><br><span class="line">    Elf64_Off e_shoff;                <span class="comment">/* Section header table file offset */</span></span><br><span class="line">    Elf64_Word e_flags;               <span class="comment">/* Processor-specific flags */</span></span><br><span class="line">    Elf64_Half e_ehsize;              <span class="comment">/* ELF header size in bytes */</span></span><br><span class="line">    Elf64_Half e_phentsize;           <span class="comment">/* Program header table entry size */</span></span><br><span class="line">    Elf64_Half e_phnum;               <span class="comment">/* Program header table entry count */</span></span><br><span class="line">    Elf64_Half e_shentsize;           <span class="comment">/* Section header table entry size */</span></span><br><span class="line">    Elf64_Half e_shnum;               <span class="comment">/* Section header table entry count */</span></span><br><span class="line">    Elf64_Half e_shstrndx;            <span class="comment">/* Section header string table index */</span></span><br><span class="line">&#125; Elf64_Ehdr;</span><br><span class="line"><span class="comment">/* Section header. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf64_Word sh_name;       <span class="comment">/* Section name (string tbl index) */</span></span><br><span class="line">    Elf64_Word sh_type;       <span class="comment">/* Section type */</span></span><br><span class="line">    Elf64_Xword sh_flags;     <span class="comment">/* Section flags */</span></span><br><span class="line">    Elf64_Addr sh_addr;       <span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">    Elf64_Off sh_offset;      <span class="comment">/* Section file offset */</span></span><br><span class="line">    Elf64_Xword sh_size;      <span class="comment">/* Section size in bytes */</span></span><br><span class="line">    Elf64_Word sh_link;       <span class="comment">/* Link to another section */</span></span><br><span class="line">    Elf64_Word sh_info;       <span class="comment">/* Additional section information */</span></span><br><span class="line">    Elf64_Xword sh_addralign; <span class="comment">/* Section alignment */</span></span><br><span class="line">    Elf64_Xword sh_entsize;   <span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf64_Shdr;</span><br><span class="line"><span class="comment">/* Program segment header. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf64_Word p_type;    <span class="comment">/* Segment type */</span></span><br><span class="line">    Elf64_Word p_flags;   <span class="comment">/* Segment flags */</span></span><br><span class="line">    Elf64_Off p_offset;   <span class="comment">/* Segment file offset */</span></span><br><span class="line">    Elf64_Addr p_vaddr;   <span class="comment">/* Segment virtual address */</span></span><br><span class="line">    Elf64_Addr p_paddr;   <span class="comment">/* Segment physical address */</span></span><br><span class="line">    Elf64_Xword p_filesz; <span class="comment">/* Segment size in file */</span></span><br><span class="line">    Elf64_Xword p_memsz;  <span class="comment">/* Segment size in memory */</span></span><br><span class="line">    Elf64_Xword p_align;  <span class="comment">/* Segment alignment */</span></span><br><span class="line">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure>
<p>与 x86 的 miniOS 中的 elf.h 一样，只是将数据结构中的成员类型改为 64 位数据结构，参考了 Linux 的/usr/include/elf.h 文件中对 elf header，Program Header 和 Section header 的定义。</p>
<h4 id="elf-c"><a href="#elf-c" class="headerlink" title="elf.c"></a>elf.c</h4><p>移植自 miniOS-x86，在加载 program 段的时候，做了少许修改，新增内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (Echo_Phdr[ph_num]-&gt;p_flags == <span class="number">0x7</span>) <span class="comment">// 一个 program，多个 section</span></span><br><span class="line">&#123;</span><br><span class="line">    exec_elfPhdrcpy(fd, Echo_Phdr[ph_num], <span class="number">1</span>); <span class="comment">// 进程 Program</span></span><br><span class="line">    <span class="keyword">for</span> (sh_num = <span class="number">0</span>; sh_num &lt; Echo_Ehdr-&gt;e_shnum; sh_num++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Echo_Shdr[sh_num]-&gt;sh_flags == <span class="number">0x6</span>)</span><br><span class="line">        &#123; <span class="comment">// text</span></span><br><span class="line">            start_addr = Echo_Shdr[sh_num]-&gt;sh_addr;</span><br><span class="line">            end_addr = Echo_Shdr[sh_num]-&gt;sh_addr + Echo_Shdr[sh_num]-&gt;sh_size;</span><br><span class="line">            end_addr = end_addr % <span class="number">4096</span> == <span class="number">0</span> ? end_addr : end_addr + (<span class="number">4096</span> - end_addr % <span class="number">4096</span>);</span><br><span class="line">            start_addr &amp;= <span class="number">0x0000007fffffffff</span>;</span><br><span class="line">            end_addr &amp;= <span class="number">0x0000007fffffffff</span>;</span><br><span class="line">            setExecPages(start_addr, end_addr, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Echo_Shdr[sh_num]-&gt;sh_flags == <span class="number">0x32</span>)</span><br><span class="line">        &#123; <span class="comment">// rodata</span></span><br><span class="line">            start_addr = Echo_Shdr[sh_num]-&gt;sh_addr;</span><br><span class="line">            end_addr = Echo_Shdr[sh_num]-&gt;sh_addr + Echo_Shdr[sh_num]-&gt;sh_size;</span><br><span class="line">            end_addr = end_addr % <span class="number">4096</span> == <span class="number">0</span> ? end_addr : end_addr + (<span class="number">4096</span> - end_addr % <span class="number">4096</span>);</span><br><span class="line">            start_addr &amp;= <span class="number">0x0000007fffffffff</span>;</span><br><span class="line">            end_addr &amp;= <span class="number">0x0000007fffffffff</span>;</span><br><span class="line">            setExecPages(start_addr, end_addr, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Echo_Shdr[sh_num]-&gt;sh_flags == <span class="number">0x3</span>)</span><br><span class="line">        &#123; <span class="comment">// bss data</span></span><br><span class="line">            start_addr = Echo_Shdr[sh_num]-&gt;sh_addr;</span><br><span class="line">            end_addr = Echo_Shdr[sh_num]-&gt;sh_addr + Echo_Shdr[sh_num]-&gt;sh_size;</span><br><span class="line">            end_addr = end_addr % <span class="number">4096</span> == <span class="number">0</span> ? end_addr : end_addr + (<span class="number">4096</span> - end_addr % <span class="number">4096</span>);</span><br><span class="line">            start_addr &amp;= <span class="number">0x0000007fffffffff</span>;</span><br><span class="line">            end_addr &amp;= <span class="number">0x0000007fffffffff</span>;</span><br><span class="line">            setExecPages(start_addr, end_addr, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>exec_load 函数中，本次的 kernel 只有一个 LOAD 段，需要对具体的 section 做进一步处理，在 Echo_Phdr[ph_num]-&gt;p_flags 的分类讨论添加一种情况，表示该 LOAD 段属性既有读写又有执行，即 flags==0x7；exec_elfPhdrcpy 用法与 miniOS-x86 一样, 这里需要对不同的段设置页表属性。<br>section 中 text 段，计算完起始页表物理地址后传入 setExecPages 函数设置页表属性为只读可执行<br>section 中 rodata 段，计算完起始页表物理地址后传入 setExecPages 函数设置页表属性为只读不可执行<br>section 中 data，bss 段，计算完起始页表物理地址后传入 setExecPages 函数设置页表属性为可读写不可执行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * read and load kernel.elf</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kern_exec</span><span class="params">(<span class="keyword">char</span> *data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Elf64_Ehdr *Echo_Ehdr;</span><br><span class="line">    Elf64_Phdr *Echo_Phdr[<span class="number">10</span>];</span><br><span class="line">    Elf64_Shdr *Echo_Shdr[<span class="number">20</span>];</span><br><span class="line">    read_elf(data, &amp;Echo_Ehdr, Echo_Phdr, Echo_Shdr);</span><br><span class="line">    exec_load(data, Echo_Ehdr, Echo_Phdr, Echo_Shdr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kern_exec 接口函数将被 main.c 调用，实现 kernel elf 文件的加载和解析。原理与 miniOSx86 一样，不做过多叙述。</p>
<p><img src="/images/2023/06/10/c1ceb1fa-e071-42c5-b1e9-a9b8470da7bb.png" alt="image.png"><br>kernel 的 link.ld 里指定了 kernel.elf 的起始虚拟地址是 0xffffff8000200000</p>

            <div class="post-copyright">
    <div class="content">
        <p>最后更新： 2023年06月10日 13:59</p>
        <p>原始链接： <a class="post-url" href="/2023/06/10/MiniOS-Arm64-bootloader%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/" title="MiniOS-Arm64 bootloader设计实现">https://xiao_feng_yang993.gitee.io/2023/06/10/MiniOS-Arm64-bootloader%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/</a></p>
        <footer>
            <a href="https://xiao_feng_yang993.gitee.io">
                <img src="/images/logo.jpg" alt="yangxiaofeng">
                yangxiaofeng
            </a>
        </footer>
    </div>
</div>

      
        
            
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;">赏</a>
</div>

<div id="reward" class="post-modal reward-lay">
    <a class="close" href="javascript:;" id="reward-close">×</a>
    <span class="reward-title">
        <i class="icon icon-quote-left"></i>
        请我吃糖~
        <i class="icon icon-quote-right"></i>
    </span>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/images/wechat_code.jpg" alt="打赏二维码">
        </div>
        <div class="reward-select">
            
            <label class="reward-select-item checked" data-id="wechat" data-wechat="/images/wechat_code.jpg">
                <img class="reward-select-item-wechat" src="/images/wechat.png" alt="微信">
            </label>
            
            
            <label class="reward-select-item" data-id="alipay" data-alipay="/images/alipay_code.jpg">
                <img class="reward-select-item-alipay" src="/images/alipay.png" alt="支付宝">
            </label>
            
        </div>
    </div>
</div>


        
    </div>
    <footer class="article-footer">
        
        
<div class="post-share">
    <a href="javascript:;" id="share-sub" class="post-share-fab">
        <i class="fa fa-share-alt"></i>
    </a>
    <div class="post-share-list" id="share-list">
        <ul class="share-icons">
          <li>
            <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://xiao_feng_yang993.gitee.io/2023/06/10/MiniOS-Arm64-bootloader%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/&title=《MiniOS-Arm64 bootloader设计实现》 — yangxiaofeng的博客&pic=https://xiao_feng_yang993.gitee.ioimages/logo.jpg" data-title="微博">
              <i class="fa fa-weibo"></i>
            </a>
          </li>
          <li>
            <a class="weixin share-sns" id="wxFab" href="javascript:;" data-title="微信">
              <i class="fa fa-weixin"></i>
            </a>
          </li>
          <li>
            <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://xiao_feng_yang993.gitee.io/2023/06/10/MiniOS-Arm64-bootloader%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/&title=《MiniOS-Arm64 bootloader设计实现》 — yangxiaofeng的博客&source=" data-title="QQ">
              <i class="fa fa-qq"></i>
            </a>
          </li>
          <li>
            <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://xiao_feng_yang993.gitee.io/2023/06/10/MiniOS-Arm64-bootloader%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/" data-title="Facebook">
              <i class="fa fa-facebook"></i>
            </a>
          </li>
          <li>
            <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《MiniOS-Arm64 bootloader设计实现》 — yangxiaofeng的博客&url=https://xiao_feng_yang993.gitee.io/2023/06/10/MiniOS-Arm64-bootloader%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/&via=https://xiao_feng_yang993.gitee.io" data-title="Twitter">
              <i class="fa fa-twitter"></i>
            </a>
          </li>
          <li>
            <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://xiao_feng_yang993.gitee.io/2023/06/10/MiniOS-Arm64-bootloader%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/" data-title="Google+">
              <i class="fa fa-google-plus"></i>
            </a>
          </li>
        </ul>
     </div>
</div>
<div class="post-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" id="wxShare-close">×</a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://xiao_feng_yang993.gitee.io/2023/06/10/MiniOS-Arm64-bootloader%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0/" alt="微信分享二维码">
</div>

<div class="mask"></div>

        
        <ul class="article-footer-menu">
            
            
  <li class="article-footer-tags">
    <i class="fa fa-tags"></i>
      
    <a href="/tags/Linux/" class="color1">Linux</a>
      
    <a href="/tags/树莓派/" class="color4">树莓派</a>
      
    <a href="/tags/汇编/" class="color3">汇编</a>
      
  </li>

        </ul>
        
    </footer>
  </div>
</article>


    <aside class="post-toc-pos post-toc-top" id="post-toc">
        <nav class="post-toc-wrap">
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#一．概述"><span class="post-toc-text">一．概述</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#实现-loader"><span class="post-toc-text">实现 loader</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#二．具体实现"><span class="post-toc-text">二．具体实现</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#loader-汇编部分"><span class="post-toc-text">loader 汇编部分</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#链接器脚本-link-ld"><span class="post-toc-text">链接器脚本 link.ld</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Start-S"><span class="post-toc-text">Start.S</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#这里是一些简单的异常处理，设置了异常向量表，异常处理函数-exc-handler。"><span class="post-toc-text">这里是一些简单的异常处理，设置了异常向量表，异常处理函数 exc_handler。</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#C-程序"><span class="post-toc-text">C 程序</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#gpio-h"><span class="post-toc-text">gpio.h</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#main-c"><span class="post-toc-text">main.c</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#mailbox"><span class="post-toc-text">mailbox</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#mbox-h"><span class="post-toc-text">mbox.h</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#mbox-c"><span class="post-toc-text">mbox.c</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Uart-串口"><span class="post-toc-text">Uart 串口</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Uart-h"><span class="post-toc-text">Uart.h</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Uart-c"><span class="post-toc-text">Uart.c</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#sprintf-c"><span class="post-toc-text">sprintf.c</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#framebuffer"><span class="post-toc-text">framebuffer</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#lbf-h"><span class="post-toc-text">lbf.h</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#lfb-c"><span class="post-toc-text">lfb.c</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SD-卡驱动"><span class="post-toc-text">SD 卡驱动</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#sd-h"><span class="post-toc-text">sd.h</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#sd-c"><span class="post-toc-text">sd.c</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#F32-文件系统"><span class="post-toc-text">F32 文件系统</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#fat-h"><span class="post-toc-text">fat.h</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#fat-c"><span class="post-toc-text">fat.c</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#MMU"><span class="post-toc-text">MMU</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#mmu-h"><span class="post-toc-text">mmu.h</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#mmu-c"><span class="post-toc-text">mmu.c</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#mmu-init"><span class="post-toc-text">mmu_init</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#ttbr0-页表"><span class="post-toc-text">ttbr0 页表</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ttbr1-页表"><span class="post-toc-text">ttbr1 页表</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#enable-MMU-设置"><span class="post-toc-text">enable MMU 设置</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#地址空间标识-ASID"><span class="post-toc-text">地址空间标识 ASID</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#setExecPages"><span class="post-toc-text">setExecPages</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#elf-解析与加载"><span class="post-toc-text">elf 解析与加载</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#elf-h"><span class="post-toc-text">elf.h</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#elf-c"><span class="post-toc-text">elf.c</span></a></li></ol></li></ol></li></ol></li></ol>
        </nav>
    </aside>
    

<nav id="article-nav">
  
  
    <a href="/2022/11/17/%E5%BC%80%E6%BA%90%E9%95%9C%E5%83%8F%E7%AB%99%E5%BB%BA%E8%AE%BE/" id="article-nav-older" class="article-nav-link-wrap">
      <span class="article-nav-title">开源镜像站建设</span>
      <i class="fa fa-hand-o-right" aria-hidden="true"></i>
    </a>
  
</nav>



    
    <!-- <link rel="stylesheet" href="//unpkg.com/gitment/style/default.css">
    <script src="//unpkg.com/gitment/dist/gitment.browser.js"></script>
    <div id="comments">
        <script>
            var gitment = new Gitment({
                owner: 'yang-xiaofeng1101',
                repo: 'yang-xiaofeng1101.github.io',
                oauth: {
                    client_id: 'e460a9c0f66b72f89833',
                    client_secret: '4d3e6140015e2f8b97a7158b70ab99d320256e57',
                },
            })
            gitment.render('comments')
        </script>
    </div> -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<div id="comments">
    <script>
        var gitalk = new Gitalk({
            clientID: 'e460a9c0f66b72f89833',
            clientSecret: '4d3e6140015e2f8b97a7158b70ab99d320256e57',
            repo: 'yang-xiaofeng1101.github.io',      // The repository of store comments,
            owner: 'yang-xiaofeng1101',
            admin: ['yang-xiaofeng1101'],
            id: decodeURI(location.pathname),      // Ensure uniqueness and length less than 50
            distractionFreeMode: false  // Facebook-like distraction free mode
        })
        gitalk.render('comments')
    </script>
</div>
    
</section>
        
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


      <p>
        Powered by  <a href="http://hexo.io/" target="_blank">Hexo</a>
        Theme <a href="//github.com/wongminho/hexo-theme-miho" target="_blank">MiHo</a>
      &copy; 2023 yangxiaofeng<br>
      </p>
    </div>
  </div>
</footer>
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
<script>
  var mihoConfig = {
      root: "https://xiao_feng_yang993.gitee.io",
      animate: true,
      isHome: false,
      share: true,
      reward: 1
  }
</script>
<div class="sidebar">
    <div id="sidebar-search" title="Search">
        <i class="fa fa-search"></i>
    </div>
    <div id="sidebar-category" title="Categories">
        <i class="fa fa-book"></i>
    </div>
    <div id="sidebar-tag" title="Tags">
        <i class="fa fa-tags"></i>
    </div>
    <div id="sidebar-top">
        <span class="sidebar-top-icon"><i class="fa fa-angle-up"></i></span>
    </div>
</div>
<div class="sidebar-menu-box" id="sidebar-menu-box">
    <div class="sidebar-menu-box-container">
        <div id="sidebar-menu-box-categories">
            <a class="category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a><a class="category-link" href="/categories/%E7%BC%96%E7%A8%8B/">编程</a>
        </div>
        <div id="sidebar-menu-box-tags">
            <a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/C/" style="font-size: 12px;">C++</a> <a href="/tags/DMA/" style="font-size: 10px;">DMA</a> <a href="/tags/Dart/" style="font-size: 12px;">Dart</a> <a href="/tags/EMMC/" style="font-size: 12px;">EMMC</a> <a href="/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/tags/cuda/" style="font-size: 14px;">cuda</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/dp/" style="font-size: 10px;">dp</a> <a href="/tags/gcc/" style="font-size: 10px;">gcc</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/proxy/" style="font-size: 10px;">proxy</a> <a href="/tags/thrust/" style="font-size: 10px;">thrust</a> <a href="/tags/time-synchronization/" style="font-size: 10px;">time synchronization</a> <a href="/tags/vscode/" style="font-size: 12px;">vscode</a> <a href="/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" style="font-size: 12px;">位运算</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">排序</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 14px;">树莓派</a> <a href="/tags/%E6%B1%87%E7%BC%96/" style="font-size: 14px;">汇编</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 18px;">算法</a> <a href="/tags/%E7%BC%96%E7%A8%8B/" style="font-size: 16px;">编程</a> <a href="/tags/%E8%B0%83%E8%AF%95/" style="font-size: 14px;">调试</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">软件工程</a> <a href="/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 12px;">链表</a>
        </div>
    </div>
    <a href="javascript:;" class="sidebar-menu-box-close">&times;</a>
</div>
<div class="mobile-header-menu-nav" id="mobile-header-menu-nav">
    <div class="mobile-header-menu-container">
        <span class="title">Menus</span>
        <ul class="mobile-header-menu-navbar">
            
            <li>
                <a  href="/">
                    <i class="fa fa-home"></i><span>Home</span>
                </a>
            </li>
            
            <li>
                <a  href="/archives">
                    <i class="fa fa-archive"></i><span>Archives</span>
                </a>
            </li>
            
            <li>
                <a  href="/about">
                    <i class="fa fa-user"></i><span>About</span>
                </a>
            </li>
            
        </ul>
    </div>
    <div class="mobile-header-tag-container">
        <span class="title">Tags</span>
        <div id="mobile-header-container-tags">
            <a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/C/" style="font-size: 12px;">C++</a> <a href="/tags/DMA/" style="font-size: 10px;">DMA</a> <a href="/tags/Dart/" style="font-size: 12px;">Dart</a> <a href="/tags/EMMC/" style="font-size: 12px;">EMMC</a> <a href="/tags/Linux/" style="font-size: 20px;">Linux</a> <a href="/tags/cuda/" style="font-size: 14px;">cuda</a> <a href="/tags/docker/" style="font-size: 10px;">docker</a> <a href="/tags/dp/" style="font-size: 10px;">dp</a> <a href="/tags/gcc/" style="font-size: 10px;">gcc</a> <a href="/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/tags/proxy/" style="font-size: 10px;">proxy</a> <a href="/tags/thrust/" style="font-size: 10px;">thrust</a> <a href="/tags/time-synchronization/" style="font-size: 10px;">time synchronization</a> <a href="/tags/vscode/" style="font-size: 12px;">vscode</a> <a href="/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/" style="font-size: 12px;">位运算</a> <a href="/tags/%E6%8E%92%E5%BA%8F/" style="font-size: 10px;">排序</a> <a href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/" style="font-size: 14px;">树莓派</a> <a href="/tags/%E6%B1%87%E7%BC%96/" style="font-size: 14px;">汇编</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 18px;">算法</a> <a href="/tags/%E7%BC%96%E7%A8%8B/" style="font-size: 16px;">编程</a> <a href="/tags/%E8%B0%83%E8%AF%95/" style="font-size: 14px;">调试</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" style="font-size: 10px;">软件工程</a> <a href="/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 12px;">链表</a>
        </div>
    </div>
</div>
<div class="search-wrap">
    <span class="search-close">&times;</span>
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
            <i class="icon icon-lg icon-chevron-left"></i>
        </a>
        <input class="search-field" placeholder="Search..." id="keywords">
        <a id="search-submit" href="javascript:;">
            <i class="fa fa-search"></i>
        </a>
    <div class="search-container" id="search-container">
        <ul class="search-result" id="search-result">
        </ul>
    </div>
</div>

<div id="search-tpl">
    <li class="search-result-item">
        <a href="{url}" class="search-item-li">
            <span class="search-item-li-title" title="{title}">{title}</span>
        </a>
    </li>
</div>

<script src="/js/search.js"></script>


<script src="/js/main.js"></script>



  <script src="//cdn.bootcss.com/particles.js/2.0.0/particles.min.js"></script>
  <div id="particles"></div>
  
<script src="/js/particles.js"></script>








  
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.5.0/animate.min.css">

  <script src="//cdn.bootcss.com/scrollReveal.js/3.0.5/scrollreveal.js"></script>
  
<script src="/js/animate.js"></script>



  
<script src="/js/pop-img.js"></script>

  <script>
     $(".article-entry p img").popImg();
  </script>

  </div>
</body>
</html>